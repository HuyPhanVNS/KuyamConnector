(function ($) {
    // fix background flickering under IE6
    try {
        if (document.execCommand)
            document.execCommand('BackgroundImageCache', false, true);
    } catch (e) { }

    var dateCheck = /\d/;
    var whiteSpaceRegExp = /\s+/;
    var version = parseInt($.browser.version.substring(0, 5).replace('.', ''));
    var geckoFlicker = $.browser.mozilla && version >= 180 && version <= 191;
    var dateFormatTokenRegExp = /d{1,4}|M{1,4}|yy(?:yy)?|([Hhmstf])\1*|"[^"]*"|'[^']*'/g;
    var mobileSafari = (navigator.userAgent.search(/like\sMac\sOS\sX;.*Mobile\/\S+/) != -1);
    var mobileSafari41 = (navigator.userAgent.search(/4_1\slike\sMac\sOS\sX;.*Mobile\/\S+/) != -1); // The bug is undetectable there.

    var useTriggerHandler = (function () {
        var dummyEvent = new $.Event("triggerHandlerTest");

        $("<div />").triggerHandler(dummyEvent);

        return !dummyEvent.isDefaultPrevented();
    })();

    var $t = $.telerik = {

        create: function (query, settings) {
            var name = settings.name;
            var options = $.extend({}, $.fn[name].defaults, settings.options);

            return query.each(function () {
                var $$ = $(this);
                options = $.meta ? $.extend({}, options, $$.data()) : options;

                if (!$$.data(name)) {
                    var component = settings.init(this, options);

                    $$.data(name, component);

                    $t.trigger(this, 'load');

                    if (settings.success) settings.success(component);
                }
            });
        },

        toJson: function (o) {
            function serializeArray(array) {
                return '[' + $.map(array, serialize).join(',') + ']';
            }

            function serialize(obj) {
                var result = [];
                for (var key in obj) {
                    var value = obj[key];
                    if ($.isArray(value)) {
                        result.push('"' + key + '":' + serializeArray(value));
                    } else if (typeof value != 'object') {
                        result.push('"' + key + '":"' + (value == null ? "" : value) + '"');
                    } else {
                        result.push('"' + key + '":' + serialize(value));
                    }
                }
                return '{' + result.join(',') + '}';
            }

            if ($.isArray(o)) {
                return serializeArray(o);
            } else {
                return serialize(o);
            }
        },

        delegate: function (context, handler) {
            return function (e) {
                handler.apply(context, [e, this]);
            };
        },

        stop: function (handler, context) {
            return function (e) {
                e.stopPropagation();
                handler.apply(context || this, arguments);
            };
        },

        stopAll: function (handler, context) {
            return function (e) {
                e.preventDefault();
                e.stopPropagation();
                handler.apply(context || this, arguments);
            }
        },

        bind: function (context, events) {
            var $element = $(context.element ? context.element : context);
            $.each(events, function (eventName) {
                if ($.isFunction(this)) $element.bind(eventName, this);
            });
        },

        preventDefault: function (e) {
            e.preventDefault();
        },

        hover: function () {
            $(this).addClass('t-state-hover');
        },

        leave: function () {
            $(this).removeClass('t-state-hover');
        },

        buttonHover: function () {
            $(this).addClass('t-button-hover');
        },

        buttonLeave: function () {
            $(this).removeClass('t-button-hover');
        },

        stringBuilder: function () {
            this.buffer = [];
        },

        ajaxError: function (element, eventName, xhr, status) {
            var prevented = this.trigger(element, eventName,
                {
                    XMLHttpRequest: xhr,
                    textStatus: status
                });

            if (!prevented) {
                if (status == 'error' && xhr.status != '0')
                    alert('Error! The requested URL returned ' + xhr.status + ' - ' + xhr.statusText);
                if (status == 'timeout')
                    alert('Error! Server timeout.');
            }

            return prevented;
        },

        trigger: function (element, eventName, e) {
            e = $.extend(e || {}, new $.Event(eventName));
            if (useTriggerHandler) {
                $(element).triggerHandler(e);
            } else {
                e.stopPropagation();
                $(element).trigger(e);
            }
            return e.isDefaultPrevented();
        },

        // Returns the type as a string. Not full. Used in string formatting
        getType: function (obj) {
            if (obj instanceof Date)
                return 'date';
            if (typeof obj === "number")
                return 'number';
            return 'object';
        },

        formatString: function () {
            var s = arguments[0];

            for (var i = 0, l = arguments.length - 1; i < l; i++) {
                var reg = new RegExp('\\{' + i + '(:([^\\}]+))?\\}', 'gm');

                var argument = arguments[i + 1];

                var formatter = this.formatters[this.getType(argument)];
                if (formatter) {
                    var match = reg.exec(s);
                    if (match)
                        argument = formatter(argument, match[2]);
                }

                s = s.replace(reg, function () {
                    return argument;
                });
            }
            return s;
        },

        splitClassesFromAttr: function (attr) {
            var classRegExp = /class="([^"]*)"/i,
                splitAttr = {
                    classes: '',
                    attributes: ''
                },
                className;

            if (attr) {
                className = classRegExp.exec(attr);
                splitAttr.attributes = $.trim(attr.replace(classRegExp, ""));

                if (className) {
                    splitAttr.classes = className[1];
                }
            }

            return splitAttr;
        },

        getElementZIndex: function (element) {
            var zIndex;
            $(element).parents().andSelf().each(function () {
                zIndex = $(this).css('zIndex');
                if (Number(zIndex)) {
                    zIndex = Number(zIndex) + 1;
                    return false;
                }
            });

            return zIndex == 'auto' ? 1 : zIndex; // 'auto' causes problems if there is Upload behind the dropdown
        },

        scrollbarWidth: function () {
            var div = document.createElement("div"),
                result;

            div.style.cssText = "overflow:scroll;overflow-x:hidden;zoom:1";
            div.innerHTML = "&nbsp;";
            document.body.appendChild(div);

            result = div.offsetWidth - div.scrollWidth;

            document.body.removeChild(div);
            return result;
        },

        lastIndexOf: function (value, character) {
            var characterLength = character.length;
            for (var i = value.length - 1; i > -1; i--)
                if (value.substr(i, characterLength) == character) return i;
            return -1;
        },

        caretPos: function (element) {
            var pos = -1;

            if (document.selection)
                pos = Math.abs(element.document.selection.createRange().moveStart('character', -element.value.length));
            else if (element.selectionStart !== undefined)
                pos = element.selectionStart;

            return pos;
        },

        encode: function (value) {
            return value.replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/\u00a0/g, '&nbsp;')
                        .replace(/'/g, '&#39;');
        },

        formatters: {},

        fx: {},

        cultureInfo: {
            days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            abbrDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            shortestDays: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
            months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
            abbrMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
            longTime: 'h:mm:ss tt',
            longDate: 'dddd, MMMM dd, yyyy',
            shortDate: 'M/d/yyyy',
            shortTime: 'h:mm tt',
            fullDateTime: 'dddd, MMMM dd, yyyy h:mm:ss tt',
            generalDateShortTime: 'M/d/yyyy h:mm tt',
            generalDateTime: 'M/d/yyyy h:mm:ss tt',
            sortableDateTime: "yyyy'-'MM'-'ddTHH':'mm':'ss",
            universalSortableDateTime: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'",
            monthYear: 'MMMM, yyyy',
            monthDay: 'MMMM dd',
            today: 'today',
            tomorrow: 'tomorrow',
            yesterday: 'yesterday',
            next: 'next',
            last: 'last',
            year: 'year',
            month: 'month',
            week: 'week',
            day: 'day',
            am: 'AM',
            pm: 'PM',
            dateSeparator: '/',
            timeSeparator: ':',
            firstDayOfWeek: 0,
            currencydecimaldigits: 2,
            currencydecimalseparator: '.',
            currencygroupseparator: ',',
            currencygroupsize: 3,
            currencynegative: 0,
            currencypositive: 0,
            currencysymbol: '$',
            numericdecimaldigits: 2,
            numericdecimalseparator: '.',
            numericgroupseparator: ',',
            numericgroupsize: 3,
            numericnegative: 1,
            percentdecimaldigits: 2,
            percentdecimalseparator: '.',
            percentgroupseparator: ',',
            percentgroupsize: 3,
            percentnegative: 0,
            percentpositive: 0,
            percentsymbol: '%'
        },

        patterns: {     // * - placeholder for the symbol; n - placeholder for the number
            numeric: {
                negative: ['(n)', '-n', '- n', 'n-', 'n -']
            },
            currency: {
                positive: ['*n', 'n*', '* n', 'n *'],
                negative: ['(*n)', '-*n', '*-n', '*n-', '(n*)', '-n*', 'n-*', 'n*-', '-n *', '-* n', 'n *-', '* n-', '* -n', 'n- *', '(* n)', '(n *)']
            },
            percent: {
                positive: ['n *', 'n*', '*n'],
                negative: ['-n *', '-n*', '-*n']
            }
        }
    };

    var filter, map;

    if (Array.prototype.filter !== undefined) {
        filter = function (array, predicate) {
            return array.filter(predicate);
        }
    } else {
        filter = function (array, predicate) {
            var result = [], length = array.length;

            for (var i = 0; i < length; i++) {
                var value = array[i];

                if (predicate(value, i, array)) {
                    result[result.length] = value;
                }
            }

            return result;
        }
    }

    if (Array.prototype.map !== undefined) {
        map = function (array, callback) {
            return array.map(callback);
        }
    } else {
        map = function (array, callback) {
            var length = array.length, result = new Array(length);

            for (var i = 0; i < length; i++) {
                result[i] = callback(array[i], i, array);
            }

            return result;
        }
    }

    $t.dropDown = function (options) {
        $.extend(this, options);

        this.$element = $(new $t.stringBuilder().cat('<div ')
                                 .catIf(options.attr, options.attr)
                                 .cat('><ul class="t-reset"></ul></div>')
                                 .string())
                                 .addClass("t-popup t-group")
                                 .hide();

        this.$element.delegate('.t-reset > .t-item', 'mouseenter', $t.hover)
                     .delegate('.t-reset > .t-item', 'mouseleave', $t.leave)
                     .delegate('.t-reset > .t-item', 'click',
                        $.proxy(function (e) {
                            if (this.onClick)
                                this.onClick($.extend(e, { item: $(e.target).closest('.t-item')[0] }));
                        }, this));

        this.$element.tScrollable();
    };

    $t.dropDown.prototype = {
        _html: function (data, isEncoded) {
            var html = new $t.stringBuilder();
            if (data) {
                for (var i = 0, length = data.length; i < length; i++) {

                    var text = "&nbsp;",
                        dataItem = data[i];

                    if (dataItem) {
                        if (dataItem.Text !== undefined) {
                            text = dataItem.Text;
                        } else {
                            text = dataItem;
                        }

                        if (isEncoded) {
                            text = $t.encode(text);
                        }

                        if (!text || !text.replace(whiteSpaceRegExp, '')) {
                            text = '&nbsp;';
                        }
                    }

                    var e = {
                        html: text,
                        dataItem: dataItem
                    };

                    if (this.onItemCreate) this.onItemCreate(e);

                    html.cat('<li unselectable="on" class="t-item">').cat(e.html).cat('</li>');
                }
            }
            return html.string();
        },

        open: function (position) {
            if (this.onOpen) this.onOpen();

            if (this.isOpened() || !this.$items) return;

            var $element = this.$element,
                width;

            if (!$element.parent()[0]) {
                $element.hide().appendTo(document.body);
            }

            if ($element[0].style.width == '')
                width = position.outerWidth ? position.outerWidth - 2 : 0;
            else
                width = parseInt(this.attr ? $('<div' + this.attr + '></div>')[0].style.width : $element[0].style.width);

            $element.css('overflowY', 'auto')
                    .css('width', width);

            var elementPosition = position.offset;
            elementPosition.top += position.outerHeight;

            if (mobileSafari) {
                if (!document.body.scrollLeft && !mobileSafari41)
                    elementPosition.left -= window.pageXOffset;
                if (!document.body.scrollTop && !mobileSafari41)
                    elementPosition.top -= window.pageYOffset;
            }

            $t.fx._wrap($element).css($.extend({
                position: 'absolute',
                zIndex: position.zIndex
            }, elementPosition));

            if (geckoFlicker)
                $element.css('overflow', 'hidden');

            $element.parent().show();

            $t.fx.play(this.effects, $element, { direction: 'bottom' }, $.proxy(function () {
                $element.css("overflow", "auto");

                var height = $element.css("height");
                if (height == "auto" || height != "100%") {
                    $element.css("height", "100%");
                }

                var $selectedItems = this.$items.filter('.t-state-selected');
                if ($selectedItems.length) this.scrollTo($selectedItems[0]);
            }, this));
        },

        close: function (e) {
            if (!this.isOpened()) return;

            var $element = this.$element;
            var $items = this.$items;

            if (geckoFlicker)
                $element.css('overflow', 'hidden');

            $t.fx.rewind(this.effects, $element, { direction: 'bottom' }, function () {
                if (geckoFlicker) {
                    $element.css('overflow', 'auto');
                }

                if ($items) {
                    $items.removeClass("t-state-hover"); // removes accidentally triggered hover states while closing
                }

                if ($element.parent(".t-animation-container")[0]) {
                    $element.parent().hide();
                }
            });
        },

        dataBind: function (data, isEncoded) {
            data = data || [];

            var $element = this.$element;

            if ($element[0].style.height == "100%") {
                $element.css("height", "auto");
            }

            var elementHeight = $element[0].style.height,
                height = elementHeight && elementHeight != 'auto' ? elementHeight : '200px',
                $ul = $element.find('> ul');

            $ul[0].innerHTML = this._html(data, isEncoded);

            var $items = this.$items = $ul.children();
            $element.css('height', $items.length > 10 ? height : 'auto');
        },

        highlight: function (li) {
            return $(li).addClass('t-state-selected')
                        .siblings()
                        .removeClass('t-state-selected')
                        .end()
                        .index();
        },

        isOpened: function () {
            return this.$element.is(':visible');
        },

        scrollTo: function (item) {

            if (!item) return;

            var itemOffsetTop = item.offsetTop;
            var itemOffsetHeight = item.offsetHeight;

            var dropDown = this.$element[0];
            var dropDownScrollTop = dropDown.scrollTop;
            var dropDownOffsetHeight = dropDown.clientHeight;
            var bottomDistance = itemOffsetTop + itemOffsetHeight;

            dropDown.scrollTop = dropDownScrollTop > itemOffsetTop
                                    ? itemOffsetTop
                                    : bottomDistance > (dropDownScrollTop + dropDownOffsetHeight)
                                    ? bottomDistance - dropDownOffsetHeight
                                    : dropDownScrollTop;
        }
    };

    $t.datetime = function () {
        if (arguments.length == 0)
            this.value = new Date();
        else if (arguments.length == 1)
            this.value = new Date(arguments[0]);
        else if (arguments.length == 3)
            this.value = new Date(arguments[0], arguments[1], arguments[2]);
        else if (arguments.length == 6)
            this.value = new Date(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
        else
            this.value = new Date(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6]);

        return this;
    }

    $.extend($t.datetime, {
        msPerMinute: 60000,
        msPerDay: 86400000,
        add: function (date, valueToAdd, ignoreDST) {
            var tzOffsetBefore = date.timeOffset();
            var resultDate = new $t.datetime(date.time() + valueToAdd);
            var tzOffsetDiff = resultDate.timeOffset() - tzOffsetBefore;

            if (ignoreDST) {
                return resultDate;
            }

            return new $t.datetime(resultDate.time() + tzOffsetDiff * $t.datetime.msPerMinute);
        },

        subtract: function (date, dateToSubtract) {
            dateToSubtract = new $t.datetime(dateToSubtract).toDate();
            var diff = date.time() - dateToSubtract;
            var tzOffsetDiff = date.timeOffset() - dateToSubtract.timeOffset();
            return diff - (tzOffsetDiff * $t.datetime.msPerMinute);
        },

        firstDayOfMonth: function (date) {
            return new $t.datetime(0)
                        .hours(date.hours())
                        .minutes(date.minutes())
                        .seconds(date.seconds())
                        .milliseconds(date.milliseconds())
                        .year(date.year(), date.month(), 1);
        },

        dst: function () {
            var today = new $t.datetime(),
                midnight = new $t.datetime(today.year(), today.month(), today.date(), 0, 0, 0),
                noon = new $t.datetime(today.year(), today.month(), today.date(), 12, 0, 0);

            return -1 * (midnight.timeOffset() - noon.timeOffset());
        },

        firstVisibleDay: function (date) {
            var firstDayOfWeek = $t.cultureInfo.firstDayOfWeek;
            var firstVisibleDay = new $t.datetime(date.year(), date.month(), 0, date.hours(), date.minutes(), date.seconds(), date.milliseconds());
            while (firstVisibleDay.day() != firstDayOfWeek) {
                $t.datetime.modify(firstVisibleDay, -1 * $t.datetime.msPerDay)
            }
            return firstVisibleDay;
        },

        modify: function (date, value) {
            var tzOffsetBefore = date.timeOffset();
            var resultDate = new $t.datetime(date.time() + value);
            var tzOffsetDiff = resultDate.timeOffset() - tzOffsetBefore;
            date.time(resultDate.time() + tzOffsetDiff * $t.datetime.msPerMinute);
        },

        pad: function (value) {
            if (value < 10)
                return '0' + value;
            return value;
        },

        standardFormat: function (format) {
            var l = $t.cultureInfo;

            var standardFormats = {
                d: l.shortDate,
                D: l.longDate,
                F: l.fullDateTime,
                g: l.generalDateShortTime,
                G: l.generalDateTime,
                m: l.monthDay,
                M: l.monthDay,
                s: l.sortableDateTime,
                t: l.shortTime,
                T: l.longTime,
                u: l.universalSortableDateTime,
                y: l.monthYear,
                Y: l.monthYear
            };

            return standardFormats[format];
        },

        format: function (date, format) {
            var l = $t.cultureInfo;

            var d = date.getDate();
            var day = date.getDay();
            var M = date.getMonth();
            var y = date.getFullYear();
            var h = date.getHours();
            var m = date.getMinutes();
            var s = date.getSeconds();
            var f = date.getMilliseconds();
            var pad = $t.datetime.pad;

            var dateFormatters = {
                d: d,
                dd: pad(d),
                ddd: l.abbrDays[day],
                dddd: l.days[day],

                M: M + 1,
                MM: pad(M + 1),
                MMM: l.abbrMonths[M],
                MMMM: l.months[M],

                yy: pad(y % 100),
                yyyy: y,

                h: h % 12 || 12,
                hh: pad(h % 12 || 12),
                H: h,
                HH: pad(h),

                m: m,
                mm: pad(m),

                s: s,
                ss: pad(s),

                f: Math.floor(f / 100),
                ff: Math.floor(f / 10),
                fff: f,

                tt: h < 12 ? l.am : l.pm
            };

            format = format || 'G';
            format = $t.datetime.standardFormat(format) ? $t.datetime.standardFormat(format) : format;

            return format.replace(dateFormatTokenRegExp, function (match) {
                return match in dateFormatters ? dateFormatters[match] : match.slice(1, match.length - 1);
            });
        },

        parse: function (options) {
            var value = options.value;
            var format = options.format;

            if (value && value.value) return value;

            format = $t.datetime.standardFormat(format) ? $t.datetime.standardFormat(format) : format;
            if (dateCheck.test(value))
                return $t.datetime.parseMachineDate({
                    value: value,
                    format: format,
                    shortYearCutOff: options.shortYearCutOff,
                    baseDate: options.baseDate,
                    AM: $t.cultureInfo.am,
                    PM: $t.cultureInfo.pm
                });

            return $t.datetime.parseByToken ? $t.datetime.parseByToken(value, options.today) : null;
        },

        parseMachineDate: function (options) {

            var AM = options.AM,
                PM = options.PM,
                value = options.value,
                format = options.format,
                baseDate = options.baseDate,
                shortYearCutOff = options.shortYearCutOff || 30,
                year = null,
                month = null,
                day = null,
                hours = 0,
                minutes = 0,
                seconds = 0,
                milliseconds = 0,
                isAM,
                isPM,
                literal = false,
                matches = function (match) {
                    return (formatPosition + 1 < format.length && format.charAt(formatPosition + 1) == match);
                },
            // Returns count of the format character in the date format string
                lookAhead = function (match) {
                    var index = 0;
                    while (matches(match)) {
                        index++;
                        formatPosition++
                    }
                    return index;
                },
            // Extract a number from the string value
                getNumber = function (size) {
                    var digits = new RegExp('^\\d{1,' + size + '}');
                    var num = value.substr(currentTokenIndex).match(digits);
                    if (num) {
                        currentTokenIndex += num[0].length;
                        return parseInt(num[0], 10);
                    } else {
                        return -1;
                    }
                },
            // Extract a name from the string value and convert to an index
                getName = function (names) {
                    for (var i = 0; i < names.length; i++) {
                        if (value.substr(currentTokenIndex, names[i].length) == names[i]) {
                            currentTokenIndex += names[i].length;
                            return i + 1;
                        }
                    }
                    return -1;
                },
                checkLiteral = function () {
                    if (value.charAt(currentTokenIndex) == format.charAt(formatPosition)) {
                        currentTokenIndex++;
                        return true;
                    } else {
                        return false;
                    }
                },
                normalizeTime = function (val) {
                    return val === -1 ? 0 : val;
                },
                count = 0,
                currentTokenIndex = 0,
                valueLength = value.length;

            for (var formatPosition = 0, flength = format.length; formatPosition < flength; formatPosition++) {
                if (currentTokenIndex == valueLength) break;
                if (literal) {
                    checkLiteral();
                    if (format.charAt(formatPosition) == "'")
                        literal = false;
                } else {
                    switch (format.charAt(formatPosition)) {
                        case 'd':
                            count = lookAhead('d');
                            day = count <= 1 ? getNumber(2) : getName($t.cultureInfo[count == 3 ? 'days' : 'abbrDays']);
                            if (day === null || (day < 1 || day > 31)) {
                                return null;
                            }
                            break;
                        case 'M':
                            count = lookAhead('M');
                            month = count <= 1 ? getNumber(2) : getName($t.cultureInfo[count == 3 ? 'months' : 'abbrMonths']);
                            if (month === null || (month < 1 || month > 12)) {
                                return null;
                            }
                            month -= 1;
                            break;
                        case 'y':
                            count = lookAhead('y');
                            year = getNumber(count <= 1 ? 2 : 4);
                            if (year < 0 || year.toString().length <= count) {
                                return null;
                            }
                            break;
                        case 'H': // 0-24 hours
                            count = lookAhead('H');
                            hours = normalizeTime(getNumber(2));
                            if (hours === null || (hours < 0 || hours > 23)) {
                                return null;
                            }
                            break;
                        case 'h': // 0-12 hours
                            lookAhead('h')
                            hours = normalizeTime(getNumber(2));
                            if (hours == 12) {
                                hours = 0;
                            }
                            if (hours === null || (hours < 0 || hours > 11)) {
                                return null;
                            }
                            break;
                        case 'm':
                            lookAhead('m');
                            minutes = normalizeTime(getNumber(2));
                            if (minutes === null || (minutes < 0 || minutes > 59)) {
                                return null;
                            }
                            break;
                        case 's':
                            lookAhead('s');
                            seconds = normalizeTime(getNumber(2));
                            if (seconds === null || (seconds < 0 || seconds > 59)) {
                                return null;
                            }
                            break;
                        case 'f':
                            count = lookAhead('f');
                            milliseconds = normalizeTime(getNumber(count <= 0 ? 1 : count + 1));
                            if (milliseconds === null || (milliseconds < 0 || milliseconds > 999)) {
                                return null;
                            }
                            break;
                        case 't': // AM/PM or A/P
                            count = lookAhead('t');
                            AM = count > 0 ? AM : 'a';
                            PM = count > 0 ? PM : 'p';

                            var subValue = value.substr(currentTokenIndex).toLowerCase();
                            isAM = subValue.indexOf(AM.toLowerCase()) != -1;
                            isPM = subValue.indexOf(PM.toLowerCase()) != -1;

                            currentTokenIndex += isPM ? PM.length : isAM ? AM.length : 0;
                            break;
                        case "'":
                            checkLiteral();
                            literal = true;
                            break;
                        default:
                            if (!checkLiteral()) {
                                return null;
                            }
                    }
                }
            }

            var date = new $t.datetime();

            if (year !== null && year < 100)
                year += date.year() - date.year() % 100 +
                                (year <= shortYearCutOff ? 0 : -100);

            hours = (isPM && hours < 12)
                  ? hours + 12
                  : hours == 12 && isAM
                  ? 0
                  : hours;

            if (baseDate == undefined) {
                if (year === null) year = date.year();

                if (day === null) {
                    day = 1;
                }

                date = new $t.datetime(year, month, day, hours, minutes, seconds, milliseconds);

            } else {
                date = new $t.datetime(year !== null ? year : baseDate.year(),
                                       month !== null ? month : baseDate.month(),
                                       day !== null ? day : baseDate.date(),
                                       hours, minutes, seconds, milliseconds);
            }
            return date;
        }
    });

    $t.datetime.prototype = {

        year: function () {
            if (arguments.length == 0)
                return this.value.getFullYear();
            else if (arguments.length == 1)
                this.value.setFullYear(arguments[0]);
            else
                this.value.setFullYear(arguments[0], arguments[1], arguments[2]);

            return this;
        },

        timeOffset: function () {
            return this.value.getTimezoneOffset();
        },

        day: function () {
            return this.value.getDay();
        },

        toDate: function () {
            return this.value;
        },

        addMonth: function (value) {
            this.month(this.month() + value);
        },

        addYear: function (value) {
            this.year(this.year() + value);
        }
    };

    $.each(["Month", "Date", "Hours", "Minutes", "Seconds", "Milliseconds", "Time"], function (index, timeComponent) {
        $t.datetime.prototype[timeComponent.toLowerCase()] =
            function () {
                if (arguments.length == 1)
                    this.value["set" + timeComponent](arguments[0]);
                else
                    return this.value["get" + timeComponent]();

                return this;
            };
    });

    /* Number formatting ===================================*/
    var customFormatRegEx = /[0#?]/;
    var standartFormatRegEx = /n|p|c/i;

    function round(value, precision) {
        var power = Math.pow(10, precision || 0);
        return Math.round(value * power) / power;
    }

    function reverse(str) {
        return str.split('').reverse().join('');
    }

    function injectInFormat(val, format, appendExtras) {
        var i = 0, j = 0,
            fLength = format.length,
            vLength = val.length,
            builder = new $t.stringBuilder();

        while (i < fLength && j < vLength && format.substring(i).search(customFormatRegEx) >= 0) {

            if (format.charAt(i).match(customFormatRegEx))
                builder.cat(val.charAt(j++));
            else
                builder.cat(format.charAt(i));

            i++;
        }

        builder.catIf(val.substring(j), j < vLength && appendExtras)
               .catIf(format.substring(i), i < fLength);

        var result = reverse(builder.string()),
            zeroIndex;

        if (result.indexOf('#') > -1)
            zeroIndex = result.indexOf('0');

        if (zeroIndex > -1) {
            var first = result.slice(0, zeroIndex),
                second = result.slice(zeroIndex, result.length);
            result = first.replace(/#/g, '') + second.replace(/#/g, '0');
        } else {
            result = result.replace(/#/g, '');
        }

        if (result.indexOf(',') == 0)
            result = result.replace(/,/g, '');

        return appendExtras ? result : reverse(result);
    }

    $t.formatNumber = function (number,
                                format,
                                digits,
                                separator,
                                groupSeparator,
                                groupSize,
                                positive,
                                negative,
                                symbol,
                                isTextBox) {

        if (!format) return number;

        var type, customFormat, negativeFormat, zeroFormat, sign = number < 0;

        format = format.split(':');
        format = format.length > 1 ? format[1].replace('}', '') : format[0];

        var isCustomFormat = customFormatRegEx.test(format) && !standartFormatRegEx.test(format);

        if (isCustomFormat) {
            format = format.split(';');
            customFormat = format[0];
            negativeFormat = format[1];
            zeroFormat = format[2];
            format = (sign && negativeFormat ? negativeFormat : customFormat).indexOf('%') != -1 ? 'p' : 'n';
        }

        switch (format.toLowerCase().charAt(0)) {
            case 'd':
                return Math.round(number).toString();
            case 'c':
                type = 'currency'; break;
            case 'n':
                type = 'numeric'; break;
            case 'p':
                type = 'percent';
                if (!isTextBox) number = Math.abs(number) * 100;
                break;
            default:
                return number.toString();
        }

        var matches = format.match(dateCheck);
        if (matches) {
            digits = parseInt(matches[0], 10);
        }

        var zeroPad = function (str, count, left) {
            for (var l = str.length; l < count; l++)
                str = left ? ('0' + str) : (str + '0');

            return str;
        };

        var addGroupSeparator = function (number, groupSeperator, groupSize) {
            if (groupSeparator && groupSize != 0) {
                var regExp = new RegExp('(-?[0-9]+)([0-9]{' + groupSize + '})');
                while (regExp.test(number)) {
                    number = number.replace(regExp, '$1' + groupSeperator + '$2');
                }
            }
            return number;
        };

        var cultureInfo = cultureInfo || $t.cultureInfo,
            patterns = $t.patterns,
            undefined;

        //define Number Formating info.
        digits = digits || digits === 0 ? digits : cultureInfo[type + 'decimaldigits'];
        separator = separator !== undefined ? separator : cultureInfo[type + 'decimalseparator'];
        groupSeparator = groupSeparator !== undefined ? groupSeparator : cultureInfo[type + 'groupseparator'];
        groupSize = groupSize || groupSize == 0 ? groupSize : cultureInfo[type + 'groupsize'];
        negative = negative || negative === 0 ? negative : cultureInfo[type + 'negative'];
        positive = positive || positive === 0 ? positive : cultureInfo[type + 'positive'];
        symbol = symbol || cultureInfo[type + 'symbol'];

        var exponent, left, right;

        if (isCustomFormat) {
            var splits = (sign && negativeFormat ? negativeFormat : customFormat).split('.'),
                leftF = splits[0],
                rightF = splits.length > 1 ? splits[1] : '',
                lastIndexZero = $t.lastIndexOf(rightF, '0'),
                lastIndexSharp = $t.lastIndexOf(rightF, '#');
            digits = (lastIndexSharp > lastIndexZero ? lastIndexSharp : lastIndexZero) + 1;
        }

        var rounded = round(number, digits);
        number = isFinite(rounded) ? rounded : number;

        if (number.toString().toLowerCase().indexOf("e") > -1) {
            number = number.toFixed(digits);
        }

        var split = number.toString().split('.');

        left = split[0];
        left = sign ? left.replace('-', '') : left;

        right = split.length > 1 ? split[1] : '';

        if (exponent) {
            if (!sign) {
                right = zeroPad(right, exponent, false);
                left += right.slice(0, exponent);
                right = right.substr(exponent);
            } else {
                left = zeroPad(left, exponent + 1, true);
                right = left.slice(exponent, left.length) + right;
                left = left.slice(0, exponent);
            }
        }

        var rightLength = right.length;
        if (digits < 1 || (isCustomFormat && lastIndexZero == -1 && rightLength === 0))
            right = '';
        else
            right = rightLength > digits ? right.slice(0, digits) : zeroPad(right, digits, false);

        var result;
        if (isCustomFormat) {
            if (left == 0) left = '';

            left = injectInFormat(reverse(left), reverse(leftF), true).replace(/,/g, "");
            left = leftF.indexOf(',') != -1 ? addGroupSeparator(left, groupSeparator, groupSize) : left;

            right = right && rightF ? injectInFormat(right, rightF) : '';

            result = number === 0 && zeroFormat ? zeroFormat
                : (sign && !negativeFormat ? '-' : '') + left + (right.length > 0 ? separator + right : '');

        } else {

            left = addGroupSeparator(left, groupSeparator, groupSize)
            patterns = patterns[type];
            var pattern = sign ? patterns['negative'][negative]
                        : symbol ? patterns['positive'][positive]
                        : null;

            var numberString = left + (right.length > 0 ? separator + right : '');

            result = pattern ? pattern.replace('n', numberString).replace('*', symbol) : numberString;
        }
        return result;
    };
    /*============================*/

    $.extend($t.formatters, {
        date: $t.datetime.format,
        number: $t.formatNumber
    });

    $t.scripts = [];

    var jobs = [];

    function resolve(dependencies, callback) {
        var scripts = $t.scripts;

        dependencies = $.grep(dependencies, function (dependency) {
            dependency = dependency.toLowerCase().replace(".min", "");
            if (dependency.indexOf("jquery-") > -1 || (dependency.indexOf("jquery.validate") > -1 && $.fn.validate) || dependency.indexOf("telerik.common") > -1) {
                return false;
            }

            var loaded = false;

            for (var i = 0; i < scripts.length; i++) {
                var script = scripts[i];
                if (dependency.indexOf(script) > -1) {
                    loaded = true;
                    break;
                }
            }
            return !loaded;
        });

        var load = function (dependency) {
            if (dependency) {
                $.ajax({
                    url: dependency,
                    dataType: "script",
                    cache: !$.browser.msie, // otherwise IE6/7 do not execute the scripts after refresh
                    success: function () {
                        load(dependencies.shift());
                    }
                });
            } else {
                callback();
                jobs.shift();
                if (jobs.length) {
                    jobs[0]();
                }
            }
        };
        load(dependencies.shift());
    }

    $t.load = function (dependencies, callback) {
        jobs.push(function () {
            resolve(dependencies, callback);
        });

        if (jobs.length == 1) {
            resolve(dependencies, callback);
        }
    };

    $t.stringBuilder.prototype = {

        cat: function (what) {
            this.buffer.push(what);
            return this;
        },

        rep: function (what, howManyTimes) {
            for (var i = 0; i < howManyTimes; i++)
                this.cat(what);
            return this;
        },

        catIf: function () {
            var args = arguments;
            if (args[args.length - 1])
                for (var i = 0, length = args.length - 1; i < length; i++)
                    this.cat(args[i]);

            return this;
        },

        string: function () {
            return this.buffer.join('');
        }
    };

    $t.isTouch = "ontouchstart" in window;

    var moveEvent = "mousemove",
        startEvent = "mousedown",
        endEvent = "mouseup";

    if ($t.isTouch) {
        moveEvent = "touchmove";
        startEvent = "touchstart";
        endEvent = "touchend";
    }

    $.extend($.fn, {
        tScrollable: function (options) {
            $(this).each(function () {
                if ($t.isTouch || (options && options.force)) {
                    new Scroller(this);
                }
            });
        }
    });

    function Scroller(element) {
        this.element = element;
        this.wrapper = $(element);

        this._horizontalScrollbar = $('<div class="t-touch-scrollbar" />');
        this._verticalScrollbar = this._horizontalScrollbar.clone();
        this._scrollbars = this._horizontalScrollbar.add(this._verticalScrollbar);

        this._startProxy = $.proxy(this._start, this);
        this._stopProxy = $.proxy(this._stop, this);
        this._dragProxy = $.proxy(this._drag, this);

        this._create();
    }

    $t.touchLocation = function (e) {
        return {
            idx: 0,
            x: e.pageX,
            y: e.pageY
        };
    };

    $t.eventTarget = function (e) {
        return e.target;
    };

    $t.eventCurrentTarget = function (e) {
        return e.currentTarget;
    };

    if ($t.isTouch) {
        $t.touchLocation = function (e, id) {
            var changedTouches = e.changedTouches || e.originalEvent.changedTouches;

            if (id) {
                var output = null;
                each(changedTouches, function (idx, value) {
                    if (id == value.identifier) {
                        output = {
                            idx: value.identifier,
                            x: value.pageX,
                            y: value.pageY
                        };
                    }
                });
                return output;
            } else {
                if (e.type in { touchstart: {}, touchmove: {}, touchend: {}, touchcancel: {} }) {
                    return {
                        idx: changedTouches[0].identifier,
                        x: changedTouches[0].pageX,
                        y: changedTouches[0].pageY
                    };
                } else {
                    return {
                        idx: 0,
                        x: e.pageX,
                        y: e.pageY
                    };
                }
            }
        };

        $t.eventTarget = function (e) {
            var touches = "originalEvent" in e ? e.originalEvent.changedTouches : "changedTouches" in e ? e.changedTouches : null;

            return touches ? document.elementFromPoint(touches[0].clientX, touches[0].clientY) : null;
        };

        $t.eventCurrentTarget = $t.eventTarget;
    }

    $t.zoomLevel = function () {
        return $t.isTouch ? (document.documentElement.clientWidth / window.innerWidth) : 1;
    };

    Scroller.prototype = {
        _create: function () {
            this.wrapper
                .css("overflow", "hidden")
                .bind(startEvent, $.proxy(this._wait, this));

        },
        _wait: function (e) {
            var startLocation = $t.touchLocation(e);

            this.start = {
                x: startLocation.x + this.wrapper.scrollLeft(),
                y: startLocation.y + this.wrapper.scrollTop()
            };

            $(document)
                .bind(moveEvent, this._startProxy)
                .bind(endEvent, this._stopProxy);
        },
        _start: function (e) {
            var currentLocation = $t.touchLocation(e);
            this._dragged = false;

            if (this.start.x - currentLocation.x > 10 || this.start.y - currentLocation.y > 10) {
                e.preventDefault();

                this._dragged = true;

                $(document).unbind(moveEvent, this._startProxy)
                           .bind(moveEvent, this._dragProxy);

                var width = this.wrapper.innerWidth(),
                    height = this.wrapper.innerHeight(),
                    offset = this.wrapper.offset(),
                    scrollWidth = this.wrapper.attr("scrollWidth"),
                    scrollHeight = this.wrapper.attr("scrollHeight");

                if (scrollWidth > width) {
                    this._horizontalScrollbar
                        .appendTo(document.body)
                        .css({
                            width: Math.floor((width / scrollWidth) * width),
                            left: this.wrapper.scrollLeft() + offset.left + parseInt(this.wrapper.css("borderLeftWidth")),
                            top: offset.top + this.wrapper.innerHeight() + parseInt(this.wrapper.css("borderTopWidth")) - this._horizontalScrollbar.outerHeight()
                        });
                }

                if (scrollHeight > height) {
                    this._verticalScrollbar
                        .appendTo(document.body)
                        .css({
                            height: Math.floor((height / scrollHeight) * height),
                            top: this.wrapper.scrollTop() + offset.top + parseInt(this.wrapper.css("borderTopWidth")),
                            left: offset.left + this.wrapper.innerWidth() + parseInt(this.wrapper.css("borderLeftWidth")) - this._verticalScrollbar.outerWidth()
                        });
                }

                this._scrollbars
                    .stop()
                    .fadeTo(200, 0.5);
            }
        },

        _drag: function (e) {
            if (!this._dragged)
                e.preventDefault();

            var currentLocation = $t.touchLocation(e),
                offset = this.wrapper.offset(),
                startLeft = offset.left + parseInt(this.wrapper.css("borderLeftWidth")),
                startTop = offset.top + parseInt(this.wrapper.css("borderTopWidth")),
                horizontalDifference = this.start.x - currentLocation.x,
                verticalDifference = this.start.y - currentLocation.y,
                left = Math.max(startLeft, startLeft + horizontalDifference),
                top = Math.max(startTop, startTop + verticalDifference);

            left = Math.min(startLeft + this.wrapper.innerWidth() - this._horizontalScrollbar.outerWidth() - this._horizontalScrollbar.outerHeight(), left);
            top = Math.min(startTop + this.wrapper.innerHeight() - this._verticalScrollbar.outerHeight() - this._verticalScrollbar.outerWidth(), top);

            this._horizontalScrollbar.css("left", left);
            this._verticalScrollbar.css("top", top);

            this.wrapper
                .scrollLeft(horizontalDifference)
                .scrollTop(verticalDifference);
        },
        _stop: function () {
            $(document).unbind(moveEvent, this._startProxy)
                       .unbind(moveEvent, this._dragProxy)
                       .unbind(endEvent, this._stopProxy);

            this._scrollbars
                .stop()
                .fadeTo(400, 0);
        }
    };

    // Effects ($t.fx)

    var prepareAnimations = function (effects, target, end) {
        if (target.length == 0 && end) {
            end();
            return null;
        }

        var animationsToPlay = effects.list.length;

        return function () {
            if (--animationsToPlay == 0 && end)
                end();
        };
    };

    $.extend($t.fx, {
        _wrap: function (element) {
            if (!element.parent().hasClass('t-animation-container')) {
                element.wrap(
                             $('<div/>')
                             .addClass('t-animation-container')
                             .css({
                                 width: element.outerWidth(),
                                 height: element.outerHeight()
                             }));
            }

            return element.parent();
        },

        play: function (effects, target, options, end) {
            var afterAnimation = prepareAnimations(effects, target, end);

            if (afterAnimation === null) return;

            target.stop(false, true);

            for (var i = 0, len = effects.list.length; i < len; i++) {

                var effect = new $t.fx[effects.list[i].name](target);

                if (!target.data('effect-' + i)) {
                    effect.play(
                    $.extend(
                        effects.list[i], {
                            openDuration: effects.openDuration,
                            closeDuration: effects.closeDuration
                        },
                        options), afterAnimation);

                    target.data('effect-' + i, effect);
                }
            }
        },

        rewind: function (effects, target, options, end) {
            var afterAnimation = prepareAnimations(effects, target, end);

            if (afterAnimation === null) return;

            for (var i = effects.list.length - 1; i >= 0; i--) {
                var effect = target.data('effect-' + i) || new $t.fx[effects.list[i].name](target);

                effect.rewind(
                    $.extend(
                        effects.list[i], {
                            openDuration: effects.openDuration,
                            closeDuration: effects.closeDuration
                        },
                        options), afterAnimation);

                target.data('effect-' + i, null);
            }
        }
    });

    // simple show/hide toggle

    $t.fx.toggle = function (element) {
        this.element = element.stop(false, true);
    };

    $t.fx.toggle.prototype = {
        play: function (options, end) {
            this.element.show();
            if (end) end();
        },
        rewind: function (options, end) {
            this.element.hide();
            if (end) end();
        }
    };

    $t.fx.toggle.defaults = function () {
        return { list: [{ name: 'toggle'}] };
    };

    // slide animation

    $t.fx.slide = function (element) {
        this.element = element;

        this.animationContainer = $t.fx._wrap(element);
    };

    $t.fx.slide.prototype = {
        play: function (options, end) {

            var animationContainer = this.animationContainer;

            this.element.css('display', 'block').stop();

            animationContainer
                .css({
                    display: 'block',
                    overflow: 'hidden'
                });

            var width = this.element.outerWidth();
            var height = this.element.outerHeight();
            var animatedProperty = options.direction == 'bottom' ? 'marginTop' : 'marginLeft';
            var animatedStartValue = options.direction == 'bottom' ? -height : -width;

            animationContainer
                .css({
                    width: width,
                    height: height
                });

            var animationEnd = {};
            animationEnd[animatedProperty] = 0;

            this.element
                .css('width', this.element.width())
                .each(function () { this.style.cssText = this.style.cssText; })
                .css(animatedProperty, animatedStartValue)
                .animate(animationEnd, {
                    queue: false,
                    duration: options.openDuration,
                    easing: 'linear',
                    complete: function () {
                        animationContainer.css('overflow', '');

                        if (end) end();
                    }
                });
        },

        rewind: function (options, end) {
            var animationContainer = this.animationContainer;

            this.element.stop(false, true);

            animationContainer.css({
                overflow: 'hidden'
            });

            var animatedProperty;

            switch (options.direction) {
                case 'bottom': animatedProperty = { marginTop: -this.element.outerHeight() };
                    break;
                case 'right': animatedProperty = { marginLeft: -this.element.outerWidth() }; break;
            }

            this.element
                .animate(animatedProperty, {
                    queue: false,
                    duration: options.closeDuration,
                    easing: 'linear',
                    complete: function () {
                        animationContainer
                            .css({
                                display: 'none',
                                overflow: ''
                            });

                        if (end) end();
                    }
                });
        }
    };

    $t.fx.slide.defaults = function () {
        return { list: [{ name: 'slide'}], openDuration: 'fast', closeDuration: 'fast' };
    };

    // property animation

    $t.fx.property = function (element) {
        this.element = element;
    };

    $t.fx.property.prototype = {
        _animate: function (properties, duration, reverse, end) {
            var startValues = { overflow: 'hidden' },
                endValues = {},
                $element = this.element;

            $.each(properties, function (i, prop) {
                var value;

                switch (prop) {
                    case 'height':
                    case 'width': value = $element[prop](); break;

                    case 'opacity': value = 1; break;

                    default: value = $element.css(prop); break;
                }

                startValues[prop] = reverse ? value : 0;
                endValues[prop] = reverse ? 0 : value;
            });

            $element.css(startValues)
                    .show()
                    .animate(endValues, {
                        queue: false,
                        duration: duration,
                        easing: 'linear',
                        complete: function () {
                            if (reverse)
                                $element.hide();

                            $.each(endValues, function (property) {
                                endValues[property] = '';
                            });

                            $element.css($.extend({ overflow: '' }, endValues));

                            if (end) end();
                        }
                    });
        },

        play: function (options, complete) {
            this._animate(options.properties, options.openDuration, false, complete);
        },

        rewind: function (options, complete) {
            this._animate(options.properties, options.closeDuration, true, complete);
        }
    }

    $t.fx.property.defaults = function () {
        return { list: [{ name: 'property', properties: arguments}], openDuration: 'fast', closeDuration: 'fast' };
    };

    // fix the MVC validation code for IE (document.getElementsByName matches `id` and `name` instead of just `name`). http://www.w3.org/TR/REC-DOM-Level-1/level-one-html.html#ID-71555259
    $(document).ready(function () {
        if ($.browser.msie && typeof (Sys) != 'undefined' && typeof (Sys.Mvc) != 'undefined' && typeof (Sys.Mvc.FormContext) != 'undefined') {
            var patch = function (formElement, name) {
                return $.grep(formElement.getElementsByTagName('*'), function (element) {
                    return element.name == name;
                });
            };

            if (Sys.Mvc.FormContext)
                Sys.Mvc.FormContext.$F = Sys.Mvc.FormContext._getFormElementsWithName = patch;
        }

    });

    /*core.js*/
    //==============================================================
    //==============================================================
    //==============================================================
    //==============================================================
    //==============================================================
    //==============================================================
    //==============================================================
    //==============================================================    
    var extend = $.extend,
        proxy = $.proxy,
        type = $.type,
        isFunction = $.isFunction,
        isPlainObject = $.isPlainObject,
        isEmptyObject = $.isEmptyObject,
        each = $.each,
        noop = $.noop;

    //Event ================================
    function Event() {
        this._isPrevented = false;
    }

    Event.prototype = {
        preventDefault: function () {
            this._isPrevented = true;
        },
        isDefaultPrevented: function () {
            return this._isPrevented;
        }
    };

    //Class =====================================
    function Class() {
    }

    Class.extend = function (proto) {
        var base = function () { },
            that = this,
            subclass = proto && proto.init ? proto.init : function () {
                that.apply(this, arguments);
            },
            subProto;

        base.prototype = that.prototype;
        subProto = subclass.fn = subclass.prototype = extend(new base, proto);

        for (var member in subProto) {
            if (typeof subProto[member] === "object") {
                subProto[member] = extend(true, {}, base.prototype[member], proto[member]);
            }
        }

        subProto.constructor = subclass;
        subclass.extend = that.extend;

        return subclass;
    };

    $.telerik.Class = Class;

    //Observable ================================
    var Observable = Class.extend({

        init: function () {
            this._events = {};
        },

        bind: function (eventName, handlers) {
            var that = this,
                idx,
                eventNames = $.isArray(eventName) ? eventName : [eventName],
                length,
                events;

            for (idx = 0, length = eventNames.length; idx < length; idx++) {
                eventName = eventNames[idx];

                handler = $.isFunction(handlers) ? handlers : handlers[eventName];

                if (handler) {
                    events = that._events[eventName] || []
                    events.push(handler);
                    that._events[eventName] = events;
                }
            }

            return that;
        },

        trigger: function (eventName, parameter) {
            var that = this,
                events = that._events[eventName],
                args = extend(parameter, new Event()),
                idx,
                length;

            if (events) {
                for (idx = 0, length = events.length; idx < length; idx++) {
                    events[idx].call(that, args);
                }
            }

            return args.isDefaultPrevented();
        },

        unbind: function (eventName, handler) {
            var that = this,
                events = that._events[eventName],
                idx,
                length;

            if (events) {
                if (handler) {
                    for (idx = 0, length = events.length; idx < length; idx++) {
                        if (events[idx] === handler) {
                            events.splice(idx, 1);
                        }
                    }
                } else {
                    that._events[eventName] = [];
                }
            }

            return that;
        }
    });

    //Query =========================================
    var Comparer = {
        selector: function (field) {
            if ($.isFunction(field)) {
                return  field 
            } else {
                var accessor = getter(field);
                return function (record) {
                        var value = accessor(record);
                        if (typeof value === "string") {
                            var date = /^\/Date\((.*?)\)\/$/.exec(value);
                            if (date) {
                                value = new Date(parseInt(date[1]));
                                return value;
                            }
                        }
                        return value;
                    }
            }
        },
        asc: function (field) {
            var selector = this.selector(field);
            return function (a, b) {
                a = selector(a);
                b = selector(b);

                return a > b ? 1 : (a < b ? -1 : 0);
            };
        },
        desc: function (field) {
            var selector = this.selector(field);
            return function (a, b) {
                a = selector(a);
                b = selector(b);

                return a < b ? 1 : (a > b ? -1 : 0);
            };
        },
        create: function (descriptor) {
            return Comparer[descriptor.dir.toLowerCase()](descriptor.field);
        },
        combine: function (comparers) {
            return function (a, b) {
                var result = comparers[0](a, b),
                     idx,
                     length;

                for (idx = 1, length = comparers.length; idx < length; idx++) {
                    result = result || comparers[idx](a, b);
                }

                return result;
            }
        }
    };

    var Filter = {
        create: function (expressions) {
            var idx,
                length,
                expr,
                selector,
                operator,
                desc,
                descriptors = [],
                caseSensitive,
                predicate;

            expressions = expressions || [];
            for (idx = 0, length = expressions.length; idx < length; idx++) {
                expr = expressions[idx];
                if (typeof expr.value === "string" && !expr.caseSensitive) {
                    caseSensitive = function (value) {
                        return typeof value === "string" ? value.toLowerCase() : value;
                    };
                } else {
                    caseSensitive = function (value) {
                        return value;
                    };
                }
                selector = Filter.selector(expr.field, caseSensitive);
                operator = Filter.operator(expr.operator);
                desc = operator(selector, caseSensitive(expr.value));
                descriptors.push(desc);
            }
            predicate = Filter.combine(descriptors);

            return function (data) {
                return Filter.execute(predicate, data);
            };
        },
        selector: function (field, caseSensitive) {
            if (field) {
                if (isFunction(field)) {
                    return field;
                } else {
                    var accessor = getter(field);
                    return function (record) {
                        var value = accessor(record);
                        if (typeof value === "string") {
                            var date = /^\/Date\((.*?)\)\/$/.exec(value);
                            if (date) {
                                value = new Date(parseInt(date[1]));
                                return value;
                            }
                        }
                        return caseSensitive(value);
                    };
                }
            }
            return function (record) {
                return caseSensitive(record);
            };
        },
        execute: function (predicate, data) {
            var idx,
                length = data.length,
                record,
                result = [];

            for (idx = 0; idx < length; idx++) {
                record = data[idx];

                if (predicate(record)) {
                    result.push(record);
                }
            }

            return result;
        },
        combine: function (descriptors) {
            return function (record) {
                var result = true,
                idx = 0,
                length = descriptors.length;

                while (result && idx < length) {
                    result = descriptors[idx++](record);
                }

                return result;
            };
        },
        operator: function (operator) {
            if (!operator)
                return Filter.eq;
            if ($.isFunction(operator))
                return operator;

            operator = operator.toLowerCase();
            operatorStrings = Filter.operatorStrings;
            for (var op in operatorStrings) {
                if ($.inArray(operator, operatorStrings[op]) > -1) {
                    operator = op;
                    break;
                }
            }

            return Filter[operator];
        },
        operatorStrings: {
            "eq": ["eq", "==", "isequalto", "equals", "equalto", "equal"],
            "neq": ["neq", "!=", "isnotequalto", "notequals", "notequalto", "notequal", "not", "ne"],
            "lt": ["lt", "<", "islessthan", "lessthan", "less"],
            "lte": ["lte", "<=", "islessthanorequalto", "lessthanequal", "le"],
            "gt": ["gt", ">", "isgreaterthan", "greaterthan", "greater"],
            "gte": ["gte", ">=", "isgreaterthanorequalto", "greaterthanequal", "ge"],
            "startswith": ["startswith"],
            "endswith": ["endswith"],
            "contains": ["contains", "substringof"]
        },
        eq: function (selector, value) {
            return function (record) {
                var item = selector(record);
                return item > value ? false : (value > item ? false : true);
            };
        },
        neq: function (selector, value) {
            return function (record) {
                return selector(record) != value;
            };
        },
        lt: function (selector, value) {
            return function (record) {
                return selector(record) < value;
            };
        },
        lte: function (selector, value) {
            return function (record) {
                return selector(record) <= value;
            };
        },
        gt: function (selector, value) {
            return function (record) {
                return selector(record) > value;
            };
        },
        gte: function (selector, value) {
            return function (record) {
                return selector(record) >= value;
            };
        },
        startswith: function (selector, value) {
            return function (record) {
                return selector(record).indexOf(value) == 0;
            };
        },
        endswith: function (selector, value) {
            return function (record) {
                var item = selector(record);
                return item.lastIndexOf(value) == item.length - (value || "").length;
            };
        },
        contains: function (selector, value) {
            return function (record) {
                return selector(record).indexOf(value) > -1;
            };
        }
    }

    var Query = function (data) {
        return new Query.fn.init(data);
    };

    $t.query = Query;

    Query.expandSort = function (field, dir) {
        var descriptor = typeof field === "string" ? { field: field, dir: dir} : field,
            descriptors = $.isArray(descriptor) ? descriptor : (descriptor !== undefined ? [descriptor] : []);

        return $.grep(descriptors, function (d) { return !!d.dir; });
    }
    Query.expandFilter = function (expressions) {
        return expressions = $.isArray(expressions) ? expressions : [expressions];
    }
    Query.expandAggregates = function (expressions) {
        return expressions = $.isArray(expressions) ? expressions : [expressions];
    }
    Query.expandGroup = function (field, dir) {
        var descriptor = typeof field === "string" ? { field: field, dir: dir} : field,
           descriptors = $.isArray(descriptor) ? descriptor : (descriptor !== undefined ? [descriptor] : []);

        return $.map(descriptors, function (d) { return { field: d.field, dir: d.dir || "asc", aggregates: d.aggregates }; });
    }

    Query.fn = Query.prototype = {
        init: function (data) {
            this.data = data || [];
            return this;
        },
        toArray: function () {
            return this.data;
        },
        skip: function (count) {
            return new Query(this.data.slice(count));
        },
        take: function (count) {
            return new Query(this.data.slice(0, count));
        },
        orderBy: function (selector) {
            var result = this.data.slice(0),
                comparer = $.isFunction(selector) || !selector ? Comparer.asc(selector) : selector.compare;

            return new Query(result.sort(comparer));
        },
        orderByDescending: function (selector) {
            return new Query(this.data.slice(0).sort(Comparer.desc(selector)));
        },
        sort: function (field, dir) {
            var idx,
                length,
                descriptors = Query.expandSort(field, dir),
                comparers = [];

            if (descriptors.length) {
                for (idx = 0, length = descriptors.length; idx < length; idx++) {
                    comparers.push(Comparer.create(descriptors[idx]));
                }

                return this.orderBy({ compare: Comparer.combine(comparers) });
            }

            return this;
        },
        filter: function (expressions) {
            var predicate = Filter.create(Query.expandFilter(expressions));
            return new Query(predicate(this.data));
        },
        where: function (predicate) {
            return Query(filter(this.data, predicate));
        },
        select: function (selector) {
            return Query(map(this.data, selector));
        },
        concat: function (value) {
            return Query(this.data.concat(value.data));
        },
        count: function () {
            return this.data.length;
        },
        any: function (predicate) {
            if ($.isFunction(predicate)) {
                for (var index = 0, length = this.data.length; index < length; index++) {
                    if (predicate(this.data[index], index)) {
                        return true;
                    }
                }

                return false;
            }
            return !!this.data.length;
        },
        group: function (descriptors, allData) {
            descriptors = Query.expandGroup(descriptors || []);
            allData = allData || this.data;

            var that = this,
                result = new Query(that.data),
                descriptor;

            if (descriptors.length > 0) {
                descriptor = descriptors[0];
                result = result.groupBy(descriptor).select(function (group) {
                    var data = new Query(allData).filter([{ field: group.field, operator: "eq", value: group.value}]);
                    return {
                        field: group.field,
                        value: group.value,
                        items: descriptors.length > 1 ? new Query(group.items).group(descriptors.slice(1), data.toArray()).toArray() : group.items,
                        hasSubgroups: descriptors.length > 1,
                        aggregates: data.aggregate(descriptor.aggregates)
                    }
                });
            }
            return result;
        },
        groupBy: function (descriptor) {
            if (isEmptyObject(descriptor) || !this.data.length) {
                return new Query([]);
            }

            var field = descriptor.field,
                sorted = this.sort(field, descriptor.dir || "asc").toArray(),
                accr = accessor(field),
                item,
                groupValue = accr.get(sorted[0], field),
                aggregate = {},
                group = {
                    field: field,
                    value: groupValue,
                    items: []
                },
                currentValue,
                idx,
                len,
                result = [group];

            for (idx = 0, len = sorted.length; idx < len; idx++) {
                item = sorted[idx];
                currentValue = accr.get(item, field);
                if (groupValue !== currentValue) {
                    groupValue = currentValue;
                    aggregate = {};
                    group = {
                        field: field,
                        value: groupValue,
                        items: []
                    };
                    result.push(group);
                }
                group.items.push(item);
            }
            return new Query(result);
        },
        aggregate: function (aggregates) {
            var idx,
                len,
                result = {};

            for (idx = 0, len = this.data.length; idx < len; idx++) {
                calculateAggregate(result, aggregates, this.data[idx], idx, len);
            }
            return result;
        }
    }

    function calculateAggregate(accumulator, aggregates, item, index, length) {
        aggregates = aggregates || [];
        var idx,
            aggr,
            functionName,
            fieldAccumulator,
            len = aggregates.length;

        for (idx = 0; idx < len; idx++) {
            aggr = aggregates[idx];
            functionName = aggr.aggregate;
            var field = aggr.field;
            accumulator[field] = accumulator[field] || {};
            accumulator[field][functionName] = functions[functionName.toLowerCase()](accumulator[field][functionName], item, accessor(field), index, length);
        }
    }

    var functions = {
        sum: function (accumulator, item, accessor) {
            return accumulator = (accumulator || 0) + accessor.get(item);
        },
        count: function (accumulator, item, accessor) {
            return (accumulator || 0) + 1;
        },
        average: function (accumulator, item, accessor, index, length) {
            accumulator = (accumulator || 0) + accessor.get(item);
            if (index == length - 1) {
                accumulator = accumulator / length;
            }
            return accumulator;
        },
        max: function (accumulator, item, accessor) {
            var accumulator = (accumulator || 0),
                value = accessor.get(item);
            if (accumulator < value) {
                accumulator = value;
            }
            return accumulator;
        },
        min: function (accumulator, item, accessor) {
            var value = accessor.get(item),
                accumulator = (accumulator || value)
            if (accumulator > value) {
                accumulator = value;
            }
            return accumulator;
        }
    };
    Query.fn.init.prototype = Query.fn;
    //End Query =========================================

    //Model =============================================
    var type = $.type,
        UPDATED = "UPDATED",
        PRISTINE = "PRISTINE",
        CREATED = "CREATED",
        DESTROYED = "DESTROYED";

    function equal(x, y) {
        if (x === y) {
            return true;
        }

        var xtype = type(x), ytype = type(y), field;

        if (xtype !== ytype) {
            return false;
        }

        if (xtype === "date") {
            return x.getTime() === y.getTime();
        }

        if (xtype !== "object" && xtype !== "array") {
            return false;
        }

        for (field in x) {
            if (!equal(x[field], y[field])) {
                return false;
            }
        }

        return true;
    }
    var getter = function (expression, safe) {
        expression = expression || "";

        if (expression && expression.charAt(0) !== "[") {
            expression = "." + expression;
        }

        if (safe) {
            return new Function("d", "return " + wrapExpression(expression.split(".")));
        }

        return new Function("d", "return d" + expression);
    },
        setter = function (expression) {
            return new Function("d,value", "d." + expression + "=value");
        },
        accessor = function (expression) {
            return {
                get: getter(expression),
                set: setter(expression)
            }
        };

    var wrapExpression = function (members) {
        var result = "d",
            index,
            idx,
            length,
            member,
            count = 1;

        for (idx = 0, length = members.length; idx < length; idx++) {
            member = members[idx];
            if (member !== "") {
                index = member.indexOf("[");

                if (index != 0) {
                    if (index == -1) {
                        member = "." + member;
                    } else {
                        count++;
                        member = "." + member.substring(0, index) + " || {})" + member.substring(index);
                    }
                }

                count++;
                result += member + ((idx < length - 1) ? " || {})" : ")");
            }
        }
        return new Array(count).join("(") + result;
    }

    var Model = Observable.extend({
        init: function (data) {
            var that = this;

            Observable.fn.init.call(that);

            that.state = PRISTINE;

            that._accessors = {};

            that._modified = false;

            that.data = extend(true, {}, data);
            that.pristine = extend(true, {}, data);

            if (that.id() === undefined) {
                that.state = CREATED;
                that.data["__id"] = that.guid();
            }
        },

        guid: function () {
            var id = "", i, random;

            for (i = 0; i < 32; i++) {
                random = Math.random() * 16 | 0;

                if (i == 8 || i == 12 || i == 16 || i == 20) {
                    id += "-";
                }
                id += (i == 12 ? 4 : (i == 16 ? (random & 3 | 8) : random)).toString(16);
            }

            return id;
        },

        accessor: function (field) {
            var accessors = this._accessors;

            return accessors[field] = accessors[field] || accessor(field);
        },

        get: function (field) {
            var that = this,
                accessor = that.accessor(field);

            return accessor.get(that.data);
        },

        set: function (fields, value) {
            var that = this,
                field,
                values = {},
                accessor;

            if (typeof fields === "string") {
                values[fields] = value;
            } else {
                values = fields;
            }

            that._modified = false;

            for (field in values) {
                accessor = that.accessor(field);

                value = values[field];

                if (!equal(value, accessor.get(that.data))) {
                    accessor.set(that.data, value);
                    that._modified = true;
                }
            }

            if (that._modified) {
                that.state = that.isNew() ? CREATED : UPDATED;
                that.trigger("change");
            }
        },

        isNew: function () {
            return this.state === CREATED;
        },

        destroy: function () {
            this.state = DESTROYED;
        },

        changes: function () {
            var modified = null,
                field,
                that = this,
                data = that.data,
                pristine = that.pristine;

            for (field in data) {
                if (field !== "__id" && !equal(pristine[field], data[field])) {
                    modified = modified || {};
                    modified[field] = data[field];
                }
            }

            return modified;
        }
    });

    Model.define = function (options) {
        var model,
            proto = options || {},
            id = proto.id || "id",
            set,
            get;

        if ($.isFunction(id)) {
            get = id;
            set = id;
        } else {
            get = getter(id);
            set = setter(id);
        }

        id = function (data, value) {
            if (value === undefined) {
                return data["__id"] || get(data);
            } else {
                set(data, value);
            }
        }

        proto.id = function (value) {
            return id(this.data, value);
        }

        model = Model.extend(proto);
        model.id = id;

        return model;
    }

    Model.UPDATED = UPDATED;
    Model.PRISTINE = PRISTINE;
    Model.CREATED = CREATED;
    Model.DESTROYED = DESTROYED;

    //DataSource ========================================
    var CREATE = "create",
        READ = "read",
        UPDATE = "update",
        DESTROY = "destroy",
        CHANGE = "change",
        ERROR = "error",
        crud = [CREATE, READ, UPDATE, DESTROY],
        identity = function (o) { return o; };


    function process(data, options) {
        var query = new Query(data),
            options = options || {},
            page = options.page,
            pageSize = options.pageSize,
            group = options.group,
            sort = Query.expandSort(options.sort).concat(Query.expandGroup(group || [])),
            total,
            filter = options.filter;

        if (filter) {
            query = query.filter(filter);
            total = query.toArray().length;
        }

        if (sort) {
            query = query.sort(sort);
        }

        if (page !== undefined && pageSize !== undefined) {
            query = query.skip((page - 1) * pageSize).take(pageSize);
        }

        if (group) {
            query = query.group(group, data);
        }

        return {
            total: total,
            data: query.toArray()
        };
    }

    function calculateAggregates(data, options) {
        var query = new Query(data),
            options = options || {},
            aggregates = options.aggregates,
            filter = options.filter;

        if (filter) {
            query = query.filter(filter);
        }
        return query.aggregate(aggregates);
    }

    var LocalTransport = Class.extend({
        init: function (options) {
            this.data = options.data;
        },

        read: function (options) {
            options.success(this.data);
        },
        update: noop
    });

    var RemoteTransport = Class.extend({
        init: function (options) {
            var that = this;

            options = that.options = extend({}, that.options, options);

            each(crud, function (index, type) {
                if (typeof options[type] === "string") {
                    options[type] = {
                        url: options[type]
                    };
                }
            });

            that.cache = options.cache ? Cache.create(options.cache) : {
                find: noop,
                add: noop
            }

            that.dialect = options.dialect;
        },

        options: {
            dialect: {
                read: identity,
                update: identity,
                destroy: identity,
                create: identity
            }
        },

        create: function (options) {
            $.ajax(this.setup(options, CREATE));
        },

        read: function (options) {
            var that = this,
                success,
                error,
                result,
                cache = that.cache;

            options = that.setup(options, READ);

            success = options.success || noop;
            error = options.error || noop;

            result = cache.find(options.data);

            if (result !== undefined) {
                success(result);
            } else {
                options.success = function (result) {
                    cache.add(options.data, result);

                    success(result);
                };
                $.ajax(options);
            }
        },

        update: function (options) {
            $.ajax(this.setup(options, UPDATE));
        },

        destroy: function (options) {
            $.ajax(this.setup(options, DESTROY));
        },

        setup: function (options, type) {
            options = options || {};

            var that = this,
                operation = that.options[type],
                data = isFunction(operation.data) ? operation.data() : operation.data;

            options = extend(true, {}, operation, options);
            options.data = that.dialect[type](extend(data, options.data));

            return options;
        }
    });

    Cache.create = function (options) {
        var store = {
            "inmemory": function () { return new Cache(); },
            "localstorage": function () { return new LocalStorageCache(); }
        };

        if (isPlainObject(options) && isFunction(options.find)) {
            return options;
        }

        if (options === true) {
            return new Cache();
        }

        return store[options]();
    }

    function Cache() {
        this._store = {};
    }

    Cache.prototype = {
        add: function (key, data) {
            if (key !== undefined) {
                this._store[stringify(key)] = data;
            }
        },
        find: function (key) {
            return this._store[stringify(key)];
        },
        clear: function () {
            this._store = {};
        },
        remove: function (key) {
            delete this._store[stringify(key)];
        }
    }

    function LocalStorageCache() {
        this._store = window.localStorage;
    }

    LocalStorageCache.prototype = {
        add: function (key, data) {
            if (key != undefined) {
                this._store.setItem(stringify(key), stringify(data));
            }
        },
        find: function (key) {
            return $.parseJSON(this._store.getItem(stringify(key)));
        },
        clear: function () {
            this._store.clear();
        },
        remove: function (key) {
            this._store.removeItem(stringify(key));
        }
    }

    var DataSource = Observable.extend({
        init: function (options) {
            var that = this, id, model, transport;

            options = that.options = extend({}, that.options, options);

            extend(that, {
                _map: {},
                _models: {},
                _data: [],
                _view: [],
                _pageSize: options.pageSize,
                _page: options.page || (options.pageSize ? 1 : undefined),
                _sort: options.sort,
                _filter: options.filter,
                _group: options.group,
                _aggregates: options.aggregates
            });

            Observable.fn.init.call(that);

            model = options.model;
            transport = options.transport;

            if (model === undefined) {
                model = {};
            } else if (isPlainObject(model)) {
                options.model = model = Model.define(model);
            }

            id = model.id;

            that._deserializer = extend({
                data: identity,
                total: function (data) {
                    return data.length;
                },
                status: function (data) {
                    return data.status;
                },
                groups: function (data) {
                    return data;
                },
                aggregates: function (data) {
                    return {};
                }
            }, options.deserializer);

            if (transport) {
                that.transport = isFunction(transport.read) ? transport : new RemoteTransport(transport);
            } else {
                that.transport = new LocalTransport({ data: options.data });
            }

            if (id) {
                that.find = function (id) {
                    return that._data[that._map[id]];
                };
                that.id = function (record) {
                    return id(record);
                };
            } else {
                that.find = that.at;
            }

            that.bind([ERROR, CHANGE, CREATE, DESTROY, UPDATE], options);
        },

        options: {
            data: [],
            serverSorting: false,
            serverPaging: false,
            serverFiltering: false,
            serverGrouping: false,
            serverAggregates: false,
            autoSync: false,
            sendAllFields: true,
            batch: {
                mode: "multiple"
            }
        },

        model: function (id) {
            var that = this,
                model = id && that._models[id];

            if (!model) {
                model = new that.options.model(that.find(id));
                that._models[model.id()] = model;
                model.bind(CHANGE, function () {
                    that.trigger(UPDATE, { model: model });
                });
            }

            return model;
        },

        _idMap: function (data) {
            var that = this, id = that.id, idx, length, map = {};

            if (id) {
                for (idx = 0, length = data.length; idx < length; idx++) {
                    map[id(data[idx])] = idx;
                }
            }

            that._map = map;
        },

        _byState: function (state, selector) {
            var models = this._models,
                result = [],
                model,
                selector = selector || identity,
                id;

            for (id in models) {
                model = models[id];

                if (model.state === state) {
                    result.push(selector(model));
                }
            }

            return result;
        },

        _createdModels: function () {
            return this._byState(Model.CREATED, function (model) {
                return model.data;
            });
        },

        _updatedModels: function () {
            var that = this,
                sendAllFields = that.options.sendAllFields;
            return that._byState(Model.UPDATED, function (model) {
                if (sendAllFields) {
                    return model.data;
                }

                return model.changes();
            });
        },

        _destroyedModels: function () {
            var that = this,
                options = that.options;

            return that._byState(Model.DESTROYED, function (model) {
                var data = {};

                if (options.sendAllFields) {
                    return model.data;
                }

                options.model.id(data, model.id());

                return data;
            });
        },

        sync: function () {
            var that = this,
                updated,
                created,
                destroyed,
                batch = that.options.batch,
                mode,
                transport = that.transport,
                promises = that._promises = [];

            updated = that._updatedModels();

            created = that._createdModels();

            destroyed = that._destroyedModels();

            if (batch === false) {
                mode = "multiple";
            }
            else if ((batch.mode || "multiple") === "multiple") {
                mode = "single";
            }

            if (mode) {
                that._send(created, proxy(transport.create, transport), mode);
                that._send(updated, proxy(transport.update, transport), mode);
                that._send(destroyed, proxy(transport.destroy, transport), mode);
            } else {
                that._send({
                    created: created,
                    updated: updated,
                    destroyed: destroyed
                },
                    proxy(transport.update, transport),
                    "single"
                );
            }

            $.when.apply(null, promises).then(function () {
                that.trigger(CHANGE);
            });
        },

        _syncSuccess: function (origData, data) {
            var that = this,
                origValue,
                origId,
                models = that._models,
                map = that._map,
                deserializer = that._deserializer;

            if (!deserializer.status(data)) {
                return that.error({ data: origData });
            }

            $.each(origData, function (index, value) {
                delete models[that.id(value)];
            });

            data = deserializer.data(data);
            $.each(data, function (index, value) {
                origValue = origData[index];
                if (origValue) {
                    origId = that.id(origValue);
                    index = map[origId];

                    if (index >= 0) {
                        that._data[index] = value;
                    }
                }
            });
            that._idMap(that._data);
        },

        _syncError: function (origData, data) {
            this.error({ data: origData });
        },

        _send: function (data, method, mode) {
            var that = this,
                idx,
                promises = that._promises,
                success = proxy(that._syncSuccess, that, data),
                error = proxy(that._syncError, that, data);

            if (data.length == 0) {
                return;
            }

            if (mode === "multiple") {
                for (idx = 0, length = data.length; idx < length; idx++) {
                    promises.push(
                        method({
                            data: data[idx],
                            success: success,
                            error: error
                        })
                    );
                }
            } else {
                promises.push(
                    method({
                        data: data,
                        success: success,
                        error: error
                    })
                );
            }

            return promises;
        },

        create: function (index, values) {
            var that = this,
                data = that._data,
                model = that.model();

            if (typeof index !== "number") {
                values = index;
                index = undefined;
            }

            model.set(values);

            index = index !== undefined ? index : data.length;

            data.splice(index, 0, model.data);

            that._idMap(data);

            that.trigger(CREATE, { model: model });

            return model;
        },

        read: function (additionalData) {
            var that = this,
                options = extend(additionalData, {
                    page: that._page,
                    pageSize: that._pageSize,
                    sort: that._sort,
                    filter: that._filter,
                    group: that._group,
                    aggregates: that._aggregates
                });

            that.transport.read({
                data: options,
                success: proxy(that.success, that),
                error: proxy(that.error, that)
            });
        },

        update: function (id, values) {
            var that = this,
            model = that.model(id);

            if (model) {
                model.set(values);
            }
        },

        destroy: function (id) {
            var that = this,
            model = that.model(id);

            if (model) {
                that._data.splice(that._map[id], 1);

                that._idMap(that._data);

                model.destroy();

                that.trigger(DESTROY, { model: model });
            }
        },

        error: function () {
            this.trigger(ERROR, arguments);
        },

        success: function (data) {
            var that = this,
            options = {},
            result,
            updated = Model ? that._updatedModels() : [],
            hasGroups = that.options.serverGrouping === true && that._group && that._group.length > 0,
            models = that._models;

            that._total = that._deserializer.total(data);

            if (that._aggregates && that.options.serverAggregates) {
                that._aggregateResult = that._deserializer.aggregates(data);
            }

            if (hasGroups) {
                data = that._deserializer.groups(data);
            } else {
                data = that._deserializer.data(data);
            }

            that._data = data;

            $.each(updated, function () {
                var updatedId = that.id(this);
                $.each(data, function () {
                    if (updatedId === that.id(this)) {
                        delete models[updatedId];
                    }
                });
            });

            if (that.options.serverPaging !== true) {
                options.page = that._page;
                options.pageSize = that._pageSize;
            }

            if (that.options.serverSorting !== true) {
                options.sort = that._sort;
            }

            if (that.options.serverFiltering !== true) {
                options.filter = that._filter;
            }

            if (that.options.serverGrouping !== true) {
                options.group = that._group;
            }

            if (that.options.serverAggregates !== true) {
                options.aggregates = that._aggregates;
                that._aggregateResult = calculateAggregates(data, options);
            }

            result = process(data, options);

            that._view = result.data;

            if (result.total !== undefined && !that.options.serverFiltering) {
                that._total = result.total;
            }

            that._idMap(data);

            that.trigger(CHANGE);
        },

        changes: function (id) {
            var that = this,
                model = that._models[id];

            if (model && model.state === Model.UPDATED) {
                return model.changes();
            }
        },

        hasChanges: function (id) {
            var that = this,
                model,
                models = that._models,
                id;

            if (id === undefined) {
                for (id in models) {
                    if (models[id].state !== Model.PRISTINE) {
                        return true;
                    }
                }

                return false;
            }

            model = models[id];

            return !!model && model.state === Model.UPDATED;
        },

        at: function (index) {
            return this._data[index];
        },

        data: function (value) {
            if (value !== undefined) {
                this._data = value;
            } else {
                return this._data;
            }
        },

        view: function () {
            return this._view;
        },

        query: function (options) {
            var that = this,
                options = options,
                result,
                remote = that.options.serverSorting || that.options.serverPaging || that.options.serverFiltering || that.options.serverGrouping || that.options.serverAggregates;

            if (options !== undefined) {
                that._pageSize = options.pageSize;
                that._page = options.page;
                that._sort = options.sort;
                that._filter = options.filter;
                that._group = options.group;
                that._aggregates = options.aggregates;

                if (options.sort) {
                    that._sort = options.sort = Query.expandSort(options.sort);
                }

                if (options.filter) {
                    that._filter = options.filter = Query.expandFilter(options.filter);
                }

                if (options.group) {
                    that._group = options.group = Query.expandGroup(options.group);
                }
                if (options.aggregates) {
                    that._aggregates = options.aggregates = Query.expandAggregates(options.aggregates);
                }
            }

            if (remote || (that._data === undefined || that._data.length == 0)) {
                that.read(options);
            } else {
                result = process(that._data, options);

                if (result.total !== undefined && !that.options.serverFiltering) {
                    that._total = result.total;
                }

                that._view = result.data;
                that._aggregateResult = calculateAggregates(that._data, options);
                that.trigger(CHANGE);
            }
        },

        fetch: function () {
            var that = this;

            that.query({
                page: that.page(),
                pageSize: that.pageSize(),
                sort: that.sort(),
                filter: that.filter(),
                group: that.group(),
                aggregate: that.aggregate()
            });
        },

        page: function (val) {
            var that = this;

            if (val !== undefined) {
                val = Math.max(Math.min(Math.max(val, 1), that._totalPages()), 1);
                that.query({ page: val, pageSize: that.pageSize(), sort: that.sort(), filter: that.filter(), group: that.group(), aggregates: that.aggregate() });
                return;
            }
            return that._page;
        },

        pageSize: function (val) {
            var that = this;

            if (val !== undefined) {
                that.query({ page: that.page(), pageSize: val, sort: that.sort(), filter: that.filter(), group: that.group(), aggregates: that.aggregate() });
                return;
            }

            return that._pageSize;
        },

        sort: function (val) {
            var that = this;

            if (val !== undefined) {
                that.query({ page: that.page(), pageSize: that.pageSize(), sort: val, filter: that.filter(), group: that.group(), aggregates: that.aggregate() });
                return;
            }

            return this._sort;
        },

        filter: function (val) {
            var that = this;

            if (val !== undefined) {
                that.query({ page: that.page(), pageSize: that.pageSize(), sort: that.sort(), filter: val, group: that.group(), aggregates: that.aggregate() });
                return;
            }

            return that._filter;
        },

        group: function (val) {
            var that = this;

            if (val !== undefined) {
                that.query({ page: that.page(), pageSize: that.pageSize(), sort: that.sort(), filter: that.filter(), group: val, aggregates: that.aggregate() });
                return;
            }

            return that._group;
        },

        total: function () {
            return this._total;
        },

        aggregate: function (val) {
            var that = this;

            if (val !== undefined) {
                that.query({ page: that.page(), pageSize: that.pageSize(), sort: that.sort(), filter: val, group: that.group(), aggregates: val });
                return;
            }

            return that._aggregates;
        },
        aggregates: function () {
            return this._aggregateResult;
        },
        _totalPages: function () {
            var that = this,
                pageSize = that.pageSize() || that.total();

            return Math.ceil((that.total() || 0) / pageSize);
        }
    });

    DataSource.create = function (options) {
        options = $.isArray(options) ? { data: options} : options;

        var dataSource = options || {},
            data = dataSource.data,
            fields = dataSource.fields,
            table = dataSource.table,
            select = dataSource.select;

        if (fields) {
            if (!data) {
                if (table) {
                    data = inferTable(table, fields);
                } else if (select) {
                    data = inferSelect(select, fields);
                }
            } else if (select) {
                rebuildSelect(data, select, fields);
            }
        }

        dataSource.data = data;

        return dataSource instanceof DataSource ? dataSource : new DataSource(dataSource);
    };

    function inferSelect(select, fields) {
        var options = $(select)[0].children,
            optionIndex,
            optionCount,
            data = [],
            record,
            option;

        for (optionIndex = 0, optionCount = options.length; optionIndex < optionCount; optionIndex++) {
            record = {};
            option = options[optionIndex];

            record[fields[0].field] = option.text;
            record[fields[1].field] = option.value;

            data.push(record);
        }

        return data;
    }

    function rebuildSelect(data, select, fields) {
        var getText = getter(fields[0].field),
            getValue = getter(fields[1].field),
            length = data.length,
            options = [],
            i = 0;

        for (; i < length; i++) {
            var option = "<option",
               dataItem = data[i],
               text = getText(dataItem),
               value = getValue(dataItem);

            if (value || value === 0) {
                option += " value=" + value;
            }

            option += ">";

            if (text || text === 0) {
                option += text;
            }

            option += "</option>";
            options.push(option);
        }

        select.html(options.join(""));
    }

    function inferTable(table, fields) {
        var tbody = $(table)[0].tBodies[0],
        rows = tbody ? tbody.rows : [],
        rowIndex,
        rowCount,
        fieldIndex,
        fieldCount = fields.length,
        data = [],
        cells,
        record,
        cell,
        empty;

        for (rowIndex = 0, rowCount = rows.length; rowIndex < rowCount; rowIndex++) {
            record = {};
            empty = true;
            cells = rows[rowIndex].cells;

            for (fieldIndex = 0; fieldIndex < fieldCount; fieldIndex++) {
                cell = cells[fieldIndex];
                if (cell.nodeName.toLowerCase() !== "th") {
                    empty = false;
                    record[fields[fieldIndex].field] = cell.innerHTML;
                }
            }
            if (!empty) {
                data.push(record);
            }
        }

        return data;
    }

    $t.DataSource = DataSource;
    $t.Model = Model;
    $t.getter = getter;
    $t.setter = setter;

    //Template ================================
    var Template = {
        paramName: "data", // name of the parameter of the generated template
        useWithBlock: true, // whether to wrap the template in a with() block
        begin: "<#", // the marker which denotes the beginning of executable code
        end: "#>", // the marker which denotes the end of executable code
        render: function (template, data) {
            var idx,
                length,
                html = "";

            for (idx = 0, length = data.length; idx < length; idx++) {
                html += template(data[idx]);
            }

            return html;
        },
        compile: function (template, options) {
            var settings = extend({}, this, options),
                paramName = settings.paramName,
                begin = settings.begin,
                end = settings.end,
                useWithBlock = settings.useWithBlock,
                functionBody = "var o='',e = $.telerik.htmlEncode;",
                encodeRegExp = /\${([^}]*)}/g,
                evalRegExp = new RegExp(begin + "=(.+?)" + end, "g"),
                quoteRegExp = new RegExp("'(?=[^" + end[0] + "]*" + end + ")", "g");

            functionBody += useWithBlock ? "with(" + paramName + "){" : "";

            functionBody += "o+='";

            functionBody += template.replace(/[\r\t\n]/g, " ")
                .replace(quoteRegExp, "\t")
                .split("'").join("\\'")
                .split("\t").join("'")
                .replace(encodeRegExp, "';o+=e($1);o+='")
                .replace(evalRegExp, "';o+=$1;o+='")
                .split(begin).join("';")
                .split(end).join("o+='");

            functionBody += useWithBlock ? "'}" : "';";

            functionBody += "return o;";

            return new Function(paramName, functionBody);
        }
    };

    function htmlEncode(value) {
        return ("" + value).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    $.telerik.template = $.proxy(Template.compile, Template);
    $.telerik.htmlEncode = htmlEncode;

    //Component ================================
    var Component = Observable.extend({
        init: function (element, options) {
            var that = this;

            Observable.fn.init.call(that);
            that.element = $(element);
            that.options = extend(true, {}, that.options, options);
        }
    });

    $.telerik.Component = Component;

    //end core.js ==================================================
    //==============================================================
    //==============================================================
})(jQuery);
(function ($, undefined) {

    // Imports ================================================================
    var doc = document,
        $t = $.telerik,
        Class = $t.Class,
        Widget = $t.Component,
        DataSource = $t.DataSource,
        baseTemplate = $t.template,
        format = function() { return $t.formatString.apply($t, arguments); },
        map = $.map,
        grep = $.grep,
        each = $.each,
        math = Math,
        proxy = $.proxy,
        getter = $t.getter,
        extend = $.extend,
        trigger = $t.trigger,
        DATA_BINDING = "dataBinding";

    var template = function(template) {
        var paramName = "d",
            useWithBlock = false,
            functionBody = "var o,e=$.telerik.htmlEncode;",
            encodeRegExp = /\${([^}]*)}/g,
            parts,
            part,
            idx;

        if ($.isFunction(template)) {
            if (template.length === 2) {
                //looks like jQuery.template
                return function(d) {
                    return template($, { data: d }).join("");
                }
            }
            return template;
        }

        functionBody += useWithBlock ? "with(" + paramName + "){" : "";

        functionBody += "o=";

        parts = template
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t')
            .replace(encodeRegExp, "#=e($1)#")
            .replace(/\\#/g, "__SHARP__")
            .split("#");

        for (idx = 0; idx < parts.length; idx ++) {
            part = parts[idx];

            if (idx % 2 === 0) {
                functionBody += "\'" + part.split("'").join("\\'") + "'";
            } else {
                if (part.charAt(0) === "=") {
                        functionBody += "+(" + part.substring(1) + ")+";
                } else {
                    functionBody += ";" + part + ";o+=";
                }
            }
        }

        functionBody += useWithBlock ? ";}" : ";";

        functionBody += "return o;";

        functionBody = functionBody.replace(/__SHARP__/g, '#');

        return new Function(paramName, functionBody);
    }

    // Constants ==============================================================
    var ABOVE = "above",
        ANIMATION_STEP = 10,
        AREA = "area",
        BASELINE_MARKER_SIZE = 1,
        BAR = "bar",
        BAR_BORDER_BRIGHTNESS = 0.8,
        BAR_GAP = 1.5,
        BAR_SPACING = 0.4,
        BELOW = "below",
        BLACK = "#000",
        BOTTOM = "bottom",
        CENTER = "center",
        CHANGE = "change",
        CIRCLE = "circle",
        CLICK = "click",
        CLIP = "clip",
        COLUMN = "column",
        COORD_PRECISION = 3,
        DATABOUND = "dataBound",
        DEFAULT_FONT = "12px sans-serif",
        DEFAULT_HEIGHT = 400,
        DEFAULT_PRECISION = 6,
        DEFAULT_WIDTH = 600,
        DEGREE = math.PI / 180,
        FADEIN = "fadeIn",
        GLASS = "glass",
        HEIGHT = "height",
        HORIZONTAL = "horizontal",
        ID_PREFIX = "k",
        INITIAL_ANIMATION_DURATION = 600,
        INSIDE_BASE = "insideBase",
        INSIDE_END = "insideEnd",
        INTERPOLATE = "interpolate",
        LEFT = "left",
        LINE = "line",
        LINE_MARKER_SIZE = 8,
        LINEAR = "linear",
        MAX_VALUE = Number.MAX_VALUE,
        MIN_VALUE = -Number.MAX_VALUE,
        MOUSEMOVE_TRACKING = "mousemove.tracking",
        MOUSEOVER = "mouseover",
        NONE = "none",
        OBJECT = "object",
        ON_MINOR_TICKS = "onMinorTicks",
        OUTSIDE = "outside",
        OUTSIDE_END = "outsideEnd",
        OUTLINE_SUFFIX = "_outline",
        PIE = "pie",
        PIE_SECTOR_ANIM_DELAY = 70,
        PRIMARY = "primary",
        RADIAL = "radial",
        RIGHT = "right",
        ROUNDED_BEVEL = "roundedBevel",
        SCATTER = "scatter",
        SCATTER_LINE = "scatterLine",
        SERIES_CLICK = "seriesClick",
        SQUARE = "square",
        SWING = "swing",
        TOP = "top",
        TOOLTIP_ANIMATION_DURATION = 150,
        TOOLTIP_OFFSET = 5,
        TOOLTIP_SHOW_DELAY = 100,
        TRIANGLE = "triangle",
        UNDEFINED = "undefined",
        VERTICAL = "vertical",
        VERTICAL_LINE = "verticalLine",
        VERTICAL_AREA = "verticalArea",
        WIDTH = "width",
        WHITE = "#fff",
        X = "x",
        Y = "y",
        ZERO = "zero",
        ZERO_THRESHOLD = 0.2;

    var CATEGORICAL_CHARTS = [BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA],
        XY_CHARTS = [SCATTER, SCATTER_LINE];

    // Chart ==================================================================
    var Chart = Widget.extend({
        init: function(element, userOptions) {
            var chart = this,
                options,
                themeOptions,
                theme;

            Widget.fn.init.call(chart, element);
            options = deepExtend({}, chart.options, userOptions);

            theme = options.theme;
            themeOptions = theme ? Chart.themes[theme] || Chart.themes[theme.toLowerCase()] : {};

            applyDefaults(options, themeOptions);

            chart.options = deepExtend({}, themeOptions, options);

            applySeriesColors(chart.options);

            chart.bind([
                DATABOUND,
                SERIES_CLICK
            ], chart.options);

            $(element).addClass("k-chart");

            if (userOptions && userOptions.dataSource) {
                chart.dataSource = DataSource
                    .create(userOptions.dataSource)
                    .bind(CHANGE, proxy(chart._onDataChanged, chart));

                if (options.autoBind) {
                    chart.dataSource.fetch();
                }
            }

            chart._redraw();
            chart._attachEvents();
        },

        options: {
            name: "Chart",
            chartArea: {},
            title: {
                visible: true
            },
            legend: {
                visible: true
            },
            valueAxis: {
                type: "Numeric"
            },
            categoryAxis: {
                categories: []
            },
            autoBind: true,
            seriesDefaults: {
                type: COLUMN,
                data: [],
                bar: {
                    gap: BAR_GAP,
                    spacing: BAR_SPACING
                },
                column: {
                    gap: BAR_GAP,
                    spacing: BAR_SPACING
                },
                line: {
                    width: 4
                },
                labels: {}
            },
            series: [],
            tooltip: {
                visible: false
            },
            transitions: true
        },

        refresh: function() {
            var chart = this;

            applyDefaults(chart.options);

            if (chart.dataSource) {
                chart.dataSource.read();
            } else {
                chart._redraw();
            }
        },

        redraw: function() {
            var chart = this;

            applyDefaults(chart.options);

            chart._redraw();
        },

        _redraw: function() {
            var chart = this,
                options = chart.options,
                element = chart.element,
                model = chart._model = chart._getModel(),
                plotArea = chart._plotArea = model._plotArea,
                viewClass = chart._supportsSVG() ? Chart.SVGView : Chart.VMLView,
                view = chart._view = viewClass.fromModel(model);

            element.css("position", "relative");
            chart._viewElement = view.renderTo(element[0]);
            chart._tooltip = new Tooltip(element, options.tooltip);
            chart._highlight = new Highlight(view, chart._viewElement);
        },

        svg: function() {
            var model = this._getModel(),
                view = Chart.SVGView.fromModel(model);

            return view.render();
        },

        _getModel: function() {
            var chart = this,
                options = chart.options,
                element = chart.element,
                model = new RootElement(deepExtend({
                    width: element.width() || DEFAULT_WIDTH,
                    height: element.height() || DEFAULT_HEIGHT,
                    transitions: options.transitions
                    }, options.chartArea)),
                plotArea;

            if (options.title && options.title.visible && options.title.text) {
                model.append(new Title(options.title));
            }

            plotArea = model._plotArea = chart._createPlotArea();
            if (options.legend.visible) {
                model.append(new Legend(plotArea.options.legend));
            }
            model.append(plotArea);
            model.reflow();

            return model;
        },

        _createPlotArea: function() {
            var chart = this,
                options = chart.options,
                series = options.series,
                i,
                length = series.length,
                currentSeries,
                categoricalSeries = [],
                xySeries = [],
                pieSeries = [],
                plotArea;

            for (i = 0; i < length; i++) {
                currentSeries = series[i];

                if (inArray(currentSeries.type, CATEGORICAL_CHARTS)) {
                    categoricalSeries.push(currentSeries);
                } else if (inArray(currentSeries.type, XY_CHARTS)) {
                    xySeries.push(currentSeries);
                } else if (currentSeries.type === PIE) {
                    pieSeries.push(currentSeries);
                }
            }

            if (pieSeries.length > 0) {
                plotArea = new PiePlotArea(pieSeries, options);
            } else if (xySeries.length > 0) {
                plotArea = new XYPlotArea(xySeries, options);
            } else {
                plotArea = new CategoricalPlotArea(categoricalSeries, options);
            }

            return plotArea;
        },

        // Needs to be overridable in tests
        _supportsSVG: supportsSVG,

        _attachEvents: function() {
            var chart = this,
                element = chart.element;

            element.bind(CLICK, proxy(chart._click, chart));
            element.bind(MOUSEOVER, proxy(chart._mouseOver, chart));
        },

        _getPoint: function(e) {
            var chart = this,
                model = chart._model,
                coords = chart._eventCoordinates(e),
                targetId = e.target.id,
                chartElement = model.idMap[targetId],
                metadata = model.idMapMetadata[targetId],
                point;

            if (chartElement) {
                if (chartElement.getNearestPoint && metadata) {
                    point = chartElement.getNearestPoint(coords.x, coords.y, metadata.seriesIx);
                } else {
                    point = chartElement;
                }
            }

            return point;
        },

        _eventCoordinates: function(e) {
            var element = this.element,
                offset = element.offset(),
                paddingLeft = parseInt(element.css("paddingLeft"), 10),
                paddingTop = parseInt(element.css("paddingTop"), 10),
                win = $(window);

            return({
                x: e.clientX - offset.left - paddingLeft + win.scrollLeft(),
                y: e.clientY - offset.top - paddingTop + win.scrollTop()
            });
        },

        _click: function(e) {
            var chart = this,
                point = chart._getPoint(e);

            if (point) {
                chart.trigger(SERIES_CLICK, {
                    value: point.value,
                    category: point.category,
                    series: point.series,
                    dataItem: point.dataItem,
                    element: $(e.target)
                });
            }
        },

        _mouseOver: function(e) {
            var chart = this,
                tooltip = chart._tooltip,
                highlight = chart._highlight,
                tooltipOptions,
                point;

            if (!highlight || highlight.element === e.target) {
                return;
            }

            point = chart._getPoint(e);
            if (point) {
                chart._activePoint = point;
                tooltipOptions = deepExtend({}, chart.options.tooltip, point.options.tooltip);
                if (tooltipOptions.visible) {
                    tooltip.show(point);
                }

                highlight.show(point);

                $(doc.body).bind(MOUSEMOVE_TRACKING, proxy(chart._mouseMove, chart));
            }
        },

        _mouseMove: function(e) {
            var chart = this,
                tooltip = chart._tooltip,
                highlight = chart._highlight,
                coords = chart._eventCoordinates(e),
                point = chart._activePoint,
                tooltipOptions,
                owner,
                seriesPoint;

            if (chart._plotArea.box.containsPoint(coords.x, coords.y)) {
                if (point && (point.series.type === LINE || point.series.type === AREA)) {
                    owner = point.owner;
                    seriesPoint = owner.getNearestPoint(coords.x, coords.y, point.seriesIx);
                    if (seriesPoint && seriesPoint != point) {
                        chart._activePoint = seriesPoint;

                        tooltipOptions = deepExtend({}, chart.options.tooltip, point.options.tooltip);
                        if (tooltipOptions.visible) {
                            tooltip.show(seriesPoint);
                        }
                        highlight.show(seriesPoint);
                    }
                }
            } else {
                $(doc.body).unbind(MOUSEMOVE_TRACKING);

                delete chart._activePoint;
                tooltip.hide();
                highlight.hide();
            }
        },

        _onDataChanged: function() {
            var chart = this,
                options = chart.options,
                series = options.series,
                categoryAxis = options.categoryAxis,
                data = chart.dataSource.view(),
                row,
                category,
                currentSeries,
                value;

            for (var seriesIdx = 0, seriesLength = series.length; seriesIdx < seriesLength; seriesIdx++) {
                currentSeries = series[seriesIdx];
                if (currentSeries.field || (currentSeries.xField && currentSeries.yField)) {
                    currentSeries.data = [];
                    currentSeries.dataItems = [];
                }
            }

            for (var dataIdx = 0, dataLength = data.length; dataIdx < dataLength; dataIdx++) {
                row = data[dataIdx];

                if (categoryAxis.field) {
                    category = getField(categoryAxis.field, row);
                    if (dataIdx === 0) {
                        categoryAxis.categories = [category];
                    } else {
                        categoryAxis.categories.push(category);
                    }
                }

                for (var seriesIdx = 0, seriesLength = series.length; seriesIdx < seriesLength; seriesIdx++) {
                    currentSeries = series[seriesIdx];

                    if (currentSeries.field) {
                        value = getField(currentSeries.field, row);
                    } else if (currentSeries.xField && currentSeries.yField) {
                        value = [getField(currentSeries.xField, row),
                                 getField(currentSeries.yField, row)];
                    } else {
                        value = undefined;
                    }

                    if (defined(value)) {
                        if (dataIdx === 0) {
                            currentSeries.data = [value];
                            currentSeries.dataItems = [row];
                        } else {
                            currentSeries.data.push(value);
                            currentSeries.dataItems.push(row);
                        }
                    }
                }
            }

            chart.trigger(DATABOUND);
            chart._redraw();
        }
    });


    // **************************
    // View Model
    // **************************
    var Point2D = Class.extend({
        init: function(x, y) {
            var point = this;
            point.x = round(x, COORD_PRECISION);
            point.y = round(y, COORD_PRECISION);
        }
    });

    var Box2D = Class.extend({
        init: function(x1, y1, x2, y2) {
            var box = this;
            box.x1 = x1 || 0;
            box.x2 = x2 || 0;
            box.y1 = y1 || 0;
            box.y2 = y2 || 0;
        },

        width: function() {
            return this.x2 - this.x1;
        },

        height: function() {
            return this.y2 - this.y1;
        },

        translate: function(dx, dy) {
            var box = this;

            box.x1 += dx;
            box.x2 += dx;
            box.y1 += dy;
            box.y2 += dy;

            return box;
        },

        move: function(x, y) {
            var box = this,
                height = box.height(),
                width = box.width();

            box.x1 = x;
            box.y1 = y;
            box.x2 = box.x1 + width;
            box.y2 = box.y1 + height;

            return box;
        },

        wrap: function(targetBox) {
            var box = this;

            box.x1 = math.min(box.x1, targetBox.x1);
            box.y1 = math.min(box.y1, targetBox.y1);
            box.x2 = math.max(box.x2, targetBox.x2);
            box.y2 = math.max(box.y2, targetBox.y2);

            return box;
        },

        snapTo: function(targetBox, axis) {
            var box = this;

            if (axis == X || !axis) {
                box.x1 = targetBox.x1;
                box.x2 = targetBox.x2;
            }

            if (axis == Y || !axis) {
                box.y1 = targetBox.y1;
                box.y2 = targetBox.y2;
            }

            return box;
        },

        alignTo: function(targetBox, edge) {
            var box = this,
                height = box.height(),
                width = box.width(),
                axis = edge == TOP || edge == BOTTOM ? Y : X,
                offset = axis == Y ? height : width;

            if (edge == TOP || edge == LEFT) {
                box[axis + 1] = targetBox[axis + 1] - offset;
            } else {
                box[axis + 1] = targetBox[axis + 2];
            }

            box.x2 = box.x1 + width;
            box.y2 = box.y1 + height;

            return box;
        },

        shrink: function(dw, dh) {
            var box = this;

            box.x2 -= dw;
            box.y2 -= dh;

            return box;
        },

        expand: function(dw, dh) {
            this.shrink(-dw, -dh);
            return this;
        },

        pad: function(padding) {
            var box = this,
                spacing = getSpacing(padding);

            box.x1 -= spacing.left;
            box.x2 += spacing.right;
            box.y1 -= spacing.top;
            box.y2 += spacing.bottom;

            return box;
        },

        unpad: function(padding) {
            var box = this,
                spacing = getSpacing(padding);

            spacing.left = -spacing.left;
            spacing.top = -spacing.top;
            spacing.right = -spacing.right;
            spacing.bottom = -spacing.bottom;

            return box.pad(spacing);
        },

        clone: function() {
            var box = this;

            return new Box2D(box.x1, box.y1, box.x2, box.y2);
        },

        center: function() {
            var box = this;

            return {
                x: box.x1 + box.width() / 2,
                y: box.y1 + box.height() / 2
            };
        },

        containsPoint: function(x, y) {
            var box = this;

            return x >= box.x1 && x <= box.x2 &&
                   y >= box.y1 && y <= box.y2;
        },

        points: function() {
            var box = this;

            return [
                new Point2D(box.x1, box.y1),
                new Point2D(box.x2, box.y1),
                new Point2D(box.x2, box.y2),
                new Point2D(box.x1, box.y2)
            ];
        }
    });

    var Sector = Class.extend({
        init: function(c, r, startAngle, angle) {
            var sector = this;

            sector.c = c;
            sector.r = r;
            sector.startAngle = startAngle;
            sector.angle = angle;
        },

        clone: function() {
            var s = this;
            return new Sector(s.c, s.r, s.startAngle, s.angle);
        },

        expand: function(value) {
            this.r += value;
            return this;
        },

        middle: function() {
            return this.startAngle + this.angle / 2;
        },

        radius: function(newRadius) {
            this.r = newRadius;
            return this;
        },

        point: function(angle) {
            var sector = this,
                radianAngle = angle * DEGREE,
                ax = math.cos(radianAngle),
                ay = math.sin(radianAngle),
                x = sector.c.x - (ax * sector.r),
                y = sector.c.y - (ay * sector.r);

            return new Point2D(x, y);
        }
    });

    var ChartElement = Class.extend({
        init: function(options) {
            var element = this;
            element.children = [];

            element.options = deepExtend({}, element.options, options);
        },

        reflow: function(targetBox) {
            var element = this,
                children = element.children,
                box,
                i,
                currentChild;

            for (i = 0; i < children.length; i++) {
                currentChild = children[i];

                currentChild.reflow(targetBox);
                box = box ? box.wrap(currentChild.box) : currentChild.box.clone();
            }

            element.box = box;
        },

        getViewElements: function(view) {
            var element = this,
                viewElements = [],
                children = element.children,
                childrenCount = children.length;

            for (var i = 0; i < childrenCount; i++) {
                viewElements.push.apply(viewElements,
                    children[i].getViewElements(view));
            }

            return viewElements;
        },

        registerId: function(id, metadata) {
            var element = this,
                root;

            root = element.getRoot();
            if (root) {
                root.idMap[id] = element;
                if (metadata) {
                    root.idMapMetadata[id] = metadata;
                }
            }
        },

        translateChildren: function(dx, dy) {
            var element = this,
                children = element.children,
                childrenCount = children.length,
                i;

            for (i = 0; i < childrenCount; i++) {
                children[i].box.translate(dx, dy);
            }
        },

        append: function() {
            var element = this,
                i,
                length = arguments.length;

            append(element.children, arguments);

            for (i = 0; i < length; i++) {
                arguments[i].parent = element;
            }
        },

        getRoot: function() {
            var element = this,
                parent = element.parent;

            return parent ? parent.getRoot() : null;
        }
    });

    var RootElement = ChartElement.extend({
        init: function(options) {
            var root = this;

            root.idMap = {};
            root.idMapMetadata = {};

            ChartElement.fn.init.call(root, options);
        },

        options: {
            width: DEFAULT_WIDTH,
            height: DEFAULT_HEIGHT,
            background: WHITE,
            border: {
                color: BLACK,
                width: 0
            },
            margin: getSpacing(5),
            zIndex: -1
        },

        reflow: function() {
            var root = this,
                options = root.options,
                children = root.children,
                currentBox = new Box2D(0, 0, options.width, options.height);

            root.box = currentBox.unpad(options.margin);

            for (var i = 0; i < children.length; i++) {
                children[i].reflow(currentBox);
                currentBox = boxDiff(currentBox, children[i].box);
            }
        },

        getViewElements: function(view) {
            var root = this,
                options = root.options,
                border = options.border || {},
                box = root.box.clone().pad(options.margin).unpad(border.width),
                elements = [
                        view.createRect(box, {
                            stroke: border.width ? border.color : "",
                            strokeWidth: border.width,
                            dashType: border.dashType,
                            fill: options.background,
                            zIndex: options.zIndex })
                    ];

            return elements.concat(
                ChartElement.fn.getViewElements.call(root, view)
            );
        },

        getRoot: function() {
            return this;
        }
    });

    var BoxElement = ChartElement.extend({
        init: function(options) {
            ChartElement.fn.init.call(this, options);
        },

        options: {
            align: LEFT,
            vAlign: TOP,
            margin: {},
            padding: {},
            border: {
                color: BLACK,
                width: 0
            },
            background: "",
            width: 0,
            height: 0,
            visible: true
        },

        reflow: function(targetBox) {
            var element = this,
                box,
                contentBox,
                options = element.options,
                children = element.children,
                margin = getSpacing(options.margin),
                padding = getSpacing(options.padding),
                border = options.border,
                borderWidth = border.width;

            ChartElement.fn.reflow.call(element, targetBox);

            if (children.length === 0) {
                box = element.box = new Box2D(0, 0, options.width, options.height);
            } else {
                box = element.box;
            }

            contentBox = element.contentBox = box.clone();

            box.pad(padding).pad(borderWidth).pad(margin);

            element.align(targetBox, X, options.align);
            element.align(targetBox, Y, options.vAlign);

            element.paddingBox = box.clone().unpad(margin).unpad(borderWidth);

            element.translateChildren(
                box.x1 - contentBox.x1 + margin.left + borderWidth + padding.left,
                box.y1 - contentBox.y1 + margin.top + borderWidth + padding.top);
        },

        align: function(targetBox, axis, alignment) {
            var element = this,
                box = element.box,
                c1 = axis + 1,
                c2 = axis + 2,
                sizeFunc = axis === X ? WIDTH : HEIGHT,
                size = box[sizeFunc]();

            if (inArray(alignment, [LEFT, TOP])) {
                box[c1] = targetBox[c1];
                box[c2] = box[c1] + size;
            } else if (inArray(alignment, [RIGHT, BOTTOM])) {
                box[c2] = targetBox[c2];
                box[c1] = box[c2] - size;
            } else if (alignment == CENTER) {
                box[c1] = targetBox[c1] + (targetBox[sizeFunc]() - size) / 2;
                box[c2] = box[c1] + size;
            }
        },

        hasBox: function() {
            var options = this.options;
            return options.border.width || options.background;
        },

        getViewElements: function(view, renderOptions) {
            var boxElement = this,
                options = boxElement.options;

            if (!options.visible) {
                return [];
            }

            var border = options.border || {},
                elements = [];

            if (boxElement.hasBox()) {
                elements.push(
                    view.createRect(boxElement.paddingBox, deepExtend({
                        id: options.id,
                        stroke: border.width ? border.color : "",
                        strokeWidth: border.width,
                        dashType: border.dashType,
                        strokeOpacity: options.opacity,
                        fill: options.background,
                        fillOpacity: options.opacity,
                        animation: options.animation,
                        zIndex: options.zIndex
                    }, renderOptions))
                );
            }

            return elements.concat(
                ChartElement.fn.getViewElements.call(boxElement, view)
            );
        }
    });

    var Text = ChartElement.extend({
        init: function(content, options) {
            var text = this;

            ChartElement.fn.init.call(text, options);

            // Calculate size
            text.content = content;
            text.reflow(new Box2D());
        },

        options: {
            font: DEFAULT_FONT,
            color: BLACK,
            align: LEFT,
            vAlign: ""
        },

        reflow: function(targetBox) {
            var text = this,
                options = text.options,
                size = options.size = measureText(
                                        text.content,
                                        { font: options.font },
                                        options.rotation);

            text.baseline = size.baseline;

            if (options.align == LEFT) {
                text.box = new Box2D(
                    targetBox.x1, targetBox.y1,
                    targetBox.x1 + size.width, targetBox.y1 + size.height);
            } else if (options.align == RIGHT) {
                text.box = new Box2D(
                    targetBox.x2 - size.width, targetBox.y1,
                    targetBox.x2, targetBox.y1 + size.height);
            } else if (options.align == CENTER) {
                var margin = (targetBox.width() - size.width) / 2;
                text.box = new Box2D(
                    round(targetBox.x1 + margin, COORD_PRECISION), targetBox.y1,
                    round(targetBox.x2 - margin, COORD_PRECISION), targetBox.y1 + size.height);
            }

            if (options.vAlign == CENTER) {
                var margin = (targetBox.height() - size.height) /2;
                text.box = new Box2D(
                    text.box.x1, targetBox.y1 + margin,
                    text.box.x2, targetBox.y2 - margin);
            } else if (options.vAlign == BOTTOM) {
                text.box = new Box2D(
                    text.box.x1, targetBox.y2 - size.height,
                    text.box.x2, targetBox.y2);
            } else if (options.vAlign == TOP) {
                text.box = new Box2D(
                    text.box.x1, targetBox.y1,
                    text.box.x2, targetBox.y1 + size.height);
            }
        },

        getViewElements: function(view) {
            var text = this,
                options = text.options;

            ChartElement.fn.getViewElements.call(this, view);

            return [
                view.createText(text.content,
                    deepExtend({}, options, {
                        x: text.box.x1, y: text.box.y1,
                        baseline: text.baseline
                    })
                )
            ];
        }
    });

    var TextBox = BoxElement.extend({
        init: function(content, options) {
            var textBox = this,
                text;

            BoxElement.fn.init.call(textBox, options);
            options = textBox.options;

            if (!options.template) {
                content = options.format ? format(options.format, content) : content
            }

            text = new Text(content, deepExtend({ }, options, { align: LEFT, vAlign: TOP }));
            textBox.append(text);

            if (textBox.hasBox()) {
                text.options.id = uniqueId();
            }

            // Calculate size
            textBox.reflow(new Box2D());
        }
    });

    var BarLabel = ChartElement.extend({
        init: function(content, options) {
            var barLabel = this;
            ChartElement.fn.init.call(barLabel, options);

            barLabel.append(new TextBox(content, barLabel.options));
        },

        options: {
            position: OUTSIDE_END,
            margin: getSpacing(3),
            padding: getSpacing(4),
            color: BLACK,
            background: "",
            border: {
                width: 1,
                color: ""
            },
            aboveAxis: true,
            isVertical: false,
            animation: {
                type: FADEIN,
                delay: INITIAL_ANIMATION_DURATION
            },
            zIndex: 1
        },

        reflow: function(targetBox) {
            var barLabel = this,
                options = barLabel.options,
                isVertical = options.isVertical,
                aboveAxis = options.aboveAxis,
                text = barLabel.children[0],
                box = text.box,
                padding = text.options.padding;

            text.options.align = isVertical ? CENTER : LEFT;
            text.options.vAlign = isVertical ? TOP : CENTER;

            if (options.position == INSIDE_END) {
                if (isVertical) {
                    text.options.vAlign = TOP;

                    if (!aboveAxis && box.height() < targetBox.height()) {
                        text.options.vAlign = BOTTOM;
                    }
                } else {
                    text.options.align = aboveAxis ? RIGHT : LEFT;
                }
            } else if (options.position == CENTER) {
                text.options.vAlign = CENTER;
                text.options.align = CENTER;
            } else if (options.position == INSIDE_BASE) {
                if (isVertical) {
                    text.options.vAlign = aboveAxis ? BOTTOM : TOP;
                } else {
                    text.options.align = aboveAxis ? LEFT : RIGHT;
                }
            } else if (options.position == OUTSIDE_END) {
                if (isVertical) {
                    if (aboveAxis) {
                        targetBox = new Box2D(
                            targetBox.x1, targetBox.y1 - box.height(),
                            targetBox.x2, targetBox.y1
                        );
                    } else {
                        targetBox = new Box2D(
                            targetBox.x1, targetBox.y2,
                            targetBox.x2, targetBox.y2 + box.height()
                        );
                    }
                } else {
                    text.options.align = CENTER;
                    if (aboveAxis) {
                        targetBox = new Box2D(
                            targetBox.x2 + box.width(), targetBox.y1,
                            targetBox.x2, targetBox.y2
                        );
                    } else {
                        targetBox = new Box2D(
                            targetBox.x1 - box.width(), targetBox.y1,
                            targetBox.x1, targetBox.y2
                        );
                    }
                }
            }

            if (isVertical) {
                padding.left = padding.right =
                    (targetBox.width() - text.contentBox.width()) / 2;
            } else {
                padding.top = padding.bottom =
                    (targetBox.height() - text.contentBox.height()) / 2;
            }

            text.reflow(targetBox);
        }
    });

    var Title = ChartElement.extend({
        init: function(options) {
            var title = this;
            ChartElement.fn.init.call(title, options);

            title.append(
                new TextBox(title.options.text, deepExtend({}, title.options, {
                    vAlign: title.options.position
                }))
            );
        },

        options: {
            text: "",
            color: BLACK,
            position: TOP,
            align: CENTER,
            margin: getSpacing(5),
            padding: getSpacing(5)
        },

        reflow: function(targetBox) {
            var title = this;

            ChartElement.fn.reflow.call(title, targetBox);
            title.box.snapTo(targetBox, X);
        }
    });

    var Legend = ChartElement.extend({
        init: function(options) {
            var legend = this;

            ChartElement.fn.init.call(legend, options);

            legend.createLabels();
        },

        options: {
            position: RIGHT,
            items: [],
            labels: {},
            offsetX: 0,
            offsetY: 0,
            margin: getSpacing(10),
            padding: getSpacing(5),
            border: {
                color: BLACK,
                width: 0
            },
            background: "",
            zIndex: 1
        },

        createLabels: function() {
            var legend = this,
                items = legend.options.items,
                count = items.length,
                label,
                name,
                i;

            for (i = 0; i < count; i++) {
                name = items[i].name;
                    label = new Text(name, legend.options.labels);

                legend.append(label);
            }
        },

        reflow: function(targetBox) {
            var legend = this,
                options = legend.options,
                childrenCount = legend.children.length;

            if (childrenCount === 0) {
                legend.box = targetBox.clone();
                return;
            }

            if (options.position == "custom") {
                legend.customLayout(targetBox);
                return;
            }

            if (options.position == TOP || options.position == BOTTOM) {
                legend.horizontalLayout(targetBox);
            } else {
                legend.verticalLayout(targetBox);
            }
        },

        getViewElements: function(view) {
            var legend = this,
                children = legend.children,
                options = legend.options,
                items = options.items,
                count = items.length,
                markerSize = legend.markerSize(),
                group = view.createGroup({ zIndex: options.zIndex }),
                border = options.border || {},
                padding,
                markerBox,
                labelBox,
                color,
                label,
                box,
                i;

            append(group.children, ChartElement.fn.getViewElements.call(legend, view));

            for (i = 0; i < count; i++) {
                color = items[i].color;
                label = children[i];
                markerBox = new Box2D();
                box = label.box;

                labelBox = labelBox ? labelBox.wrap(box) : box.clone();

                markerBox.x1 = box.x1 - markerSize * 2;
                markerBox.x2 = markerBox.x1 + markerSize;

                if (options.position == TOP || options.position == BOTTOM) {
                    markerBox.y1 = box.y1 + markerSize / 2;
                } else {
                    markerBox.y1 = box.y1 + (box.height() - markerSize) / 2;
                }

                markerBox.y2 = markerBox.y1 + markerSize;

                group.children.push(view.createRect(markerBox, { fill: color, stroke: color }));
            }

            if (children.length > 0) {
                padding = getSpacing(options.padding);
                padding.left += markerSize * 2;
                labelBox.pad(padding);
                group.children.unshift(view.createRect(labelBox, {
                    stroke: border.width ? border.color : "",
                    strokeWidth: border.width,
                    dashType: border.dashType,
                    fill: options.background })
                );
            }

            return [ group ];
        },

        verticalLayout: function(targetBox) {
            var legend = this,
                options = legend.options,
                children = legend.children,
                childrenCount = children.length,
                labelBox = children[0].box.clone(),
                offsetX,
                offsetY,
                margin = getSpacing(options.margin),
                markerSpace = legend.markerSize() * 2,
                label,
                i;

            // Position labels below each other
            for (i = 1; i < childrenCount; i++) {
                label = legend.children[i];
                label.box.alignTo(legend.children[i - 1].box, BOTTOM);
                labelBox.wrap(label.box);
            }

            // Vertical center is calculated relative to the container, not the parent!
            if (options.position == LEFT) {
                offsetX = targetBox.x1 + markerSpace + margin.left;
                offsetY = (targetBox.y2 - labelBox.height()) / 2;
                labelBox.x2 += markerSpace + margin.left + margin.right;
            } else {
                offsetX = targetBox.x2 - labelBox.width() - margin.right;
                offsetY = (targetBox.y2 - labelBox.height()) / 2;
                labelBox.translate(offsetX, offsetY);
                labelBox.x1 -= markerSpace + margin.left;
            }

            legend.translateChildren(offsetX + options.offsetX,
                    offsetY + options.offsetY);

            var labelBoxWidth = labelBox.width();
            labelBox.x1 = math.max(targetBox.x1, labelBox.x1);
            labelBox.x2 = labelBox.x1 + labelBoxWidth;

            labelBox.y1 = targetBox.y1;
            labelBox.y2 = targetBox.y2;

            legend.box = labelBox;
        },

        horizontalLayout: function(targetBox) {
            var legend = this,
                options = legend.options,
                children = legend.children,
                childrenCount = children.length,
                box = children[0].box.clone(),
                markerWidth = legend.markerSize() * 3,
                offsetX,
                offsetY,
                margin = getSpacing(options.margin),
                boxWidth = children[0].box.width() + markerWidth,
                plotAreaWidth = targetBox.width(),
                label,
                labelY = 0,
                i;

            // Position labels next to each other
            for (i = 1; i < childrenCount; i++) {
                label = children[i];

                boxWidth += label.box.width() + markerWidth;
                if (boxWidth > plotAreaWidth - markerWidth) {
                    label.box = new Box2D(box.x1, box.y2,
                        box.x1 + label.box.width(), box.y2 + label.box.height());
                    boxWidth = label.box.width() + markerWidth;
                    labelY = label.box.y1;
                } else {
                    label.box.alignTo(children[i - 1].box, RIGHT);
                    label.box.y2 = labelY + label.box.height();
                    label.box.y1 = labelY;
                    label.box.translate(markerWidth, 0);
                }
                box.wrap(label.box);
            }

            offsetX = (targetBox.width() - box.width() + markerWidth) / 2;
            if (options.position === TOP) {
                offsetY = targetBox.y1 + margin.top;
                box.y2 = targetBox.y1 + box.height() + margin.top + margin.bottom;
                box.y1 = targetBox.y1;
            } else {
                offsetY = targetBox.y2 - box.height() - margin.bottom;
                box.y1 = targetBox.y2 - box.height() - margin.top - margin.bottom;
                box.y2 = targetBox.y2;
            }

            legend.translateChildren(offsetX + options.offsetX,
                    offsetY + options.offsetY);

            box.x1 = targetBox.x1;
            box.x2 = targetBox.x2;

            legend.box = box;
        },

        customLayout: function (targetBox) {
            var legend = this,
                options = legend.options,
                children = legend.children,
                childrenCount = children.length,
                labelBox = children[0].box.clone(),
                markerWidth = legend.markerSize() * 2,
                i;

            // Position labels next to each other
            for (i = 1; i < childrenCount; i++) {
                labelBox = legend.children[i].box;
                labelBox.alignTo(legend.children[i - 1].box, BOTTOM);
                labelBox.wrap(labelBox);
            }

            legend.translateChildren(options.offsetX + markerWidth, options.offsetY);

            legend.box = targetBox;
        },

        markerSize: function() {
            var legend = this,
                children = legend.children;

            if (children.length > 0) {
                return children[0].box.height() / 2;
            } else {
                return 0;
            }
        }
    });

    var Axis = ChartElement.extend({
        init: function(options) {
            var axis = this;

            ChartElement.fn.init.call(axis, options);

            if (!axis.options.visible) {
                axis.options = deepExtend({}, axis.options, {
                    labels: {
                        visible: false
                    },
                    line: {
                        visible: false
                    },
                    margin: 0,
                    majorTickSize: 0,
                    minorTickSize: 0
                });
            }

            axis.createLabels();
            axis.createTitle();
        },

        options: {
            labels: {
                visible: true,
                rotation: 0,
                mirror: false,
                step: 1
            },
            line: {
                width: 1,
                color: BLACK,
                visible: true
            },
            title: {
                visible: true,
                position: CENTER
            },
            majorTickType: OUTSIDE,
            majorTickSize: 4,
            minorTickType: NONE,
            minorTickSize: 3,
            axisCrossingValue: 0,
            minorGridLines: {
                visible: false,
                width: 1,
                color: BLACK
            },
            // TODO: Move to line or labels options
            margin: 5,
            visible: true
        },

        createLabels: function() {
            var axis = this,
                options = axis.options,
                align = options.isVertical ? RIGHT : CENTER,
                labelOptions = deepExtend({ }, options.labels, {
                    align: align, zIndex: options.zIndex
                }),
                step = labelOptions.step;

            axis.labels = [];
            if (labelOptions.visible) {
                var labelsCount = axis.getLabelsCount(),
                    labelText,
                    label,
                    i;

                for (i = 0; i < labelsCount; i += step) {
                    labelText = axis.getLabelText(i);

                    if (labelOptions.template) {
                        labelTemplate = baseTemplate(labelOptions.template);
                        labelText = labelTemplate({ value: labelText });
                    }

                    label = new TextBox(labelText, labelOptions);
                    axis.append(label);
                    axis.labels.push(label);
                }
            }
        },

        getLabelsCount: function() {
        },

        getLabelText: function(index) {
        },

        lineBox: function() {
            var axis = this,
                options = axis.options,
                box = axis.box,
                isVertical = options.isVertical,
                mirror = options.labels.mirror,
                axisX = mirror ? box.x1 : box.x2,
                axisY = mirror ? box.y2 : box.y1;

            if (isVertical) {
                return new Box2D(axisX, box.y1, axisX, box.y2);
            }

            return new Box2D(box.x1, axisY, box.x2, axisY);
        },

        createTitle: function() {
            var axis = this,
                options = axis.options,
                titleOptions = deepExtend({
                    rotation: options.isVertical ? -90 : 0,
                    text: "",
                    zIndex: 1
                }, options.title),
                title;

            if (titleOptions.visible && titleOptions.text) {
                title = new TextBox(titleOptions.text, titleOptions);
                axis.append(title);
                axis.title = title;
            }
        },

        renderTicks: function(view) {
            var axis = this,
                options = axis.options,
                mirror = options.labels.mirror,
                lineBox = axis.lineBox(),
                majorTicks = axis.getMajorTickPositions(),
                ticks = [];

            if (options.majorTickType.toLowerCase() === OUTSIDE) {
                ticks = ticks.concat(map(majorTicks, function(pos) {
                    return {
                        pos: pos,
                        size: options.majorTickSize,
                        width: options.line.width,
                        color: options.line.color
                    };
                }));
            }

            if (options.minorTickType.toLowerCase() === OUTSIDE) {
                ticks = ticks.concat(map(axis.getMinorTickPositions(), function(pos) {
                    if (options.majorTickType.toLowerCase() !== NONE) {
                        if (!inArray(pos, majorTicks)) {
                            return {
                                pos: pos,
                                size: options.minorTickSize,
                                width: options.line.width,
                                color: options.line.color
                            };
                        }
                    } else {
                        return {
                            pos: pos,
                            size: options.minorTickSize,
                            width: options.line.width,
                            color: options.line.color
                        };
                    }
                }));
            }

            return map(ticks, function(tick) {
                var tickX = mirror ? lineBox.x2 : lineBox.x2 - tick.size,
                    tickY = mirror ? lineBox.y1 - tick.size : lineBox.y1;

                if (options.isVertical) {
                    return view.createLine(
                        tickX, tick.pos, tickX + tick.size, tick.pos,
                        {
                            strokeWidth: tick.width,
                            stroke: tick.color
                        }
                    );
                } else {
                    return view.createLine(
                        tick.pos, tickY, tick.pos, tickY + tick.size,
                        {
                            strokeWidth: tick.width,
                            stroke: tick.color
                        }
                    );
                }
            });
        },

        getActualTickSize: function () {
            var axis = this,
                options = axis.options,
                tickSize = 0;

            if (options.majorTickType != NONE && options.minorTickType != NONE ) {
                tickSize = math.max(options.majorTickSize, options.minorTickSize);
            } else if (options.majorTickType != NONE) {
                tickSize = options.majorTickSize;
            } else if (options.minorTickType != NONE) {
                tickSize = options.minorTickSize;
            }

            return tickSize;
        },

        renderPlotBands: function(view) {
            var axis = this,
                options = axis.options,
                plotBands = options.plotBands || [],
                isVertical = options.isVertical,
                result = [],
                plotArea = axis.parent,
                slotX,
                slotY,
                from,
                to;

            if (plotBands.length) {
                result = map(plotBands, function(item) {
                    from = defined(item.from) ? item.from : MIN_VALUE;
                    to = defined(item.to) ? item.to : MAX_VALUE;
                    item.from = math.min(from, to);
                    item.to = math.max(from, to);
                    slotX = isVertical ? plotArea.axisX.lineBox()  : plotArea.axisX.getSlot(item.from, item.to);
                    slotY = isVertical ? plotArea.axisY.getSlot(item.from, item.to) : plotArea.axisY.lineBox();
                    return view.createRect(
                            new Box2D(slotX.x1, slotY.y1, slotX.x2, slotY.y2),
                            { fill: item.color, fillOpacity: item.opacity, zIndex: -1 });
                });
            }

            return result;
        },

        reflowAxis: function(box, position) {
            var axis = this,
                options = axis.options,
                isVertical = options.isVertical,
                labels = axis.labels,
                count = labels.length,
                space = axis.getActualTickSize() + options.margin,
                maxLabelHeight = 0,
                maxLabelWidth = 0,
                title = axis.title,
                label,
                i;

            for (i = 0; i < count; i++) {
                label = labels[i];
                maxLabelHeight = math.max(maxLabelHeight, label.box.height());
                maxLabelWidth = math.max(maxLabelWidth, label.box.width());
            }

            if (title) {
                if (isVertical) {
                    maxLabelWidth += title.box.width()
                } else {
                    maxLabelHeight += title.box.height();
                }
            }

            if (isVertical) {
                axis.box = new Box2D(
                    box.x1, box.y1,
                    box.x1 + maxLabelWidth + space, box.y2
                );
            } else {
                axis.box = new Box2D(
                    box.x1, box.y1,
                    box.x2, box.y1 + maxLabelHeight + space
                );
            }

            axis.arrangeTitle();
            axis.arrangeLabels(maxLabelWidth, maxLabelHeight, position);
        },

        arrangeLabels: function(maxLabelWidth, maxLabelHeight, position) {
            var axis = this,
                options = axis.options,
                labelStep = options.labels.step,
                labels = axis.labels,
                isVertical = options.isVertical,
                lineBox = axis.lineBox(),
                mirror = options.labels.mirror,
                tickPositions = axis.getMajorTickPositions(),
                tickSize = axis.getActualTickSize(),
                labelOffset = axis.getActualTickSize() + options.margin,
                labelBox,
                labelY,
                i;

            for (i = 0; i < labels.length; i++) {
                var label = labels[i],
                    tickIx = labelStep * i,
                    labelSize = isVertical ? label.box.height() : label.box.width(),
                    labelPos = tickPositions[tickIx] - (labelSize / 2),
                    firstTickPosition,
                    nextTickPosition,
                    middle,
                    labelX;

                if (isVertical) {
                    if (position == ON_MINOR_TICKS) {
                        firstTickPosition = tickPositions[tickIx];
                        nextTickPosition = tickPositions[tickIx + 1];

                        middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;
                        labelPos = middle - (labelSize / 2);
                    }

                    labelX = lineBox.x2;

                    if (mirror) {
                        labelX += labelOffset;
                    } else {
                        labelX -= labelOffset + label.box.width();
                    }

                    labelBox = label.box.move(labelX, labelPos);
                } else {
                    if (position == ON_MINOR_TICKS) {
                        firstTickPosition = tickPositions[tickIx];
                        nextTickPosition = tickPositions[tickIx + 1];
                    } else {
                        firstTickPosition = labelPos;
                        nextTickPosition = labelPos + labelSize;
                    }

                    labelY = lineBox.y1;

                    if (mirror) {
                        labelY -= labelOffset + label.box.height();
                    } else {
                        labelY += labelOffset;
                    }

                    labelBox = new Box2D(firstTickPosition, labelY,
                                         nextTickPosition, labelY + label.box.height());
                }

                label.reflow(labelBox);
            }
        },

        arrangeTitle: function() {
            var axis = this,
                options = axis.options,
                mirror = options.labels.mirror,
                isVertical = options.isVertical,
                title = axis.title;

            if (title) {
                if (isVertical) {
                    title.options.align = mirror ? RIGHT : LEFT;
                    title.options.vAlign = title.options.position;
                } else {
                    title.options.align = title.options.position;
                    title.options.vAlign = mirror ? TOP : BOTTOM;
                }

                title.reflow(axis.box);
            }
        }
    });

    var NumericAxis = Axis.extend({
        init: function(seriesMin, seriesMax, options) {
            var axis = this,
                defaultOptions = axis.initDefaults(seriesMin, seriesMax, options),
                labelTemplate,
                i;

            Axis.fn.init.call(axis, defaultOptions);
        },

        options: {
            min: 0,
            max: 1,
            isVertical: true,
            majorGridLines: {
                visible: true,
                width: 1,
                color: BLACK
            },
            zIndex: 1
        },

        initDefaults: function(seriesMin, seriesMax, options) {
            var axis = this,
                autoMin = axis.autoAxisMin(seriesMin, seriesMax),
                autoMax = axis.autoAxisMax(seriesMin, seriesMax),
                autoMajorUnit = axis.autoMajorUnit(autoMin, autoMax),
                autoOptions = {
                    majorUnit: autoMajorUnit
                },
                userSetLimits;

            if (autoMin < 0) {
                autoMin -= autoMajorUnit;
            }

            if (autoMax > 0) {
                autoMax += autoMajorUnit;
            }

            autoOptions.min = floor(autoMin, autoMajorUnit);
            autoOptions.max = ceil(autoMax, autoMajorUnit);

            if (options) {
                userSetLimits = defined(options.min) || defined(options.max);
                if (userSetLimits) {
                    if (options.min === options.max) {
                        if (options.min > 0) {
                            options.min = 0;
                        } else {
                            options.max = 1;
                        }
                    }
                }

                if (options.majorUnit) {
                    autoOptions.min = floor(autoOptions.min, options.majorUnit);
                    autoOptions.max = ceil(autoOptions.max, options.majorUnit);
                } else if (userSetLimits) {
                    options = deepExtend(autoOptions, options);

                    // Determine an auto major unit after min/max have been set
                    autoOptions.majorUnit = axis.autoMajorUnit(options.min, options.max);
                }
            }

            return deepExtend(autoOptions, options);
        },

        range: function() {
            var options = this.options;
            return { min: options.min, max: options.max };
        },

        reflow: function(targetBox) {
            this.reflowAxis(targetBox);
        },

        getViewElements: function(view) {
            var axis = this,
                options = axis.options,
                line = options.line,
                childElements = ChartElement.fn.getViewElements.call(axis, view),
                lineBox = axis.lineBox(),
                lineOptions;

            if (line.width > 0 && line.visible) {
                lineOptions = {
                    strokeWidth: line.width,
                    stroke: line.color,
                    dashType: line.dashType,
                    zIndex: options.zIndex
                };
                if (options.isVertical) {
                    childElements.push(view.createLine(
                        lineBox.x1, lineBox.y1,
                        lineBox.x1, lineBox.y2,
                        lineOptions));
                } else {
                    childElements.push(view.createLine(
                        lineBox.x1, lineBox.y1,
                        lineBox.x2, lineBox.y1,
                        lineOptions));
                }

                append(childElements, axis.renderTicks(view));
                append(childElements, axis.renderPlotBands(view));
            }

            return childElements;
        },

        autoMajorUnit: function (min, max) {
            var diff = max - min;

            if (diff == 0) {
                if (max == 0) {
                    return 0.1;
                }

                diff = math.abs(max);
            }

            var scale = math.pow(10, math.floor(math.log(diff) / math.log(10))),
                relativeValue = round((diff / scale), DEFAULT_PRECISION),
                scaleMultiplier = 1;

            if (relativeValue < 1.904762) {
                scaleMultiplier = 0.2;
            } else if (relativeValue < 4.761904) {
                scaleMultiplier = 0.5;
            } else if (relativeValue < 9.523809) {
                scaleMultiplier = 1;
            } else {
                scaleMultiplier = 2;
            }

            return round(scale * scaleMultiplier, DEFAULT_PRECISION);
        },

        autoAxisMax: function(min, max) {
            if (min == 0 && max == 0) {
                return 1;
            }

            var axisMax;
            if (min <= 0 && max <= 0) {
                max = min == max ? 0 : max;

                var diff = math.abs((max - min) / max);
                if(diff > ZERO_THRESHOLD) {
                    return 0;
                }

                axisMax = max - ((min - max) / 2);
            } else {
                min = min == max ? 0 : min;
                axisMax = max;
            }

            return axisMax;
        },

        autoAxisMin: function(min, max) {
            if (min == 0 && max == 0) {
                return 0;
            }

            var axisMin;
            if (min >= 0 && max >= 0) {
                min = min == max ? 0 : min;

                var diff = (max - min) / max;
                if(diff > ZERO_THRESHOLD) {
                    return 0;
                }

                axisMin = min - ((max - min) / 2);
            } else {
                max = min == max ? 0 : max;
                axisMin = min;
            }

            return axisMin;
        },

        getDivisions: function(stepValue) {
            var options = this.options,
                range = options.max - options.min;

            return math.floor(round(range / stepValue, COORD_PRECISION)) + 1;
        },

        getTickPositions: function(stepValue) {
            var axis = this,
                options = axis.options,
                isVertical = options.isVertical,
                lineBox = axis.lineBox(),
                lineSize = isVertical ? lineBox.height() : lineBox.width(),
                range = options.max - options.min,
                scale = lineSize / range,
                step = stepValue * scale,
                divisions = axis.getDivisions(stepValue),
                pos = lineBox[isVertical ? "y2" : "x1"],
                multiplier = isVertical ? -1 : 1,
                positions = [],
                i;

            for (i = 0; i < divisions; i++) {
                positions.push(round(pos, COORD_PRECISION));
                pos = pos + step * multiplier;
            }

            return positions;
        },

        getMajorTickPositions: function() {
            var axis = this;

            return axis.getTickPositions(axis.options.majorUnit);
        },

        getMinorTickPositions: function() {
            var axis = this;

            return axis.getTickPositions(axis.options.majorUnit / 5);
        },

        lineBox: function() {
            var axis = this,
                options = axis.options,
                isVertical = options.isVertical,
                labelSize = isVertical ? "height" : "width",
                labels = axis.labels,
                baseBox = Axis.fn.lineBox.call(axis),
                startMargin = 0,
                endMargin = 0;

            if (labels.length > 1) {
                startMargin = labels[0].box[labelSize]() / 2;
                endMargin = last(labels).box[labelSize]() / 2;
            }

            if (isVertical) {
               return new Box2D(baseBox.x1, baseBox.y1 + startMargin,
                 baseBox.x1, baseBox.y2 - endMargin);
            } else {
               return new Box2D(baseBox.x1 + startMargin, baseBox.y1,
                 baseBox.x2 - endMargin, baseBox.y1);
            }
        },

        getSlot: function(a, b) {
            var axis = this,
                options = axis.options,
                isVertical = options.isVertical,
                valueAxis = isVertical ? Y : X,
                lineBox = axis.lineBox(),
                lineStart = lineBox[valueAxis + 1],
                lineSize = isVertical ? lineBox.height() : lineBox.width(),
                scale = lineSize / (options.max - options.min),
                a = defined(a) ? a : options.axisCrossingValue,
                b = defined(b) ? b : options.axisCrossingValue,
                a = math.max(math.min(a, options.max), options.min),
                b = math.max(math.min(b, options.max), options.min),
                p1,
                p2,
                slotBox = new Box2D(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);

            if (isVertical) {
                p1 = lineStart + scale * (options.max - math.max(a, b));
                p2 = lineStart + scale * (options.max - math.min(a, b));
            } else {
                p1 = lineStart + scale * (math.min(a, b) - options.min);
                p2 = lineStart + scale * (math.max(a, b) - options.min);
            }

            slotBox[valueAxis + 1] = p1;
            slotBox[valueAxis + 2] = p2;

            return slotBox;
        },

        getLabelsCount: function() {
            return this.getDivisions(this.options.majorUnit);
        },

        getLabelText: function(index) {
            var options = this.options;
            return round(options.min + (index * options.majorUnit), DEFAULT_PRECISION);
        }
    });

    var CategoryAxis = Axis.extend({
        options: {
            categories: [],
            isVertical: false,
            majorGridLines: {
                visible: false,
                width: 1,
                color: BLACK
            },
            zIndex: 1
        },

        range: function() {
            return { min: 0, max: this.options.categories.length };
        },

        reflow: function(targetBox) {
            this.reflowAxis(targetBox, ON_MINOR_TICKS);
        },

        getViewElements: function(view) {
            var axis = this,
                options = axis.options,
                line = options.line,
                lineBox = axis.lineBox(),
                childElements = ChartElement.fn.getViewElements.call(axis, view),
                lineOptions;

            if (line.width > 0 && line.visible) {
                lineOptions = {
                    strokeWidth: line.width,
                    stroke: line.color,
                    dashType: line.dashType,
                    zIndex: line.zIndex
                };

                childElements.push(view.createLine(
                    lineBox.x1, lineBox.y1, lineBox.x2, lineBox.y2,
                    lineOptions));

                append(childElements, axis.renderTicks(view));
                append(childElements, axis.renderPlotBands(view));
            }

            return childElements;
        },

        getTickPositions: function(itemsCount) {
            var axis = this,
                options = axis.options,
                isVertical = options.isVertical,
                size = isVertical ? axis.box.height() : axis.box.width(),
                step = size / itemsCount,
                pos = isVertical ? axis.box.y1 : axis.box.x1,
                positions = [],
                i;

            for (i = 0; i < itemsCount; i++) {
                positions.push(round(pos, COORD_PRECISION));
                pos += step;
            }

            positions.push(isVertical ? axis.box.y2 : axis.box.x2);

            return positions;
        },

        getMajorTickPositions: function() {
            var axis = this;

            return axis.getTickPositions(axis.options.categories.length);
        },

        getMinorTickPositions: function() {
            var axis = this;

            return axis.getTickPositions(axis.options.categories.length * 2);
        },

        getSlot: function(from, to) {
            var axis = this,
                options = axis.options,
                isVertical = options.isVertical,
                childrenCount = math.max(1, options.categories.length),
                from = math.min(math.max(0, from), childrenCount),
                to = defined(to) ? to : from,
                to = math.max(math.min(childrenCount, to), from),
                lineBox = axis.lineBox(),
                size = isVertical ? lineBox.height() : lineBox.width(),
                startPos = isVertical ? lineBox.y1 : lineBox.x1,
                step = size / childrenCount,
                p1 = startPos + (from * step),
                p2 = p1 + step,
                length = to - from;

            if (length > 0 || (from == to && childrenCount == from)) {
                p2 = p1 + (length * step);
            }

            return isVertical ?
                   new Box2D(lineBox.x2, p1, lineBox.x2, p2) :
                   new Box2D(p1, lineBox.y1, p2, lineBox.y1);
        },

        getLabelsCount: function() {
            return this.options.categories.length;
        },

        getLabelText: function(index) {
            var options = this.options;
            return defined(options.categories[index]) ? options.categories[index] : "";
        }
    });

    var ClusterLayout = ChartElement.extend({
        init: function(options) {
            var cluster = this;
            ChartElement.fn.init.call(cluster, options);
        },

        options: {
            isVertical: false,
            gap: 0,
            spacing: 0
        },

        reflow: function(box) {
            var cluster = this,
                options = cluster.options,
                isVertical = options.isVertical,
                axis = isVertical ? Y : X,
                children = cluster.children,
                gap = options.gap,
                spacing = options.spacing,
                count = children.length,
                slots = count + gap + (spacing * (count - 1)),
                slotSize = (isVertical ? box.height() : box.width()) / slots,
                position = box[axis + 1] + slotSize * (gap / 2),
                childBox,
                i;

            for (i = 0; i < count; i++) {
                childBox = (children[i].box || box).clone();

                childBox[axis + 1] = position;
                childBox[axis + 2] = position + slotSize;

                children[i].reflow(childBox);
                if (i < count - 1) {
                    position += (slotSize * spacing);
                }

                position += slotSize;
            }
        }
    });

    var StackLayout = ChartElement.extend({
        init: function(options) {
            var stack = this;
            ChartElement.fn.init.call(stack, options);
        },

        options: {
            isVertical: true,
            isReversed: false
        },

        reflow: function(targetBox) {
            var stack = this,
                options = stack.options,
                isVertical = options.isVertical,
                positionAxis = isVertical ? X : Y,
                stackAxis = isVertical ? Y : X,
                stackBase = targetBox[stackAxis + 2],
                children = stack.children,
                box = stack.box = new Box2D(),
                childrenCount = children.length,
                stackDirection,
                i;

            if (options.isReversed) {
                stackDirection = isVertical ? BOTTOM : LEFT;
            } else {
                stackDirection = isVertical ? TOP : RIGHT;
            }

            for (i = 0; i < childrenCount; i++) {
                var currentChild = children[i],
                    childBox = currentChild.box.clone();

                childBox.snapTo(targetBox, positionAxis)
                if (currentChild.options) {
                    currentChild.options.stackBase = stackBase;
                }

                if (i == 0) {
                    box = stack.box = childBox.clone();
                } else {
                    childBox.alignTo(children[i - 1].box, stackDirection);
                }

                currentChild.reflow(childBox);

                box.wrap(childBox);
            }
        }
    });

    var Bar = ChartElement.extend({
        init: function(value, options) {
            var bar = this;

            bar.value = value;
            bar.options.id = uniqueId();

            ChartElement.fn.init.call(bar, options);
        },

        options: {
            color: WHITE,
            border: {
                width: 1
            },
            isVertical: true,
            overlay: {
                gradient: GLASS
            },
            aboveAxis: true,
            labels: {
                visible: false
            },
            animation: {
                type: BAR
            },
            opacity: 1
        },

        render: function() {
            var bar = this,
                value = bar.value,
                options = bar.options,
                labels = options.labels,
                labelText = value,
                labelTemplate;

            if (bar._rendered) {
                return;
            } else {
                bar._rendered = true;
            }

            if (labels.visible && value) {
                if (labels.template) {
                    labelTemplate = baseTemplate(labels.template);
                    labelText = labelTemplate({
                        dataItem: bar.dataItem,
                        category: bar.category,
                        value: bar.value,
                        series: bar.series
                    });
                }

                bar.append(
                    new BarLabel(labelText, deepExtend({
                            isVertical: options.isVertical,
                            id: uniqueId()},
                        options.labels)
                    )
                );
            }
        },

        reflow: function(targetBox) {
            this.render();

            var bar = this,
                options = bar.options,
                children = bar.children,
                label = children[0];

            bar.box = targetBox;

            if (label) {
                label.options.aboveAxis = options.aboveAxis;
                label.reflow(targetBox);
            }
        },

        getViewElements: function(view) {
            var bar = this,
                options = bar.options,
                isVertical = options.isVertical,
                normalAngle = isVertical ? 0 : 90,
                border = options.border.width > 0 ? {
                    stroke: bar.getBorderColor(),
                    strokeWidth: options.border.width,
                    dashType: options.border.dashType
                } : {},
                box = bar.box,
                rectStyle = deepExtend({
                    id: options.id,
                    fill: options.color,
                    normalAngle: normalAngle,
                    aboveAxis: options.aboveAxis,
                    fillOpacity: options.opacity,
                    strokeOpacity: options.opacity,
                    stackBase: options.stackBase,
                    animation: options.animation
                }, border),
                elements = [],
                label = bar.children[0];

            if (options.overlay) {
                rectStyle.overlay = deepExtend({rotation: normalAngle }, options.overlay);
            }

            elements.push(view.createRect(box, rectStyle));

            append(elements,
                ChartElement.fn.getViewElements.call(bar, view));

            bar.registerId(options.id);
            if (label) {
                bar.registerId(label.options.id);
            }

            return elements;
        },

        getOutlineElement: function(view, options){
            var bar = this,
                box = bar.box,
                outlineId = bar.options.id + OUTLINE_SUFFIX;

            bar.registerId(outlineId);
            options = deepExtend({}, options, { id: outlineId });

            return view.createRect(box, options);
        },

        getBorderColor: function() {
            var bar = this,
                options = bar.options,
                color = options.color,
                borderColor = options.border.color;

            if (!defined(borderColor)) {
                borderColor =
                    new Color(color).brightness(BAR_BORDER_BRIGHTNESS).toHex();
            }

            return borderColor;
        },

        tooltipAnchor: function(tooltipWidth, tooltipHeight) {
            var bar = this,
                options = bar.options,
                box = bar.box,
                isVertical = options.isVertical,
                aboveAxis = options.aboveAxis,
                x,
                y;

            if (isVertical) {
                x = box.x2 + TOOLTIP_OFFSET;
                y = aboveAxis ? box.y1 : box.y2 - tooltipHeight;
            } else {
                if (options.isStacked) {
                    x = box.x2 - tooltipWidth;
                    y = box.y1 - tooltipHeight - TOOLTIP_OFFSET;
                } else {
                    x = box.x2 + TOOLTIP_OFFSET;
                    y = box.y1;
                }
            }

            return new Point2D(x, y);
        },

        formatPointValue: function(format) {
            var point = this;

            return point.owner.formatPointValue(point.value, format);
        }
    });

    var CategoricalChart = ChartElement.extend({
        init: function(plotArea, options) {
            var chart = this;

            ChartElement.fn.init.call(chart, options);

            chart.plotArea = plotArea;

            // Value axis ranges grouped by axis name, e.g.:
            // primary: { min: 0, max: 1 }
            chart.valueAxisRanges = {};

            chart.points = [];
            chart.categoryPoints = [];
            chart.seriesPoints = [];

            chart.render();
        },

        options: {
            series: [],
            invertAxes: false,
            isStacked: false
        },

        render: function() {
            var chart = this;

            chart.traverseDataPoints(proxy(chart.addValue, chart));
        },

        addValue: function(value, category, categoryIx, series, seriesIx) {
            var chart = this,
                point,
                categoryPoints = chart.categoryPoints[categoryIx],
                seriesPoints = chart.seriesPoints[seriesIx];

            if (!categoryPoints) {
                chart.categoryPoints[categoryIx] = categoryPoints = [];
            }

            if (!seriesPoints) {
                chart.seriesPoints[seriesIx] = seriesPoints = [];
            }

            chart.updateRange(value, categoryIx, series);

            point = chart.createPoint(value, category, categoryIx, series, seriesIx);
            if (point) {
                point.category = category;
                point.series = series;
                point.seriesIx = seriesIx;
                point.owner = chart;
                point.dataItem = series.dataItems ?
                    series.dataItems[categoryIx] : { value: value };
            }

            chart.points.push(point);
            seriesPoints.push(point);
            categoryPoints.push(point);
        },

        updateRange: function(value, categoryIx, series) {
            var chart = this,
                axisName = series.axis || PRIMARY,
                axisRange = chart.valueAxisRanges[axisName];

            if (defined(value)) {
                axisRange = chart.valueAxisRanges[axisName] =
                    axisRange || { min: MAX_VALUE, max: MIN_VALUE };

                axisRange.min = math.min(axisRange.min, value);
                axisRange.max = math.max(axisRange.max, value);
            }
        },

        seriesValueAxis: function(series) {
            return this.plotArea.namedValueAxes[(series || {}).axis || PRIMARY];
        },

        reflow: function(targetBox) {
            var chart = this,
                options = chart.options,
                invertAxes = options.invertAxes,
                plotArea = chart.plotArea,
                pointIx = 0,
                categorySlots = chart.categorySlots = [],
                chartPoints = chart.points,
                categoryAxis = plotArea.categoryAxis,
                valueAxis,
                point;

            chart.traverseDataPoints(function(value, category, categoryIx, currentSeries) {
                valueAxis = chart.seriesValueAxis(currentSeries);
                point = chartPoints[pointIx++];
                if (point && point.plotValue) {
                    value = point.plotValue;
                }

                var categorySlot = categoryAxis.getSlot(categoryIx),
                    valueSlot = valueAxis.getSlot(value),
                    slotX = invertAxes ? valueSlot : categorySlot,
                    slotY = invertAxes ? categorySlot : valueSlot,
                    pointSlot = new Box2D(slotX.x1, slotY.y1, slotX.x2, slotY.y2),
                    aboveAxis = value >= valueAxis.options.axisCrossingValue;

                if (point) {
                    point.options.aboveAxis = aboveAxis;
                    point.reflow(pointSlot);
                }

                if (!categorySlots[categoryIx]) {
                    categorySlots[categoryIx] = categorySlot;
                }
            });

            chart.reflowCategories(categorySlots);

            chart.box = targetBox;
        },

        reflowCategories: function() { },

        traverseDataPoints: function(callback) {
            var chart = this,
            options = chart.options,
            series = options.series,
            categories = chart.plotArea.options.categoryAxis.categories || [],
            count = categoriesCount(series),
            categoryIx,
            seriesIx,
            value,
            currentCategory,
            currentSeries;

            for (categoryIx = 0; categoryIx < count; categoryIx++) {
                for (seriesIx = 0; seriesIx < series.length; seriesIx++) {
                    currentCategory = categories[categoryIx];
                    currentSeries = series[seriesIx];
                    value = currentSeries.data[categoryIx];
                    callback(value, currentCategory, categoryIx, currentSeries, seriesIx);
                }
            }
        },

        formatPointValue: function(value, tooltipFormat) {
            return format(tooltipFormat, value);
        }
    });

    var BarChart = CategoricalChart.extend({
        init: function(plotArea, options) {
            var chart = this;

            chart._categoryTotalsPos = [];
            chart._categoryTotalsNeg = [];

            CategoricalChart.fn.init.call(chart, plotArea, options);
        },

        render: function() {
            var chart = this;

            CategoricalChart.fn.render.apply(chart);
            chart.computeAxisRanges();
        },

        createPoint: function(value, category, categoryIx, series, seriesIx) {
            var barChart = this,
                options = barChart.options,
                children = barChart.children,
                isStacked = barChart.options.isStacked,
                labelOptions = deepExtend({}, series.labels);

            if (isStacked) {
                if (labelOptions.position == OUTSIDE_END) {
                    labelOptions.position = INSIDE_END;
                }
            }

            var bar = new Bar(value,
                deepExtend({}, {
                    isVertical: !options.invertAxes,
                    overlay: series.overlay,
                    labels: labelOptions,
                    isStacked: isStacked
                }, series));

            var cluster = children[categoryIx];
            if (!cluster) {
                cluster = new ClusterLayout({
                    isVertical: options.invertAxes,
                    gap: options.gap,
                    spacing: options.spacing
                });
                barChart.append(cluster);
            }

            if (isStacked) {
                var stackWrap = cluster.children[0],
                    positiveStack,
                    negativeStack;

                if (!stackWrap) {
                    stackWrap = new ChartElement();
                    cluster.append(stackWrap);

                    positiveStack = new StackLayout({
                        isVertical: !options.invertAxes
                    });
                    negativeStack = new StackLayout({
                        isVertical: !options.invertAxes,
                        isReversed: true
                    });
                    stackWrap.append(positiveStack, negativeStack);
                } else {
                    positiveStack = stackWrap.children[0];
                    negativeStack = stackWrap.children[1];
                }

                if (value > 0) {
                    positiveStack.append(bar);
                } else {
                    negativeStack.append(bar);
                }
            } else {
                cluster.append(bar);
            }

            return bar;
        },

        updateRange: function(value, categoryIx, series) {
            var chart = this,
                isStacked = chart.options.isStacked,
                totalsPos = chart._categoryTotalsPos,
                totalsNeg = chart._categoryTotalsNeg;

            if (defined(value)) {
                if (isStacked) {
                    incrementSlot(value > 0 ? totalsPos : totalsNeg, categoryIx, value);
                } else {
                    CategoricalChart.fn.updateRange.apply(chart, arguments);
                }
            }
        },

        computeAxisRanges: function() {
            var chart = this,
                isStacked = chart.options.isStacked,
                axisName;

            if (isStacked) {
                axisName = chart.options.series[0].axis || PRIMARY;
                chart.valueAxisRanges[axisName] = {
                    min: sparseArrayMin(chart._categoryTotalsNeg.concat(0)),
                    max: sparseArrayMax(chart._categoryTotalsPos.concat(0))
                };
            }
        },

        seriesValueAxis: function(series) {
            var chart = this,
                options = chart.options;

            return CategoricalChart.fn.seriesValueAxis.call(
                chart,
                options.isStacked ? chart.options.series[0] : series
            );
        },

        reflowCategories: function(categorySlots) {
            var chart = this,
                children = chart.children,
                childrenLength = children.length,
                i;

            for (i = 0; i < childrenLength; i++) {
                children[i].reflow(categorySlots[i]);
            }
        }
    });

    var ShapeElement = BoxElement.extend({
        init: function(options) {
            var marker = this;

            BoxElement.fn.init.call(marker, options);
        },

        options: {
            type: SQUARE,
            align: CENTER,
            vAlign: CENTER
        },

        getViewElements: function(view, renderOptions) {
            var marker = this,
                options = marker.options,
                type = options.type,
                box = marker.paddingBox,
                element = BoxElement.fn.getViewElements.call(marker, view, renderOptions)[0],
                halfWidth = box.width() / 2;

            if (!element) {
                return [];
            }

            if (type === TRIANGLE) {
                element = view.createPolyline([
                    new Point2D(box.x1 + halfWidth, box.y1),
                    new Point2D(box.x1, box.y2),
                    new Point2D(box.x2, box.y2)
                ], true, element.options);
            } else if (type === CIRCLE) {
                element = view.createCircle([
                    round(box.x1 + halfWidth, COORD_PRECISION),
                    round(box.y1 + box.height() / 2, COORD_PRECISION)
                ], halfWidth, element.options);
            }

            return [ element ];
        }
    });

    var LinePoint = ChartElement.extend({
        init: function(value, options) {
            var point = this;

            point.value = value;

            ViewElement.fn.init.call(point, options);
        },

        options: {
            aboveAxis: true,
            isVertical: true,
            markers: {
                visible: true,
                background: WHITE,
                size: LINE_MARKER_SIZE,
                type: CIRCLE,
                border: {
                    width: 2
                },
                opacity: 1
            },
            labels: {
                visible: false,
                position: ABOVE,
                margin: getSpacing(3),
                padding: getSpacing(4),
                animation: {
                    type: FADEIN,
                    delay: INITIAL_ANIMATION_DURATION
                }
            }
        },

        render: function() {
            var point = this,
                options = point.options,
                markers = options.markers,
                labels = options.labels,
                markerBackground = markers.background,
                markerBorder = deepExtend({}, markers.border),
                labelText = point.value;

            if (point._rendered) {
                return;
            } else {
                point._rendered = true;
            }

            if (!defined(markerBorder.color)) {
                markerBorder.color =
                    new Color(markerBackground).brightness(BAR_BORDER_BRIGHTNESS).toHex();
            }

            point.marker = new ShapeElement({
                id: uniqueId(),
                visible: markers.visible,
                type: markers.type,
                width: markers.size,
                height: markers.size,
                background: markerBackground,
                border: markerBorder,
                opacity: markers.opacity
            });

            point.append(point.marker);

            if (labels.visible) {
                if (labels.template) {
                    var labelTemplate = baseTemplate(labels.template);
                    labelText = labelTemplate({
                        dataItem: point.dataItem,
                        category: point.category,
                        value: point.value,
                        series: point.series
                    });
                } else if (labels.format) {
                    labelText = point.formatPointValue(labels.format);
                }
                point.label = new TextBox(labelText,
                    deepExtend({
                        id: uniqueId(),
                        align: CENTER,
                        vAlign: CENTER,
                        margin: {
                            left: 5,
                            right: 5
                        }
                    }, labels, { format: "" })
                );
                point.append(point.label);
            }
        },

        markerBox: function() {
            return this.marker.box;
        },

        reflow: function(targetBox) {
            var point = this,
                options = point.options,
                isVertical = options.isVertical,
                aboveAxis = options.aboveAxis,
                childBox;

            point.render();

            point.box = targetBox;
            childBox = targetBox.clone();

            if (isVertical) {
                if (aboveAxis) {
                    childBox.y1 -= childBox.height();
                } else {
                    childBox.y2 += childBox.height();
                }
            } else {
                if (aboveAxis) {
                    childBox.x1 += childBox.width();
                } else {
                    childBox.x2 -= childBox.width();
                }
            }

            point.marker.reflow(childBox);
            point.reflowLabel(childBox);
        },

        reflowLabel: function(box) {
            var point = this,
                options = point.options,
                marker = point.marker,
                label = point.label,
                edge = options.labels.position;

            if (label) {
                edge = edge === ABOVE ? TOP : edge;
                edge = edge === BELOW ? BOTTOM : edge;

                label.reflow(box);
                label.box.alignTo(marker.box, edge);
                label.reflow(label.box);
            }
        },

        getViewElements: function(view) {
            var element = this,
                marker = element.marker,
                label = element.label;

            element.registerId(marker.options.id);

            if (label) {
                element.registerId(label.options.id);
            }

            return ChartElement.fn.getViewElements.call(element, view);
        },

        getOutlineElement: function(view, options) {
            var element = this,
                marker = element.marker,
                outlineId = element.marker.options.id + OUTLINE_SUFFIX;

            element.registerId(outlineId);
            options = deepExtend({}, options, { id: outlineId });

            return marker.getViewElements(view, deepExtend(options, {
                fill: marker.options.border.color,
                fillOpacity: 1,
                strokeOpacity: 0
            }))[0];
        },

        tooltipAnchor: function(tooltipWidth, tooltipHeight) {
            var point = this,
                markerBox = point.marker.box,
                aboveAxis = point.options.aboveAxis;

            return new Point2D(
                markerBox.x2 + TOOLTIP_OFFSET,
                aboveAxis ? markerBox.y1 - tooltipHeight : markerBox.y2
            );
        },

        formatPointValue: function(format) {
            var point = this;

            return point.owner.formatPointValue(point.value, format);
        }
    });

    var LineChartMixin = {
        splitSegments: function(view) {
            var chart = this,
                options = chart.options,
                series = options.series,
                seriesPoints = chart.seriesPoints,
                currentSeries,
                seriesIx,
                seriesCount = seriesPoints.length,
                currentSeriesPoints,
                linePoints,
                point,
                pointIx,
                pointCount,
                lines = [];

            for (seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
                currentSeriesPoints = seriesPoints[seriesIx];
                pointCount = currentSeriesPoints.length;
                currentSeries = series[seriesIx];
                linePoints = [];

                for (pointIx = 0; pointIx < pointCount; pointIx++) {
                    point = currentSeriesPoints[pointIx];
                    if (point) {
                        pointCenter = point.markerBox().center();
                        linePoints.push(new Point2D(pointCenter.x, pointCenter.y));
                    } else if (currentSeries.missingValues !== INTERPOLATE) {
                        if (linePoints.length > 1) {
                            lines.push(
                                chart.createSegment(uniqueId(), view, linePoints, currentSeries, seriesIx));
                        }
                        linePoints = [];
                    }
                }

                if (linePoints.length > 1) {
                    lines.push(
                        chart.createSegment(uniqueId(), view, linePoints, currentSeries, seriesIx));
                }
            }

            return lines;
        },

        createSegment: function(lineId, view, points, series, seriesIx) {
            this.registerId(lineId, { seriesIx: seriesIx });
            return view.createPolyline(points, false, {
                id: lineId,
                stroke: series.color,
                strokeWidth: series.width,
                strokeOpacity: series.opacity,
                fill: "",
                dashType: series.dashType
            });
        },

        getNearestPoint: function(x, y, seriesIx) {
            var chart = this,
                invertAxes = chart.options.invertAxes,
                axis = invertAxes ? Y : X,
                pos = invertAxes ? y : x,
                points = chart.seriesPoints[seriesIx],
                nearestPointDistance = MAX_VALUE,
                pointsLength = points.length,
                currentPoint,
                pointBox,
                pointDistance,
                nearestPoint,
                i;

            for (i = 0; i < pointsLength; i++) {
                currentPoint = points[i];

                if (currentPoint && defined(currentPoint.value) && currentPoint.value !== null) {
                    pointBox = currentPoint.box;
                    pointDistance = math.abs(pointBox.center()[axis] - pos);

                    if (pointDistance < nearestPointDistance) {
                        nearestPoint = currentPoint;
                        nearestPointDistance = pointDistance;
                    }
                }
            }

            return nearestPoint;
        }
    };

    var LineChart = CategoricalChart.extend({
        init: function(plotArea, options) {
            var chart = this;

            chart._stackAxisRange = { min: MAX_VALUE, max: MIN_VALUE };
            chart._categoryTotals = [];

            CategoricalChart.fn.init.call(chart, plotArea, options);
        },

        render: function() {
            var chart = this;

            CategoricalChart.fn.render.apply(chart);
            chart.computeAxisRanges();
        },

        createPoint: function(value, category, categoryIx, series, seriesIx) {
            var chart = this,
                options = chart.options,
                isStacked = options.isStacked,
                categoryPoints = chart.categoryPoints[categoryIx],
                stackPoint,
                plotValue = 0;

            if (!defined(value) || value === null) {
                if (isStacked || series.missingValues === ZERO) {
                    value = 0;
                } else {
                    return null;
                }
            }

            var point = new LinePoint(value,
                deepExtend({
                    isVertical: !options.invertAxes,
                    markers: {
                        border: {
                            color: series.color
                        }
                    }
                }, series)
            );

            if (isStacked) {
                stackPoint = last(categoryPoints);
                if (stackPoint) {
                    plotValue = stackPoint.plotValue;
                }

                point.plotValue = value + plotValue;
            }

            chart.append(point);

            return point;
        },

        updateRange: function(value, categoryIx, series) {
            var chart = this,
                isStacked = chart.options.isStacked,
                stackAxisRange = chart._stackAxisRange,
                totals = chart._categoryTotals;

            if (defined(value)) {
                if (isStacked) {
                    incrementSlot(totals, categoryIx, value);

                    stackAxisRange.min = math.min(stackAxisRange.min, sparseArrayMin(totals));
                    stackAxisRange.max = math.max(stackAxisRange.max, sparseArrayMax(totals));
                } else {
                    CategoricalChart.fn.updateRange.apply(chart, arguments);
                }
            }
        },

        computeAxisRanges: function() {
            var chart = this,
                isStacked = chart.options.isStacked,
                axisName,
                totals = chart._categoryTotals;

            if (isStacked) {
                axisName = chart.options.series[0].axis || PRIMARY;
                chart.valueAxisRanges[axisName] = chart._stackAxisRange;
            }
        },

        getViewElements: function(view) {
            var chart = this,
                elements = CategoricalChart.fn.getViewElements.call(chart, view),
                group = view.createGroup({
                    animation: {
                        type: CLIP
                    }
                }),
                lines = chart.splitSegments(view);


            group.children = lines.concat(elements);
            return [group];
        }
    });
    deepExtend(LineChart.fn, LineChartMixin);

    var AreaChart = LineChart.extend({
        splitSegments: function(view) {
            var chart = this,
                options = chart.options,
                plotArea = chart.plotArea,
                invertAxes = chart.options.invertAxes,
                originalLines = LineChart.fn.splitSegments.call(chart, view),
                lines = [],
                axisLineBox = plotArea.categoryAxis.lineBox(),
                end = invertAxes ? axisLineBox.x1 : axisLineBox.y1,
                originalLinePoints,
                linesCount = originalLines.length,
                seriesIx = 0,
                linePoints,
                firstPoint,
                lastPoint,
                lineOptions,
                i;

            for (i = 0; i < linesCount; i++) {
                line = originalLines[i].clone();
                linePoints = line.points;
                lineOptions = line.options;
                seriesIx = lineOptions.seriesIx;

                if (lineOptions.stack && seriesIx != 0) {
                    if (seriesIx > 0) {
                        originalLinePoints = originalLines[i - 1].clone().points.reverse();
                        line.points = linePoints.concat(originalLinePoints);
                    }
                } else {
                    if (linePoints.length > 1) {
                        firstPoint = linePoints[0];
                        lastPoint = last(linePoints);

                        if (invertAxes) {
                            linePoints.unshift(new Point2D(end, firstPoint.y));
                            linePoints.push(new Point2D(end, lastPoint.y));
                        } else {
                            linePoints.unshift(new Point2D(firstPoint.x, end));
                            linePoints.push(new Point2D(lastPoint.x, end));
                        }
                    }
                }
                lines.push(line);
            }

            return lines;
        },

        createSegment: function(lineId, view, points, series, seriesIx) {
            var line = deepExtend({}, {
                    color: series.color,
                    opacity: series.opacity
                }, series.line);
            this.registerId(lineId, { seriesIx: seriesIx });

            return view.createPolyline(points, true, {
                id: lineId,
                stroke: line.color,
                strokeWidth: line.width,
                strokeOpacity: line.opacity,
                dashType: line.dashType,
                fillOpacity: series.opacity,
                fill: series.color,
                seriesIx: seriesIx,
                stack: series.stack
            });
        }
    });

    var ScatterChart = ChartElement.extend({
        init: function(plotArea, options) {
            var chart = this;

            ChartElement.fn.init.call(chart, options);

            chart.plotArea = plotArea;

            // X and Y axis ranges grouped by name, e.g.:
            // primary: { min: 0, max: 1 }
            chart.xAxisRanges = {};
            chart.yAxisRanges = {};

            chart.points = [];
            chart.seriesPoints = [];

            chart.render();
        },

        options: {
            series: [],
            tooltip: {
                format: "{0}, {1}"
            },
            labels: {
                format: "{0}, {1}"
            }
        },

        render: function() {
            var chart = this;

            chart.traverseDataPoints(proxy(chart.addValue, chart));
        },

        addValue: function(value, fields) {
            var chart = this,
                point,
                seriesIx = fields.seriesIx,
                seriesPoints = chart.seriesPoints[seriesIx];

            chart.updateRange(value, fields.series);

            point = chart.createPoint(value, fields.series, seriesIx);
            if (point) {
                extend(point, fields);
            }

            chart.points.push(point);
            seriesPoints.push(point);
        },

        updateRange: function(value, series) {
            var chart = this,
                x = value.x,
                y = value.y,
                xAxisName = series.xAxis || PRIMARY,
                yAxisName = series.yAxis || PRIMARY,
                xAxisRange = chart.xAxisRanges[xAxisName],
                yAxisRange = chart.yAxisRanges[yAxisName];

            if (defined(x) && x !== null) {
                xAxisRange = chart.xAxisRanges[xAxisName] =
                    xAxisRange || { min: MAX_VALUE, max: MIN_VALUE };

                xAxisRange.min = math.min(xAxisRange.min, x);
                xAxisRange.max = math.max(xAxisRange.max, x);
            }

            if (defined(y) && y !== null) {
                yAxisRange = chart.yAxisRanges[yAxisName] =
                    yAxisRange || { min: MAX_VALUE, max: MIN_VALUE };

                yAxisRange.min = math.min(yAxisRange.min, y);
                yAxisRange.max = math.max(yAxisRange.max, y);
            }
        },

        createPoint: function(value, series, seriesIx) {
            var chart = this,
                point,
                x = value.x,
                y = value.y;

            if (!defined(x) || x === null || !defined(y) || y === null) {
                return null;
            }

            point = new LinePoint(value,
                deepExtend({
                    markers: {
                        border: {
                            color: series.color
                        },
                        opacity: series.opacity
                    },
                    tooltip: {
                        format: chart.options.tooltip.format
                    },
                    labels: {
                        format: chart.options.labels.format
                    }
                }, series)
            );

            chart.append(point);

            return point;
        },

        seriesAxes: function(series) {
            var plotArea = this.plotArea,
                xAxis = series.xAxis || PRIMARY,
                yAxis = series.yAxis || PRIMARY;

            return {
                x: plotArea.namedXAxes[xAxis],
                y: plotArea.namedYAxes[yAxis]
            };
        },

        reflow: function(targetBox) {
            var chart = this,
                plotArea = chart.plotArea,
                chartPoints = chart.points,
                pointIx = 0,
                point,
                seriesAxes;

            chart.traverseDataPoints(function(value, fields) {
                point = chartPoints[pointIx++];
                seriesAxes = chart.seriesAxes(fields.series);

                var slotX = seriesAxes.x.getSlot(value.x, value.x),
                    slotY = seriesAxes.y.getSlot(value.y, value.y),
                    pointSlot = new Box2D(slotX.x1, slotY.y1, slotX.x2, slotY.y2);

                if (point) {
                    point.reflow(pointSlot);
                }
            });

            chart.box = targetBox;
        },

        getViewElements: function(view) {
            var chart = this,
                elements = ChartElement.fn.getViewElements.call(chart, view),
                group = view.createGroup({
                    animation: {
                        type: CLIP
                    }
                });

            group.children = elements;
            return [group];
        },

        traverseDataPoints: function(callback) {
            var chart = this,
                options = chart.options,
                series = options.series,
                seriesPoints = chart.seriesPoints,
                pointIx = 0,
                seriesIx,
                currentSeries,
                currentSeriesPoints,
                dataItems,
                value,
                pointData;

            for (seriesIx = 0; seriesIx < series.length; seriesIx++) {
                currentSeries = series[seriesIx];

                currentSeriesPoints = seriesPoints[seriesIx];
                if (!currentSeriesPoints) {
                    seriesPoints[seriesIx] = [];
                }

                for (pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
                    pointData = currentSeries.data[pointIx] || [];
                    dataItems = currentSeries.dataItems;
                    value = { x: pointData[0], y: pointData[1] };

                    callback(value, {
                        pointIx: pointIx,
                        series: currentSeries,
                        seriesIx: seriesIx,
                        dataItem: dataItems ? dataItems[pointIx] : value,
                        owner: chart
                    });
                }
            }
        },

        formatPointValue: function(value, tooltipFormat) {
            return format(tooltipFormat, value.x, value.y);
        }
    });

    var ScatterLineChart = ScatterChart.extend({
        getViewElements: function(view) {
            var chart = this,
                elements = ScatterChart.fn.getViewElements.call(chart, view),
                group = view.createGroup({
                    animation: {
                        type: CLIP
                    }
                }),
                lines = chart.splitSegments(view);

            group.children = lines.concat(elements);
            return [group];
        }
    });
    deepExtend(ScatterLineChart.fn, LineChartMixin);

    var PieSegment = ChartElement.extend({
        init: function(value, sector, options) {
            var segment = this;

            segment.value = value;
            segment.sector = sector;

            ChartElement.fn.init.call(segment, options);
        },

        options: {
            color: WHITE,
            overlay: {
                gradient: ROUNDED_BEVEL
            },
            border: {
                width: 0.5
            },
            labels: {
                visible: false,
                distance: 35,
                font: DEFAULT_FONT,
                margin: getSpacing(0.5),
                align: CIRCLE,
                zIndex: 1,
                position: OUTSIDE_END
            },
            animation: {
                type: PIE
            },
            highlight: {
                visible: true,
                border: {
                    width: 1
                }
            }
        },

        render: function() {
            var segment = this,
                options = segment.options,
                labels = options.labels,
                labelText = segment.value,
                labelTemplate;

            if (segment._rendered) {
                return;
            } else {
                segment._rendered = true;
            }

            if (labels.template) {
                labelTemplate = baseTemplate(labels.template);
                labelText = labelTemplate({
                    dataItem: segment.dataItem,
                    category: segment.category,
                    value: segment.value,
                    series: segment.series,
                    percentage: segment.percentage
                });
            }

            if (labels.visible) {
                segment.label = new TextBox(labelText, deepExtend({}, labels, {
                        id: uniqueId(),
                        align: CENTER,
                        vAlign: "",
                        animation: {
                            type: FADEIN,
                            delay: segment.categoryIx * PIE_SECTOR_ANIM_DELAY
                        }
                    }));

                segment.append(segment.label);
                segment.registerId(segment.label.options.id);
            }
        },

        reflow: function(targetBox) {
            var segment = this;

            segment.render();

            segment.box = targetBox;
            targetBox.clone();

            segment.reflowLabel();
        },

        reflowLabel: function() {
            var segment = this,
                sector = segment.sector.clone(),
                options = segment.options,
                label = segment.label,
                labelsOptions = options.labels,
                labelsDistance = labelsOptions.distance,
                lp,
                x1,
                angle = sector.middle(),
                labelWidth,
                labelHeight;

            if (label) {
                labelHeight = label.box.height();
                labelWidth = label.box.width();
                if (labelsOptions.position == CENTER) {
                    sector.r = math.abs((sector.r - labelHeight) / 2) + labelHeight;
                    lp = sector.point(angle);
                    label.reflow(new Box2D(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
                } else if (labelsOptions.position == INSIDE_END) {
                    sector.r = sector.r - labelHeight / 2;
                    lp = sector.point(angle);
                    label.reflow(new Box2D(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
                } else {
                    lp = sector.clone().expand(labelsDistance).point(angle);
                    if (lp.x >= sector.c.x) {
                        x1 = lp.x + labelWidth;
                        label.orientation = RIGHT;
                    } else {
                        x1 = lp.x - labelWidth;
                        label.orientation = LEFT;
                    }
                    label.reflow(new Box2D(x1, lp.y - labelHeight, lp.x, lp.y));
                }
            }
        },

        getViewElements: function(view) {
            var segment = this,
                sector = segment.sector,
                options = segment.options,
                borderOptions = options.border || {},
                border = borderOptions.width > 0 ? {
                    stroke: borderOptions.color,
                    strokeWidth: borderOptions.width,
                    dashType: borderOptions.dashType
                } : {},
                elements = [],
                overlay = options.overlay;

            if (overlay) {
                overlay = deepExtend({}, options.overlay, {
                    r: sector.r,
                    cx: sector.c.x,
                    cy: sector.c.y
                })
            }

            if (segment.value !== 0) {
                elements.push(view.createSector(sector, deepExtend({
                    id: options.id,
                    fill: options.color,
                    overlay: overlay,
                    fillOpacity: options.opacity,
                    strokeOpacity: options.opacity,
                    animation: deepExtend(options.animation, {
                        delay: segment.categoryIx * PIE_SECTOR_ANIM_DELAY
                    })
                }, border)));
            }

            append(elements,
                ChartElement.fn.getViewElements.call(segment, view)
            );

            return elements;
        },

        getOutlineElement: function(view, options) {
            var segment = this,
                highlight = segment.options.highlight || {},
                border = highlight.border || {},
                outlineId = segment.options.id + OUTLINE_SUFFIX,
                element;

            segment.registerId(outlineId);
            options = deepExtend({}, options, { id: outlineId });

            if (segment.value !== 0) {
                element = view.createSector(segment.sector, deepExtend({}, options, {
                    fill: highlight.color,
                    fillOpacity: highlight.opacity,
                    strokeOpacity: border.opacity,
                    strokeWidth: border.width,
                    stroke: border.color
                }));
            }

            return element;
        },

        tooltipAnchor: function(tooltipWidth, tooltipHeight) {
            var w = tooltipWidth / 2,
                h = tooltipHeight / 2,
                r = math.sqrt((w * w) + (h * h)),
                sector = this.sector.clone().expand(r + TOOLTIP_OFFSET),
                tooltipCenter = sector.point(sector.middle());

            return new Point2D(tooltipCenter.x - w, tooltipCenter.y - h);
        },

        formatPointValue: function(format) {
            var point = this;

            return point.owner.formatPointValue(point.value, format);
        }
    });

    var PieChart = ChartElement.extend({
        init: function(plotArea, options) {
            var chart = this;

            ChartElement.fn.init.call(chart, options);

            chart.plotArea = plotArea;
            chart.segments = [];
            chart.seriesPoints = [];
            chart.render();
        },

        options: {
            startAngle: 90,
            padding: 60,
            connectors: {
                width: 1,
                color: "#939393",
                padding: 4
            }
        },

        render: function() {
            var chart = this;

            chart.traverseDataPoints(proxy(chart.addValue, chart));
        },

        traverseDataPoints: function(callback) {
            var chart = this,
                options = chart.options,
                colors = chart.plotArea.options.seriesColors || [],
                startAngle = options.startAngle,
                colorsCount = colors.length,
                series = options.series,
                dataItems,
                currentName,
                currentSeries,
                currentData,
                seriesIx,
                angle,
                data,
                anglePerValue,
                value,
                explode,
                total,
                i;

            for (seriesIx = 0; seriesIx < series.length; seriesIx++) {
                currentSeries = series[seriesIx];
                dataItems = currentSeries.dataItems;
                data = currentSeries.data;
                total = chart.pointsTotal(data)
                anglePerValue = 360 / total;

                for (i = 0; i < data.length; i++) {
                    currentData = chart.pointData(currentSeries, i);
                    value = currentData.value;
                    angle = round(value * anglePerValue, DEFAULT_PRECISION);
                    currentName = currentData.category;
                    explode = data.length != 1 && !!currentData.explode;
                    currentSeries.color = currentData.color ?
                        currentData.color : colors[i % colorsCount];

                    callback(value, new Sector(null, 0, startAngle, angle), {
                        owner: chart,
                        category: currentName,
                        categoryIx: i,
                        series: currentSeries,
                        seriesIx: seriesIx,
                        dataItem: dataItems ? dataItems[i] : { value: currentData },
                        percentage: value / total,
                        explode: explode,
                        currentData: currentData
                    });

                    startAngle += angle;
                }
            }
        },

        addValue: function(value, sector, fields) {
            var chart = this,
                segment;

            segment = new PieSegment(value, sector, fields.series);
            segment.options.id = uniqueId();
            extend(segment, fields);
            chart.append(segment);
            chart.segments.push(segment);
        },

        pointValue: function(point) {
            return defined(point.value) ? point.value : point;
        },

        pointData: function(series, index) {
            var chart = this,
                data = series.data[index];

            return {
                value: chart.pointValue(data),
                category: chart.pointGetter(series, index, "category"),
                color: chart.pointGetter(series, index, "color"),
                explode: chart.pointGetter(series, index, "explode")
            };
        },

        pointGetter: function(series, index, prop) {
            var valueField = series[prop + "Field"],
                data = series.data[index],
                value = data[prop];

            if (valueField && series.dataItems) {
                return getField(valueField, series.dataItems[index]);
            } else {
                return defined(value) ? value : "";
            }
        },

        pointsTotal: function(data) {
            var chart = this,
                length = data.length,
                sum = 0,
                i;

            for(i = 0; i < length; i++) {
                sum += chart.pointValue(data[i]);
            }

            return sum;
        },

        reflow: function(targetBox) {
            var chart = this,
                options = chart.options,
                box = targetBox.clone(),
                minWidth = math.min(box.width(), box.height()),
                space = 5,
                padding = options.padding > minWidth / 2 - space ? minWidth / 2 - space : options.padding,
                newBox = new Box2D(box.x1, box.y1,
                    box.x1 + minWidth, box.y1 + minWidth),
                newBoxCenter = newBox.center(),
                boxCenter = box.center(),
                segments = chart.segments,
                count = segments.length,
                leftSideLabels = [],
                rightSideLabels = [],
                label,
                segment,
                sector,
                i;

            newBox.translate(boxCenter.x - newBoxCenter.x, boxCenter.y - newBoxCenter.y);

            for (i = 0; i < count; i++) {
                segment = segments[i];

                sector = segment.sector;
                sector.r = minWidth / 2 - padding;
                sector.c = new Point2D(
                    sector.r + newBox.x1 + padding,
                    sector.r + newBox.y1 + padding
                );

                if (segment.explode) {
                    sector.c = sector.clone().radius(sector.r * 0.15).point(sector.middle());
                }

                segment.reflow(newBox);

                label = segment.label;
                if (label) {
                    if (label.options.position === OUTSIDE_END) {
                        if (label.orientation === RIGHT) {
                            rightSideLabels.push(label);
                        } else {
                            leftSideLabels.push(label);
                        }
                    }
                }
            }

            if (leftSideLabels.length > 0) {
                leftSideLabels.sort(chart.labelComparator(true));
                chart.leftLabelsReflow(leftSideLabels);
            }

            if (rightSideLabels.length > 0) {
                rightSideLabels.sort(chart.labelComparator(false));
                chart.rightLabelsReflow(rightSideLabels);
            }

            chart.box = newBox;
        },

        leftLabelsReflow: function(labels) {
            var chart = this,
                distances = chart.distanceBetweenLabels(labels);

            chart.distributeLabels(distances, labels);
        },

        rightLabelsReflow: function(labels) {
            var chart = this,
                distances = chart.distanceBetweenLabels(labels);

            chart.distributeLabels(distances, labels);
        },

        distanceBetweenLabels: function(labels) {
            var chart = this,
                segment = chart.segments[0],
                sector = segment.sector,
                firstBox = labels[0].box,
                secondBox,
                count = labels.length - 1,
                distances = [],
                distance,
                lr = sector.r + segment.options.labels.distance,
                i;

            distance = round(firstBox.y1 - (sector.c.y - lr - firstBox.height() - firstBox.height() / 2));
            distances.push(distance);
            for (i = 0; i < count; i++) {
                firstBox = labels[i].box;
                secondBox = labels[i + 1].box;
                distance = round(secondBox.y1 - firstBox.y2);
                distances.push(distance);
            }
            distance = round(sector.c.y + lr - labels[count].box.y2 - labels[count].box.height() / 2);
            distances.push(distance);

            return distances;
        },

        distributeLabels: function(distances, labels) {
            var chart = this,
                count = distances.length,
                remaining,
                left,
                right,
                i;

            for (i = 0; i < count; i++) {
                left = right = i;
                remaining = -distances[i];
                while(remaining > 0 && (left >= 0 || right < count)) {
                    remaining = chart._takeDistance(distances, i, --left, remaining);
                    remaining = chart._takeDistance(distances, i, ++right, remaining);
                }
            }

            chart.reflowLabels(distances, labels);
        },

        _takeDistance: function(distances, anchor, position, amount) {
            if (distances[position] > 0) {
                var available = math.min(distances[position], amount);
                amount -= available;
                distances[position] -= available;
                distances[anchor] += available;
            }

            return amount;
        },

        reflowLabels: function(distances, labels) {
            var chart = this,
                segments = chart.segments,
                segment = segments[0],
                sector = segment.sector,
                labelsCount = labels.length,
                labelOptions = segment.options.labels,
                labelDistance = labelOptions.distance,
                boxY = sector.c.y - (sector.r + labelDistance) - labels[0].box.height(),
                label,
                boxX,
                box,
                i;

            distances[0] += 2;
            for (i = 0; i < labelsCount; i++) {
                label = labels[i];
                boxY += distances[i];
                box = label.box;
                boxX = chart.hAlignLabel(
                    box.x2,
                    sector.clone().expand(labelDistance),
                    boxY,
                    boxY + box.height(),
                    label.orientation == RIGHT);

                if (label.orientation == RIGHT) {
                    if (labelOptions.align !== CIRCLE) {
                        boxX = sector.r + sector.c.x + labelDistance;
                    }
                    label.reflow(new Box2D(boxX + box.width(), boxY,
                        boxX, boxY));
                } else {
                    if (labelOptions.align !== CIRCLE) {
                        boxX = sector.c.x - sector.r - labelDistance;
                    }
                    label.reflow(new Box2D(boxX - box.width(), boxY,
                        boxX, boxY));
                }

                boxY += box.height();
            }
        },

        getViewElements: function(view) {
            var chart = this,
                options = chart.options,
                connectors = options.connectors,
                segments = chart.segments,
                connectorLine,
                sector,
                count = segments.length,
                space = 4,
                angle,
                lines = [],
                points,
                segment,
                seriesIx,
                label,
                i;

            for (i = 0; i < count; i++) {
                segment = segments[i];
                sector = segment.sector;
                angle = sector.middle();
                label = segment.label;
                seriesIx = { seriesId: segment.seriesIx };

                if (label) {
                    points = [];
                    if (label.options.position === OUTSIDE_END && segment.value !== 0) {
                        var box = label.box,
                            centerPoint = sector.c,
                            start = sector.point(angle),
                            middle = new Point2D(box.x1, box.center().y),
                            sr,
                            end,
                            crossing;

                        start = sector.clone().expand(connectors.padding).point(angle);
                        points.push(start);
                        if (label.orientation == RIGHT) {
                            end = new Point2D(box.x1 - connectors.padding, box.center().y);
                            crossing = intersection(centerPoint, start, middle, end);
                            middle = new Point2D(end.x - space, end.y);
                            crossing = crossing || middle;
                            crossing.x = math.min(crossing.x, middle.x);

                            if (chart.pointInCircle(crossing, sector.c, sector.r + space) ||
                                crossing.x < sector.c.x) {
                                sr = sector.c.x + sector.r + space;
                                if (segment.options.labels.align !== COLUMN) {
                                    if (sr < middle.x) {
                                        points.push(new Point2D(sr, start.y));
                                    } else {
                                        points.push(new Point2D(start.x + space * 2, start.y));
                                    }
                                } else {
                                    points.push(new Point2D(sr, start.y));
                                }
                                points.push(new Point2D(middle.x, end.y));
                            } else {
                                crossing.y = end.y;
                                points.push(crossing);
                            }
                        } else {
                            end = new Point2D(box.x2 + connectors.padding, box.center().y);
                            crossing = intersection(centerPoint, start, middle, end);
                            middle = new Point2D(end.x + space, end.y);
                            crossing = crossing || middle;
                            crossing.x = math.max(crossing.x, middle.x);

                            if (chart.pointInCircle(crossing, sector.c, sector.r + space) ||
                                crossing.x > sector.c.x) {
                                sr = sector.c.x - sector.r - space;
                                if (segment.options.labels.align !== COLUMN) {
                                    if (sr > middle.x) {
                                        points.push(new Point2D(sr, start.y));
                                    } else {
                                        points.push(new Point2D(start.x - space * 2, start.y));
                                    }
                                } else {
                                    points.push(new Point2D(sr, start.y));
                                }
                                points.push(new Point2D(middle.x, end.y));
                            } else {
                                crossing.y = end.y;
                                points.push(crossing);
                            }
                        }

                        points.push(end);
                        connectorLine = view.createPolyline(points, false, {
                            id: uniqueId(),
                            stroke: connectors.color,
                            strokeWidth: connectors.width,
                            animation: {
                                type: FADEIN,
                                delay: segment.categoryIx * PIE_SECTOR_ANIM_DELAY
                            }
                        });
                        lines.push(connectorLine);
                        segment.registerId(connectorLine.options.id, seriesIx);
                    }
                    segment.registerId(label.options.id, seriesIx);
                }

                segment.registerId(segment.options.id, seriesIx);
            }

            append(lines,
                ChartElement.fn.getViewElements.call(chart, view));

            return lines;
        },

        labelComparator: function (reverse) {
            reverse = (reverse) ? -1 : 1;

            return function(a, b) {
                a = (a.parent.sector.middle() + 270) % 360;
                b = (b.parent.sector.middle() + 270) % 360;
                return (a - b) * reverse;
            }
        },

        hAlignLabel: function(originalX, sector, y1, y2, direction) {
            var cx = sector.c.x,
                cy = sector.c.y,
                r = sector.r,
                t = math.min(math.abs(cy - y1), math.abs(cy - y2));

            if (t > r) {
                return originalX;
            } else {
                return cx + math.sqrt((r * r) - (t * t)) * (direction ? 1 : -1);
            }
        },

        pointInCircle: function(point, c, r) {
            return sqr(c.x - point.x) + sqr(c.y - point.y) < sqr(r);
        },

        formatPointValue: function(value, tooltipFormat) {
            return format(tooltipFormat, value);
        }
    });

    var PlotAreaBase = ChartElement.extend({
        init: function(series, options) {
            var plotArea = this;

            ChartElement.fn.init.call(plotArea, options);

            plotArea.series = series;
            plotArea.charts = [];
            plotArea.options.legend.items = [];
            plotArea.axes = [];

            plotArea.render();
        },

        options: {
            series: [],
            plotArea: {
                margin: {}
            },
            background: "",
            border: {
                color: BLACK,
                width: 0
            },
            legend: {}
        },

        appendChart: function(chart) {
            var plotArea = this;

            plotArea.charts.push(chart);
            plotArea.addToLegend(chart);
            plotArea.append(chart);
        },

        addToLegend: function(chart) {
            var series = chart.options.series,
                count = series.length,
                data = [],
                i;

            for (i = 0; i < count; i++) {
                data.push({ name: series[i].name || "", color: series[i].color });
            }

            append(this.options.legend.items, data);
        },

        reflow: function(targetBox) {
            var plotArea = this,
                options = plotArea.options.plotArea,
                margin = getSpacing(options.margin);

            plotArea.box = targetBox.clone();

            plotArea.box.unpad(margin);

            if (plotArea.axes.length > 0) {
                plotArea.reflowAxes();
                plotArea.box = plotArea.axisBox();
            }

            plotArea.reflowCharts();
        },

        axisCrossingValues: function(axis, crossingAxes) {
            var options = axis.options,
                crossingValues = [].concat(options.axisCrossingValue),
                valuesToAdd = crossingAxes.length - crossingValues.length,
                defaultValue = crossingValues[0] || 0,
                i;

            for (i = 0; i < valuesToAdd; i++) {
                crossingValues.push(defaultValue);
            }

            return crossingValues;
        },

        alignAxisTo: function(axis, targetAxis, crossingValue, targetCrossingValue) {
            var slot = axis.getSlot(crossingValue, crossingValue),
                targetSlot = targetAxis.getSlot(targetCrossingValue, targetCrossingValue);

            axis.reflow(
                axis.box.translate(
                    targetSlot.x1 - slot.x1,
                    targetSlot.y1 - slot.y1
                )
            );
        },

        alignAxes: function(xAxes, yAxes) {
            var plotArea = this,
                xAnchor = xAxes[0],
                yAnchor = yAxes[0],
                xAnchorCrossings = plotArea.axisCrossingValues(xAnchor, yAxes),
                yAnchorCrossings = plotArea.axisCrossingValues(yAnchor, xAxes),
                leftAnchor,
                rightAnchor,
                topAnchor,
                bottomAnchor,
                axis,
                axisCrossings,
                i;

            // TODO: Refactor almost-identical loops
            for (i = 0; i < yAxes.length; i++) {
                axis = yAxes[i];
                plotArea.alignAxisTo(axis, xAnchor, yAnchorCrossings[i], xAnchorCrossings[i]);

                if (axis.lineBox().x1 === xAnchor.lineBox().x1) {
                    if (leftAnchor) {
                        axis.reflow(axis.box
                            .alignTo(leftAnchor.box, LEFT)
                            .translate(-axis.options.margin, 0)
                        );
                    }

                    leftAnchor = axis;
                }

                if (axis.lineBox().x2 === xAnchor.lineBox().x2) {
                    if (!axis._mirrored) {
                        axis.options.labels.mirror = !axis.options.labels.mirror;
                        axis._mirrored = true;
                    }
                    plotArea.alignAxisTo(axis, xAnchor, yAnchorCrossings[i], xAnchorCrossings[i]);

                    if (rightAnchor) {
                        axis.reflow(axis.box
                            .alignTo(rightAnchor.box, RIGHT)
                            .translate(axis.options.margin, 0)
                        );
                    }

                    rightAnchor = axis;
                }
            }

            for (i = 0; i < xAxes.length; i++) {
                axis = xAxes[i];
                plotArea.alignAxisTo(axis, yAnchor, xAnchorCrossings[i], yAnchorCrossings[i]);

                if (axis.lineBox().y1 === yAnchor.lineBox().y1) {
                    if (!axis._mirrored) {
                        axis.options.labels.mirror = !axis.options.labels.mirror;
                        axis._mirrored = true;
                    }
                    plotArea.alignAxisTo(axis, yAnchor, xAnchorCrossings[i], yAnchorCrossings[i]);

                    if (topAnchor) {
                        axis.reflow(axis.box
                            .alignTo(topAnchor.box, TOP)
                            .translate(0, -axis.options.margin)
                        );
                    }

                    topAnchor = axis;
                }

                if (axis.lineBox().y2 === yAnchor.lineBox().y2) {
                    if (bottomAnchor) {
                        axis.reflow(axis.box
                            .alignTo(bottomAnchor.box, BOTTOM)
                            .translate(0, axis.options.margin)
                        );
                    }

                    bottomAnchor = axis;
                }
            }
        },

        axisBox: function() {
            var plotArea = this,
                axes = plotArea.axes,
                box = axes[0].box.clone(),
                i,
                length = axes.length;

            for (i = 1; i < length; i++) {
                box.wrap(axes[i].box);
            }

            return box;
        },

        shrinkAxes: function() {
            var plotArea = this,
                box = plotArea.box,
                axisBox = plotArea.axisBox(),
                overflowY = axisBox.height() - box.height(),
                overflowX = axisBox.width() - box.width(),
                axes = plotArea.axes,
                currentAxis,
                isVertical,
                i,
                length = axes.length;

            // Shrink all axes so they don't overflow out of the bounding box
            for (i = 0; i < length; i++) {
                currentAxis = axes[i];
                isVertical = currentAxis.options.isVertical;

                currentAxis.reflow(
                    currentAxis.box.shrink(
                        isVertical ? 0 : overflowX,
                        isVertical ? overflowY : 0
                    )
                );
            }
        },

        shrinkAdditionalAxes: function(xAxes, yAxes) {
            var plotArea = this,
                axes = plotArea.axes,
                xAnchor = xAxes[0],
                yAnchor = yAxes[0],
                anchorLineBox = xAnchor.lineBox().clone().wrap(yAnchor.lineBox()),
                overflowX,
                overflowY,
                currentAxis,
                isVertical,
                lineBox,
                i,
                length = axes.length;

            for (i = 0; i < length; i++) {
                currentAxis = axes[i];
                isVertical = currentAxis.options.isVertical;
                lineBox = currentAxis.lineBox();

                overflowX = math.max(0, lineBox.x2 - anchorLineBox.x2) +
                            math.max(0, anchorLineBox.x1 - lineBox.x1);

                overflowY = math.max(0, lineBox.y2 - anchorLineBox.y2) +
                            math.max(0, anchorLineBox.y1 - lineBox.y1);

                currentAxis.reflow(
                    currentAxis.box.shrink(
                        isVertical ? 0 : overflowX,
                        isVertical ? overflowY : 0
                    )
                );
            }
        },

        fitAxes: function() {
            var plotArea = this,
                axes = plotArea.axes,
                box = plotArea.box,
                axisBox = plotArea.axisBox(),
                offsetX = box.x1 - axisBox.x1,
                offsetY = box.y1 - axisBox.y1,
                currentAxis,
                i,
                length = axes.length;

            for (i = 0; i < length; i++) {
                currentAxis = axes[i];

                currentAxis.reflow(
                    currentAxis.box.translate(offsetX, offsetY)
                );
            }
        },

        reflowAxes: function() {
            var plotArea = this,
                axes = plotArea.axes,
                xAxes = grep(axes, (function(axis) { return !axis.options.isVertical; })),
                yAxes = grep(axes, (function(axis) { return axis.options.isVertical; })),
                i,
                length = axes.length;

            for (i = 0; i < length; i++) {
                axes[i].reflow(plotArea.box);
            }

            plotArea.alignAxes(xAxes, yAxes);
            plotArea.shrinkAdditionalAxes(xAxes, yAxes);
            plotArea.alignAxes(xAxes, yAxes);
            plotArea.shrinkAxes();
            plotArea.alignAxes(xAxes, yAxes);
            plotArea.fitAxes();
        },

        reflowCharts: function() {
            var plotArea = this,
                charts = plotArea.charts,
                count = charts.length,
                box = plotArea.box,
                i;

            for (i = 0; i < count; i++) {
                charts[i].reflow(box);
            }

            plotArea.box = box;
        },

        renderGridLines: function(view, axis, secondaryAxis) {
            var options = axis.options,
                isVertical = options.isVertical,
                crossingSlot = axis.getSlot(options.axisCrossingValue),
                secAxisPos = round(crossingSlot[isVertical ? "y1" : "x1"]),
                lineBox = secondaryAxis.lineBox(),
                lineStart = lineBox[isVertical ? "x1" : "y1"],
                lineEnd = lineBox[isVertical ? "x2" : "y2" ],
                majorTicks = axis.getMajorTickPositions(),
                gridLines = [],
                gridLine = function (pos, options) {
                    return {
                        pos: pos,
                        options: options
                    };
                };

            if (options.majorGridLines.visible) {
                gridLines = map(majorTicks, function(pos) {
                                return gridLine(pos, options.majorGridLines);
                            });
            }

            if (options.minorGridLines.visible) {
                gridLines = gridLines.concat(
                    map(axis.getMinorTickPositions(), function(pos) {
                        if (options.majorGridLines.visible) {
                            if (!inArray(pos, majorTicks)) {
                                return gridLine(pos, options.minorGridLines);
                            }
                        } else {
                            return gridLine(pos, options.minorGridLines);
                        }
                    }
                ));
            }

            return map(gridLines, function(line) {
                var gridLineOptions = {
                        strokeWidth: line.options.width,
                        stroke: line.options.color,
                        dashType: line.options.dashType
                    },
                    linePos = round(line.pos);

                if (secAxisPos === linePos && secondaryAxis.options.line.visible) {
                    return null;
                }

                if (isVertical) {
                    return view.createLine(
                        lineStart, linePos, lineEnd, linePos,
                        gridLineOptions);
                } else {
                    return view.createLine(
                        linePos, lineStart, linePos, lineEnd,
                        gridLineOptions);
                }
            });
        },

        getViewElements: function(view) {
            var plotArea = this,
                options = plotArea.options.plotArea,
                axisY = plotArea.axisY,
                axisX = plotArea.axisX,
                gridLinesY = axisY ? plotArea.renderGridLines(view, axisY, axisX) : [],
                gridLinesX = axisX ? plotArea.renderGridLines(view, axisX, axisY) : [],
                childElements = ChartElement.fn.getViewElements.call(plotArea, view),
                border = options.border || {},
                elements = [
                    view.createRect(plotArea.box, {
                        fill: options.background,
                        zIndex: -1
                    }),
                    view.createRect(plotArea.box, {
                        stroke: border.width ? border.color : "",
                        strokeWidth: border.width,
                        fill: "",
                        zIndex: 0,
                        dashType: border.dashType
                    })
                ];

            return [].concat(gridLinesY, gridLinesX, childElements, elements);
        }
    });

    var CategoricalPlotArea = PlotAreaBase.extend({
        init: function(series, options) {
            var plotArea = this,
                axisOptions = deepExtend({}, plotArea.options, options);

            plotArea.namedValueAxes = {};
            plotArea.valueAxisRangeTracker = new AxisGroupRangeTracker(axisOptions.valueAxis);

            if (series.length > 0) {
                plotArea.invertAxes = inArray(
                    series[0].type, [BAR, VERTICAL_LINE, VERTICAL_AREA]
                );
            }

            PlotAreaBase.fn.init.call(plotArea, series, options);
        },

        options: {
            categoryAxis: {
                categories: []
            },
            valueAxis: {}
        },

        render: function() {
            var plotArea = this,
                series = plotArea.series;

            plotArea.createBarChart(grep(series, function(s) {
                return inArray(s.type, [BAR, COLUMN]);
            }));

            plotArea.createLineChart(grep(series, function(s) {
                return inArray(s.type, [LINE, VERTICAL_LINE]);
            }));

            plotArea.createAreaChart(grep(series, function(s) {
                return inArray(s.type, [AREA, VERTICAL_AREA]);
            }));

            plotArea.createAxes();
        },

        appendChart: function(chart) {
            var plotArea = this,
                options = plotArea.options,
                series = chart.options.series,
                categories = options.categoryAxis.categories,
                categoriesToAdd = math.max(0, categoriesCount(series) - categories.length);

            append(categories, new Array(categoriesToAdd));

            plotArea.valueAxisRangeTracker.update(chart.valueAxisRanges);

            PlotAreaBase.fn.appendChart.call(plotArea, chart);
        },

        createBarChart: function(series) {
            if (series.length === 0) {
                return;
            }

            var plotArea = this,
                options = plotArea.options,
                firstSeries = series[0],
                barChart = new BarChart(plotArea, {
                    series: series,
                    invertAxes: plotArea.invertAxes,
                    isStacked: firstSeries.stack,
                    gap: firstSeries.gap,
                    spacing: firstSeries.spacing
                });

            plotArea.appendChart(barChart);
        },

        createLineChart: function(series) {
            if (series.length === 0) {
                return;
            }

            var plotArea = this,
                options = plotArea.options,
                firstSeries = series[0],
                lineChart = new LineChart(plotArea, {
                    invertAxes: plotArea.invertAxes,
                    isStacked: firstSeries.stack,
                    series: series
                });

            plotArea.appendChart(lineChart);
        },

        createAreaChart: function(series) {
            if (series.length === 0) {
                return;
            }

            var plotArea = this,
                options = plotArea.options,
                firstSeries = series[0],
                areaChart = new AreaChart(plotArea, {
                    invertAxes: plotArea.invertAxes,
                    isStacked: firstSeries.stack,
                    series: series
                });

            plotArea.appendChart(areaChart);
        },

        createAxes: function() {
            var plotArea = this,
                options = plotArea.options,
                range,
                invertAxes = plotArea.invertAxes,
                categoriesCount = options.categoryAxis.categories.length,
                categoryAxis = new CategoryAxis(deepExtend({
                        isVertical: invertAxes,
                        axisCrossingValue: invertAxes ? categoriesCount : 0
                    },
                    options.categoryAxis)
                ),
                axis,
                axisName,
                namedValueAxes = plotArea.namedValueAxes,
                valueAxisOptions = [].concat(options.valueAxis),
                primaryValueAxis;

            each(valueAxisOptions, function() {
                axisName = this.name || PRIMARY;
                range = plotArea.valueAxisRangeTracker.query(axisName);

                axis = namedValueAxes[axisName] =
                    new NumericAxis(range.min, range.max, deepExtend({
                        isVertical: !invertAxes
                    },
                    this)
                );

                plotArea.axes.push(axis);
                plotArea.append(axis);
            });

            primaryValueAxis = namedValueAxes[PRIMARY] || plotArea.axes[0];

            // TODO: Consider removing axisX and axisY aliases
            plotArea.axisX = invertAxes ? primaryValueAxis : categoryAxis;
            plotArea.axisY = invertAxes ? categoryAxis : primaryValueAxis;

            plotArea.categoryAxis = categoryAxis;
            plotArea.axes.push(categoryAxis);
            plotArea.append(plotArea.categoryAxis);
        }
    });

    var AxisGroupRangeTracker = Class.extend({
        init: function(axisOptions) {
            var tracker = this;

            tracker.axisRanges = {},
            tracker.axisOptions = [].concat(axisOptions),
            tracker.defaultRange = { min: 0, max: 1 };
        },

        update: function(chartAxisRanges) {
            var tracker = this,
                axisRanges = tracker.axisRanges,
                axisOptions = tracker.axisOptions,
                range,
                chartRange,
                i,
                axis,
                axisName,
                length = axisOptions.length;

            if (!chartAxisRanges) {
                return;
            }

            for (i = 0; i < length; i++) {
                axis = axisOptions[i];
                axisName = axis.name || PRIMARY;
                range = axisRanges[axisName];
                chartRange = chartAxisRanges[axisName];
                if (chartRange) {
                    axisRanges[axisName] = range =
                        range || { min: MAX_VALUE, max: MIN_VALUE };

                    range.min = math.min(range.min, chartRange.min);
                    range.max = math.max(range.max, chartRange.max);
                }
            }
        },

        query: function(axisName) {
            var tracker = this;

            return tracker.axisRanges[axisName] || deepExtend({}, tracker.defaultRange);
        }
    });

    var XYPlotArea = PlotAreaBase.extend({
        init: function(series, options) {
            var plotArea = this,
                axisOptions = deepExtend({}, plotArea.options, options);

            plotArea.namedXAxes = {};
            plotArea.namedYAxes = {};

            plotArea.xAxisRangeTracker = new AxisGroupRangeTracker(axisOptions.xAxis);
            plotArea.yAxisRangeTracker = new AxisGroupRangeTracker(axisOptions.yAxis);

            PlotAreaBase.fn.init.call(plotArea, series, options);
        },

        options: {
            xAxis: {},
            yAxis: {}
        },

        render: function() {
            var plotArea = this,
                series = plotArea.series;

            plotArea.createScatterChart(grep(series, function(s) {
                return s.type === SCATTER;
            }));

            plotArea.createScatterLineChart(grep(series, function(s) {
                return s.type === SCATTER_LINE;
            }));

            plotArea.createAxes();
        },

        appendChart: function(chart) {
            var plotArea = this;

            plotArea.xAxisRangeTracker.update(chart.xAxisRanges);
            plotArea.yAxisRangeTracker.update(chart.yAxisRanges);

            PlotAreaBase.fn.appendChart.call(plotArea, chart);
        },

        createScatterChart: function(series) {
            var plotArea = this;

            if (series.length > 0) {
                plotArea.appendChart(
                    new ScatterChart(plotArea, { series: series })
                );
            }
        },

        createScatterLineChart: function(series) {
            var plotArea = this;

            if (series.length > 0) {
                plotArea.appendChart(
                    new ScatterLineChart(plotArea, { series: series })
                );
            }
        },

        createXYAxis: function(options, isVertical) {
            var plotArea = this,
                axisName = options.name || PRIMARY,
                namedAxes = isVertical ? plotArea.namedYAxes : plotArea.namedXAxes,
                axisRanges = isVertical ? plotArea.yAxisRanges : plotArea.xAxisRanges,
                rangeTracker = isVertical ? plotArea.yAxisRangeTracker : plotArea.xAxisRangeTracker,
                range = rangeTracker.query(axisName),
                options = deepExtend({}, options, { isVertical: isVertical }),
                axis = new NumericAxis(range.min, range.max, options);

            namedAxes[axisName] = axis;
            plotArea.append(axis);
            plotArea.axes.push(axis);
        },

        createAxes: function() {
            var plotArea = this,
                options = plotArea.options,
                xAxesOptions = [].concat(options.xAxis),
                yAxesOptions = [].concat(options.yAxis);

            each(xAxesOptions, function() {
                plotArea.createXYAxis(this, false);
            });

            each(yAxesOptions, function() {
                plotArea.createXYAxis(this, true);
            });

            // TODO: Remove axisX and axisY aliases
            plotArea.axisX = plotArea.namedXAxes.primary || plotArea.namedXAxes[xAxesOptions[0].name];
            plotArea.axisY = plotArea.namedYAxes.primary || plotArea.namedYAxes[yAxesOptions[0].name];
        }
    });

    var PiePlotArea = PlotAreaBase.extend({
        render: function() {
            var plotArea = this,
                series = plotArea.series;

            plotArea.createPieChart(series);
        },

        createPieChart: function(series) {
            var plotArea = this,
                firstSeries = series[0],
                pieChart = new PieChart(plotArea, {
                    series: series,
                    padding: firstSeries.padding,
                    startAngle: firstSeries.startAngle,
                    connectors: firstSeries.connectors
                });

            plotArea.appendChart(pieChart);
        },

        addToLegend: function(chart) {
            var plotArea = this,
                options = plotArea.options,
                segments = chart.segments,
                count = segments.length,
                i;

            for (i = 0; i < count; i++) {
                options.legend.items.push({
                    name: segments[i].category,
                    color: segments[i].options.color });
            }
        }
    });

    // **************************
    // Visual elements
    // **************************

    var ViewElement = Class.extend({
        init: function(options) {
            var element = this;
            element.children = [];
            element.options = deepExtend({}, element.options, options);
        },

        render: function() {
            return this.template(this);
        },

        renderContent: function() {
            var element = this,
                output = "",
                sortedChildren = element.sortChildren(),
                childrenCount = sortedChildren.length,
                i;

            for (i = 0; i < childrenCount; i++) {
                output += sortedChildren[i].render();
            }

            return output;
        },

        sortChildren: function() {
            var element = this,
                children = element.children,
                length,
                i;

            for (i = 0, length = children.length; i < length; i++) {
                children[i]._childIndex = i;
            }

            return children.slice(0).sort(element.compareChildren);
        },

        compareChildren: function(a, b) {
            var aValue = a.options.zIndex || 0,
                bValue = b.options.zIndex || 0;

            if (aValue !== bValue) {
                return aValue - bValue;
            }

            return a._childIndex - b._childIndex;
        },

        renderAttr: function (name, value) {
            return defined(value) ? " " + name + "='" + value + "' " : "";
        }
    });

    var ViewBase = ViewElement.extend({
        init: function(options) {
            var view = this;

            ViewElement.fn.init.call(view, options);

            view.definitions = {};
            view.decorators = [];
            view.animations = [];
        },

        renderDefinitions: function() {
            var view = this,
                definitions = view.definitions,
                definitionId,
                output = "";

            for (definitionId in definitions) {
                if (definitions.hasOwnProperty(definitionId)) {
                    output += definitions[definitionId].render();
                }
            }

            return output;
        },

        decorate: function(element) {
            var view = this,
                decorators = view.decorators,
                i,
                length = decorators.length,
                currentDecorator;

            for (i = 0; i < length; i++) {
                currentDecorator = decorators[i];
                view._decorateChildren(currentDecorator, element);
                element = currentDecorator.decorate.call(currentDecorator, element);
            }

            return element;
        },

        _decorateChildren: function(decorator, element) {
            var view = this,
                children = element.children,
                i,
                length = children.length;

            for (i = 0; i < length; i++) {
                view._decorateChildren(decorator, children[i]);
                children[i] = decorator.decorate.call(decorator, children[i]);
            }
        },

        setupAnimations: function() {
            var animations = this.animations,
                i,
                count = animations.length;

            for (i = 0; i < count; i++) {
                animations[i].setup();
            }
        },

        playAnimations: function() {
            var view = this,
                anim;

            while(anim = view.animations.shift()) {
                anim.play();
            }
        },

        buildGradient: function(options) {
            var view = this,
                cache = view._gradientCache,
                hashCode,
                overlay,
                definition;

            if (!cache) {
                cache = view._gradientCache = [];
            }

            if (options) {
                hashCode = getHash(options);
                overlay = cache[hashCode];
                definition = Chart.Gradients[options.gradient];
                if (!overlay && definition) {
                    overlay = deepExtend({ id: uniqueId() }, definition, options);
                    cache[hashCode] = overlay;
                }
            }

            return overlay;
        }
    });

    function supportsSVG() {
        return doc.implementation.hasFeature(
            "http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
    }

    // Animations
    var BarAnimationDecorator = Class.extend({
        init: function(view) {
            this.view = view;
        },

        decorate: function(element) {
            var decorator = this,
                view = decorator.view,
                animation = element.options.animation;

            if (animation && view.options.transitions) {
                if (animation.type === BAR) {
                    view.animations.push(
                        new BarAnimation(element)
                    );
                }
            }

            return element;
        }
    });

    var PieAnimationDecorator = Class.extend({
        init: function(view) {
            this.view = view;
        },

        decorate: function(element) {
            var decorator = this,
                view = decorator.view,
                animation = element.options.animation;

            if (animation && animation.type === PIE && view.options.transitions) {
                view.animations.push(
                    new PieAnimation(element, animation)
                );
            }

            return element;
        }
    });

    var FadeAnimationDecorator = Class.extend({
        init: function(view) {
            this.view = view;
        },

        decorate: function(element) {
            var decorator = this,
                view = decorator.view,
                options = view.options,
                animation = element.options.animation;

            if (animation && animation.type === FADEIN && options.transitions) {
                view.animations.push(
                    new FadeAnimation(element, animation)
                );
            }

            return element;
        }
    });

    var ElementAnimation = Class.extend({
        init: function(element, options) {
            var anim = this;

            anim.options = deepExtend({}, anim.options, options);
            anim.element = element;
        },

        options: {
            duration: INITIAL_ANIMATION_DURATION,
            easing: SWING
        },

        play: function() {
            var anim = this,
                options = anim.options,
                element = anim.element,
                delay = options.delay || 0,
                start = +new Date() + delay,
                duration = options.duration,
                finish = start + duration,
                domElement = doc.getElementById(element.options.id),
                easing = jQuery.easing[options.easing],
                wallTime,
                time,
                pos,
                easingPos;

            setTimeout(function() {
                var loop = function() {
                    wallTime = +new Date();
                    time = math.min(wallTime - start, duration);
                    pos = time / duration;
                    easingPos = easing(pos, time, 0, 1, duration);

                    anim.step(easingPos);

                    element.refresh(domElement);

                    if (wallTime < finish) {
                        requestAnimFrame(loop, domElement);
                    }
                };

                loop();
            }, delay);
        },

        setup: function() {
        },

        step: function(pos) {
        }
    });

    var FadeAnimation = ElementAnimation.extend({
        options: {
            duration: 200,
            easing: LINEAR
        },

        setup: function() {
            var anim = this,
                options = anim.element.options;

            anim.targetFillOpacity = options.fillOpacity;
            anim.targetStrokeOpacity = options.strokeOpacity;
            options.fillOpacity = options.strokeOpacity = 0;
        },

        step: function(pos) {
            var anim = this,
                options = anim.element.options;

            options.fillOpacity = pos * anim.targetFillOpacity;
            options.strokeOpacity = pos * anim.targetStrokeOpacity;
        }
    });

    var ExpandAnimation = ElementAnimation.extend({
        options: {
            size: 0,
            easing: LINEAR
        },

        setup: function() {
            var anim = this,
                points = anim.element.points;

            points[1].x = points[2].x = points[0].x;
        },

        step: function(pos) {
            var anim = this,
                options = anim.options,
                size = interpolateValue(0, options.size, pos),
                points = anim.element.points;

            // Expands rectangle to the right
            points[1].x = points[2].x = points[0].x + size;
        }
    });

    var requestAnimFrame =
        window.requestAnimationFrame       ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame    ||
        window.oRequestAnimationFrame      ||
        window.msRequestAnimationFrame     ||
        function(callback, element) {
            setTimeout(callback, ANIMATION_STEP);
        };

    var BarAnimation = ElementAnimation.extend({
        options: {
            easing: SWING
        },

        setup: function() {
            var anim = this,
                element = anim.element,
                points = element.points,
                options = element.options,
                axis = options.normalAngle === 0 ? Y : X,
                stackBase = options.stackBase,
                aboveAxis = options.aboveAxis,
                startPosition,
                endState = anim.endState = {
                    top: points[0].y,
                    right: points[1].x,
                    bottom: points[3].y,
                    left: points[0].x
                };

            if (axis === Y) {
                startPosition = defined(stackBase) ? stackBase :
                    aboveAxis ? endState.bottom : endState.top;
            } else {
                startPosition = defined(stackBase) ? stackBase :
                    aboveAxis ? endState.left : endState.right;
            }

            anim.startPosition = startPosition;

            updateArray(points, axis, startPosition);
        },

        step: function(pos) {
            var anim = this,
                startPosition = anim.startPosition,
                endState = anim.endState,
                element = anim.element,
                points = element.points;

            if (element.options.normalAngle === 0) {
                points[0].y = points[1].y =
                    interpolateValue(startPosition, endState.top, pos);

                points[2].y = points[3].y =
                    interpolateValue(startPosition, endState.bottom, pos);
            } else {
                points[0].x = points[3].x =
                    interpolateValue(startPosition, endState.left, pos);

                points[1].x = points[2].x =
                    interpolateValue(startPosition, endState.right, pos);
            }
        }
    });

    var PieAnimation = ElementAnimation.extend({
        options: {
            easing: "easeOutElastic",
            duration: INITIAL_ANIMATION_DURATION
        },

        setup: function() {
            var anim = this,
                sector = anim.element.circleSector;

            anim.endRadius = sector.r;
            sector.r = 0;
        },

        step: function(pos) {
            var anim = this,
                endRadius = anim.endRadius,
                sector = anim.element.circleSector;

            sector.r = interpolateValue(0, endRadius, pos);
        }
    });

    var Highlight = Class.extend({
        init: function(view, viewElement, options) {
            var highlight = this;
            highlight.options = deepExtend({}, highlight.options, options);

            highlight.view = view;
            highlight.viewElement = viewElement;
        },

        options: {
            fill: WHITE,
            fillOpacity: 0.2,
            stroke: WHITE,
            strokeWidth: 1,
            strokeOpacity: 0.2
        },

        show: function(point) {
            var highlight = this,
                view = highlight.view,
                viewElement = highlight.viewElement,
                outline,
                element;

            highlight.hide();

            if (point.getOutlineElement) {
                outline = point.getOutlineElement(view, highlight.options);

                if (outline) {
                    element = view.renderElement(outline);
                    viewElement.appendChild(element);

                    highlight.element = element;
                    highlight.visible = true;
                }
            }
        },

        hide: function() {
            var highlight = this,
                element = highlight.element;

            if (element) {
                if (element.parentNode) {
                    element.parentNode.removeChild(element);
                }

                delete highlight.element;
                highlight.visible = false;
            }
        }
    });

    var Tooltip = Class.extend({
        init: function(chartElement, options) {
            var tooltip = this;

            tooltip.options = deepExtend({}, tooltip.options, options);
            options = tooltip.options;

            tooltip.chartElement = chartElement;
            tooltip.chartPadding = {
                top: parseInt(chartElement.css("paddingTop"), 10),
                left: parseInt(chartElement.css("paddingLeft"), 10)
            };

            tooltip.template = Tooltip.template;
            if (!tooltip.template) {
                tooltip.template = Tooltip.template = template(
                    "<div style='display:none; position: absolute; font: #= d.font #;" +
                    "border-radius: 4px; -moz-border-radius: 4px; -webkit-border-radius: 4px;" +
                    "border: #= d.border.width #px solid;" +
                    "opacity: #= d.opacity #; filter: alpha(opacity=#= d.opacity * 100 #);" +
                    "padding: 2px 6px; white-space: nowrap; z-index: 1000;'></div>"
                );
            }

            tooltip.element = $(tooltip.template(tooltip.options)).appendTo(chartElement);
        },

        options: {
            background: BLACK,
            color: WHITE,
            border: {
                width: 3
            },
            opacity: 1,
            animation: {
                duration: TOOLTIP_ANIMATION_DURATION
            }
        },

        show: function(point) {
            var tooltip = this;

            tooltip.point = point;
            tooltip.showTimeout =
                setTimeout(proxy(tooltip._show, tooltip), TOOLTIP_SHOW_DELAY);
        },

        _show: function() {
            var tooltip = this,
                point = tooltip.point,
                element = tooltip.element,
                options = tooltip.options,
                chartPadding = tooltip.chartPadding,
                anchor,
                template,
                content,
                tooltipOptions,
                top,
                left;

            if (!point) {
                return;
            }
            content = point.value.toString();

            tooltipOptions = deepExtend({}, tooltip.options, point.options.tooltip);

            if (tooltipOptions.template) {
                template = baseTemplate(tooltipOptions.template);
                content = template({
                    value: point.value,
                    category: point.category,
                    series: point.series,
                    dataItem: point.dataItem,
                    percentage: point.percentage
                });
            } else if (tooltipOptions.format) {
                content = point.formatPointValue(tooltipOptions.format);
            }

            element.html(content);

            anchor = point.tooltipAnchor(element.outerWidth(), element.outerHeight());
            top = round(anchor.y + chartPadding.top) + "px";
            left = round(anchor.x + chartPadding.left) + "px";

            if (!tooltip.visible) {
                tooltip.element.css({ top: top, left: left });
            }

            tooltip.element
                .css({
                   backgroundColor: tooltipOptions.background,
                   borderColor: tooltipOptions.border.color || point.options.color,
                   color: tooltipOptions.color,
                   opacity: tooltipOptions.opacity,
                   borderWidth: tooltipOptions.border.width
                })
                .stop(true, true)
                .show()
                .animate({
                    left: left,
                    top: top
                }, options.animation.duration);

            tooltip.visible = true;
        },

        hide: function() {
            var tooltip = this;

            clearTimeout(tooltip.showTimeout);

            if (tooltip.visible) {
                tooltip.element.fadeOut();

                tooltip.point = null;
                tooltip.visible = false;
            }
        }
    });

    // Helper functions
    function ceil(value, step) {
        return round(math.ceil(value / step) * step, DEFAULT_PRECISION);
    }

    function floor(value, step) {
        return round(math.floor(value / step) * step, DEFAULT_PRECISION);
    }

    function round(value, precision) {
        var power = math.pow(10, precision || 0);
        return math.round(value * power) / power;
    }

    function measureText(text, style, rotation) {
        var styleHash = getHash(style),
            cacheKey = text + styleHash + rotation,
            cachedResult = measureText.cache[cacheKey];

        if (cachedResult) {
            return cachedResult;
        }

        var measureBox = measureText.measureBox,
            baselineMarker = measureText.baselineMarker.cloneNode(false);

        if (!measureBox) {
            measureBox = measureText.measureBox =
                $("<div style='position: absolute; top: -4000px; left: -4000px;" +
                              "line-height: normal; visibility: hidden;' />")
                .appendTo(doc.body)[0];
        }

        for (var styleKey in style) {
            measureBox.style[styleKey] = style[styleKey];
        }
        measureBox.innerHTML = text;
        measureBox.appendChild(baselineMarker);

        var size = {
                width: measureBox.offsetWidth - BASELINE_MARKER_SIZE,
                height: measureBox.offsetHeight,
                baseline: baselineMarker.offsetTop + BASELINE_MARKER_SIZE
            };

        if (rotation) {
            var width = size.width,
                height = size.height,
                cx = width / 2,
                cy = height / 2,
                r1 = rotatePoint(0, 0, cx, cy, rotation),
                r2 = rotatePoint(width, 0, cx, cy, rotation),
                r3 = rotatePoint(width, height, cx, cy, rotation);
                r4 = rotatePoint(0, height, cx, cy, rotation);

            size.normalWidth = width;
            size.normalHeight = height;
            size.width = math.max(r1.x, r2.x, r3.x, r4.x) - math.min(r1.x, r2.x, r3.x, r4.x);
            size.height = math.max(r1.y, r2.y, r3.y, r4.y) - math.min(r1.y, r2.y, r3.y, r4.y);
        }

        measureText.cache[cacheKey] = size;

        return size;
    }

    measureText.cache = {};
    measureText.baselineMarker =
        $("<div style='display: inline-block; vertical-align: baseline;" +
                  "width: " + BASELINE_MARKER_SIZE + "px; height: " + BASELINE_MARKER_SIZE + "px;" +
                  "zoom: 1; *display: inline; overflow: hidden;' />")[0];

    function getHash(object) {
        var hash = [];
        for (var key in object) {
            hash.push(key + object[key]);
        }

        return hash.sort().join(" ");
    }

    function rotatePoint(x, y, cx, cy, angle) {
        var theta = angle * DEGREE;
        return {
            x: cx + (x - cx) * math.cos(theta) + (y - cy) * math.sin(theta),
            y: cy - (x - cx) * math.sin(theta) + (y - cy) * math.cos(theta)
        }
    }

    function boxDiff(r, s) {
        if (r.x1 == s.x1 && r.y1 == s.y1 && r.x2 == s.x2 && r.y2 == s.y2) {
            return s;
        }

        var a = math.min(r.x1, s.x1),
            b = math.max(r.x1, s.x1),
            c = math.min(r.x2, s.x2),
            d = math.max(r.x2, s.x2),
            e = math.min(r.y1, s.y1),
            f = math.max(r.y1, s.y1),
            g = math.min(r.y2, s.y2),
            h = math.max(r.y2, s.y2),
            result = [];

        // X = intersection, 0-7 = possible difference areas
        // h +-+-+-+
        // . |5|6|7|
        // g +-+-+-+
        // . |3|X|4|
        // f +-+-+-+
        // . |0|1|2|
        // e +-+-+-+
        // . a b c d

        // we'll always have rectangles 1, 3, 4 and 6
        result[0] = new Box2D(b, e, c, f);
        result[1] = new Box2D(a, f, b, g);
        result[2] = new Box2D(c, f, d, g);
        result[3] = new Box2D(b, g, c, h);

        // decide which corners
        if( r.x1 == a && r.y1 == e || s.x1 == a && s.y1 == e )
        { // corners 0 and 7
            result[4] = new Box2D(a, e, b, f);
            result[5] = new Box2D(c, g, d, h);
        }
        else
        { // corners 2 and 5
            result[4] = new Box2D(c, e, d, f);
            result[5] = new Box2D(a, g, b, h);
        }

        return $.grep(result, function(box) {
            return box.height() > 0 && box.width() > 0
        })[0];
    }

    function sparseArrayMin(arr) {
        return sparseArrayLimits(arr).min;
    }

    function sparseArrayMax(arr) {
        return sparseArrayLimits(arr).max;
    }

    function sparseArrayLimits(arr) {
        var min = MAX_VALUE,
            max = MIN_VALUE,
            i,
            length = arr.length,
            n;

        for (i = 0; i < length; i++) {
            n = arr[i];
            if (defined(n)) {
                min = math.min(min, n);
                max = math.max(max, n);
            }
        }

        return { min: min, max: max };
    }

    function getSpacing(value) {
        var spacing = { top: 0, right: 0, bottom: 0, left: 0 };

        if (typeof(value) === "number") {
            spacing[TOP] = spacing[RIGHT] = spacing[BOTTOM] = spacing[LEFT] = value;
        } else {
            spacing[TOP] = value[TOP] || 0;
            spacing[RIGHT] = value[RIGHT] || 0;
            spacing[BOTTOM] = value[BOTTOM] || 0;
            spacing[LEFT] = value[LEFT] || 0;
        }

        return spacing;
    }

    function inArray(value, array) {
        return $.inArray(value, array) != -1;
    }

    function last(array) {
        return array[array.length - 1];
    }

    function deepExtend(destination) {
        var i = 1,
            length = arguments.length;

        for (i = 1; i < length; i++) {
            deepExtendOne(destination, arguments[i]);
        }

        return destination;
    }

    function deepExtendOne(destination, source) {
        var property,
            propValue,
            propType,
            destProp;

        for (property in source) {
            propValue = source[property];
            propType = typeof propValue;
            if (propType === OBJECT && propValue !== null && propValue.constructor !== Array) {
                destProp = destination[property];
                if (typeof (destProp) === OBJECT) {
                    destination[property] = destProp || {};
                } else {
                    destination[property] = {};
                }
                deepExtendOne(destination[property], propValue);
            } else if (propType !== UNDEFINED) {
                destination[property] = propValue;
            }
        }

        return destination;
    }

    function intersection(a1, a2, b1, b2) {
        var result,
            ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),
            u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y),
            ua;

        if (u_b != 0) {
            ua = (ua_t / u_b);

            result = new Point2D(
                a1.x + ua * (a2.x - a1.x),
                a1.y + ua * (a2.y - a1.y)
            );
        }

        return result;
    }

    function append(first, second) {
        [].push.apply(first, second);
    }

    function interpolateValue(start, end, progress) {
        return round(start + (end - start) * progress, COORD_PRECISION);
    }

    function applySeriesDefaults(options, themeOptions) {
        var series = options.series,
            i,
            seriesLength = series.length,
            seriesType,
            seriesDefaults = options.seriesDefaults,
            commonDefaults = deepExtend({}, options.seriesDefaults),
            themeSeriesDefaults = themeOptions ? deepExtend({}, themeOptions.seriesDefaults) : {},
            commonThemeDefaults = deepExtend({}, themeSeriesDefaults);

        cleanupNestedSeriesDefaults(commonDefaults);
        cleanupNestedSeriesDefaults(commonThemeDefaults);

        for (i = 0; i < seriesLength; i++) {
            seriesType = series[i].type || options.seriesDefaults.type;

            series[i] = deepExtend(
                {},
                commonThemeDefaults,
                themeSeriesDefaults[seriesType],
                { tooltip: options.tooltip },
                commonDefaults,
                seriesDefaults[seriesType],
                series[i]);
        }
    }

    function cleanupNestedSeriesDefaults(seriesDefaults) {
        delete seriesDefaults.bar;
        delete seriesDefaults.column;
        delete seriesDefaults.line;
        delete seriesDefaults.verticalLine;
        delete seriesDefaults.pie;
        delete seriesDefaults.area;
        delete seriesDefaults.verticalArea;
        delete seriesDefaults.scatter;
        delete seriesDefaults.scatterLine;
    }

    function applySeriesColors(options) {
        var series = options.series,
            i,
            seriesLength = series.length,
            colors = options.seriesColors || [];

        for (i = 0; i < seriesLength; i++) {
            series[i].color = series[i].color || colors[i % colors.length];
        }
    }

    function applyAxisDefaults(options, themeOptions) {
        var themeAxisDefaults = deepExtend({}, (themeOptions || {}).axisDefaults);

        each(["category", "value", "x", "y"], function() {
            var axisName = this + "Axis",
                axes = [].concat(options[axisName]);

            axes = $.map(axes, function(axisOptions) {
                var axisColor = (axisOptions || {}).color;
                return deepExtend({},
                    themeAxisDefaults,
                    themeAxisDefaults[axisName],
                    options.axisDefaults,
                    { line: { color: axisColor }, labels: { color: axisColor }, title: { color: axisColor } },
                    axisOptions
                );
            });

            options[axisName] = axes.length > 1 ? axes : axes[0];
        });
    }

    function applyDefaults(options, themeOptions) {
        applyAxisDefaults(options, themeOptions);
        applySeriesDefaults(options, themeOptions);
    }

    function incrementSlot(slots, index, value) {
        slots[index] = (slots[index] || 0) + value;
    }

    function defined(value) {
        return typeof value !== UNDEFINED;
    }

    var uniqueId = (function() {
        // Implements 32-bit Linear feedback shift register
        var lfsr = 1;

        return function() {
            lfsr = ((lfsr >>> 1) ^ (-(lfsr & 1) & 0xD0000001)) >>> 0;
            return ID_PREFIX + lfsr.toString(16);
        };
    })();

    var Color = function(value) {
        var color = this,
            formats = Color.formats,
            re,
            processor,
            parts,
            i,
            channels;

        if (arguments.length === 1) {
            value = color.resolveColor(value);

            for (i = 0; i < formats.length; i++) {
                re = formats[i].re;
                processor = formats[i].process;
                parts = re.exec(value);

                if (parts) {
                    channels = processor(parts);
                    color.r = channels[0];
                    color.g = channels[1];
                    color.b = channels[2];
                }
            }
        } else {
            color.r = arguments[0];
            color.g = arguments[1];
            color.b = arguments[2];
        }

        color.r = color.normalizeByte(color.r);
        color.g = color.normalizeByte(color.g);
        color.b = color.normalizeByte(color.b);
    };

    Color.prototype = {
        toHex: function() {
            var color = this,
                pad = color.padDigit,
                r = color.r.toString(16),
                g = color.g.toString(16),
                b = color.b.toString(16);

            return "#" + pad(r) + pad(g) + pad(b);
        },

        resolveColor: function(value) {
            value = value || BLACK;

            if (value.charAt(0) == "#") {
                value = value.substr(1, 6);
            }

            value = value.replace(/ /g, "");
            value = value.toLowerCase();
            value = Color.namedColors[value] || value;

            return value;
        },

        normalizeByte: function(value) {
            return (value < 0 || isNaN(value)) ? 0 : ((value > 255) ? 255 : value);
        },

        padDigit: function(value) {
            return (value.length === 1) ? "0" + value : value;
        },

        brightness: function(value) {
            var color = this,
                round = math.round;

            color.r = round(color.normalizeByte(color.r * value));
            color.g = round(color.normalizeByte(color.g * value));
            color.b = round(color.normalizeByte(color.b * value));

            return color;
        }
    };

    Color.formats = [{
            re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
            process: function(parts) {
                return [
                    parseInt(parts[1], 10), parseInt(parts[2], 10), parseInt(parts[3], 10)
                ];
            }
        }, {
            re: /^(\w{2})(\w{2})(\w{2})$/,
            process: function(parts) {
                return [
                    parseInt(parts[1], 16), parseInt(parts[2], 16), parseInt(parts[3], 16)
                ];
            }
        }, {
            re: /^(\w{1})(\w{1})(\w{1})$/,
            process: function(parts) {
                return [
                    parseInt(parts[1] + parts[1], 16),
                    parseInt(parts[2] + parts[2], 16),
                    parseInt(parts[3] + parts[3], 16)
                ];
            }
        }
    ];

    Color.namedColors = {
        aqua: "00ffff", azure: "f0ffff", beige: "f5f5dc",
        black: "000000", blue: "0000ff", brown: "a52a2a",
        coral: "ff7f50", cyan: "00ffff", darkblue: "00008b",
        darkcyan: "008b8b", darkgray: "a9a9a9", darkgreen: "006400",
        darkorange: "ff8c00", darkred: "8b0000", dimgray: "696969",
        fuchsia: "ff00ff", gold: "ffd700", goldenrod: "daa520",
        gray: "808080", green: "008000", greenyellow: "adff2f",
        indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c",
        lightblue: "add8e6", lightgrey: "d3d3d3", lightgreen: "90ee90",
        lightpink: "ffb6c1", lightyellow: "ffffe0", lime: "00ff00",
        limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff",
        maroon: "800000", mediumblue: "0000cd", navy: "000080",
        olive: "808000", orange: "ffa500", orangered: "ff4500",
        orchid: "da70d6", pink: "ffc0cb", plum: "dda0dd",
        purple: "800080", red: "ff0000", royalblue: "4169e1",
        salmon: "fa8072", silver: "c0c0c0", skyblue: "87ceeb",
        slateblue: "6a5acd", slategray: "708090", snow: "fffafa",
        steelblue: "4682b4", tan: "d2b48c", teal: "008080",
        tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee",
        wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5",
        yellow: "ffff00", yellowgreen: "9acd32"
    };

    Chart.Gradients = {
        glass: {
            type: LINEAR,
            rotation: 0,
            stops: [{
                offset: 0,
                color: WHITE,
                opacity: 0
            }, {
                offset: 0.1,
                color: WHITE,
                opacity: 0
            }, {
                offset: 0.25,
                color: WHITE,
                opacity: 0.3
            }, {
                offset: 0.92,
                color: WHITE,
                opacity: 0
            }, {
                offset: 1,
                color: WHITE,
                opacity: 0
            }]
        },
        sharpBevel: {
            type: RADIAL,
            stops: [{
                offset: 0,
                color: WHITE,
                opacity: 0.55
            }, {
                offset: 0.65,
                color: WHITE,
                opacity: 0
            }, {
                offset: 0.95,
                color: WHITE,
                opacity: 0
            }, {
                offset: 0.95,
                color: WHITE,
                opacity: 0.25
            }]
        },
        roundedBevel: {
            type: RADIAL,
            stops: [{
                offset: 0.33,
                color: WHITE,
                opacity: 0.06
            }, {
                offset: 0.83,
                color: WHITE,
                opacity: 0.2
            }, {
                offset: 0.95,
                color: WHITE,
                opacity: 0
            }]
        }
    };

    function updateArray(arr, prop, value) {
        var i,
            length = arr.length;

        for(i = 0; i < length; i++) {
            arr[i][prop] = value;
        }
    }

    function categoriesCount(series) {
        var seriesCount = series.length,
            categories = 0,
            i;

        for (i = 0; i < seriesCount; i++) {
            categories = math.max(categories, series[i].data.length);
        }

        return categories;
    }

    function sqr(value) {
        return value * value;
    }

    jQuery.extend(jQuery.easing, {
        easeOutElastic: function (n, d, first, diff) {
            var s = 1.70158,
                p = 0,
                a = diff;

            if ( n === 0 ) {
                return first;
            }

            if ( n === 1) {
                return first + diff;
            }

            if (!p) {
                p = 0.5;
            }

            if (a < math.abs(diff)) {
                a=diff;
                s = p / 4;
            } else {
                s = p / (2 * math.PI) * math.asin(diff / a);
            }

            return a * math.pow(2,-10 * n) *
                   math.sin((n * 1 - s) * (1.1 * math.PI) / p) +
                   diff + first;
        }
    });

    function getField(field, row) {
        if (row === null) {
            return null;
        }

        var get = getField.cache[field] =
                getField.cache[field] || getter(field, true);

        return get(row);
    }
    getField.cache = {};

    // Exports ================================================================

    $t.scripts.push("telerik.chart.js");

    $t.chart = function (element, options) {
        var wrapper = this,
            chart,
            dataSource,
            e = {};
        
        wrapper.element = element;

        $t.bind(wrapper.element, {
            load: options.onLoad,
            error: options.onError,
            dataBinding: options.onDataBinding
        });

        deepExtend(options, {
            dataBound: options.onDataBound,
            seriesClick: options.onSeriesClick
        });
        
        wrapper._chart = chart = new Chart(element, extend({ autoBind: false }, options));

        dataSource = chart.dataSource;
        if (dataSource) {
            dataSource.bind("error", function(xhr, status, response) {
                var prevented = trigger(element, "error", {
                    XMLHttpRequest: xhr
                });

                if (!prevented) {
                    alert("Error! Data binding failed. Unexpected server response - see console.");
                }
            });

            $(wrapper.element).bind("load", function() {
                if (!trigger(element, DATA_BINDING, e)) {
                    chart.dataSource.query(e.data || {});
                }
            });
        }

        wrapper.options = chart.options;
    };

    $t.chart.prototype = {
        rebind: function(data) {
            this._ajaxRequest(data);
        },

        refresh: function() {
            var wrapper = this,
                chart = wrapper._chart;

            chart.options = wrapper.options;

            applyDefaults(chart.options);

            chart._redraw();
        },
        
        _ajaxRequest: function(data) {
            var e = {};

            if (!trigger(this.element, DATA_BINDING, e)) {
                this._chart.dataSource.read(extend(e.data || {}, data));
            }
        },

        refresh: function() {
            var wrapper = this,
                chart = wrapper._chart;

            chart.options = wrapper.options;
            chart.refresh();
        },

        svg: function() {
            return this._chart.svg();
        }
    };

    $.fn.tChart = function(options) {
        return $t.create(this, {
            name: "tChart",
            init: function(element, options) {
                return new $t.chart(element, options);
            },
            options: options
        });
    };

    $.fn.tChart.defaults = { };

    $t.chart.Chart = Chart;

    deepExtend(Chart, {
        COORD_PRECISION: COORD_PRECISION,
        CLIP: CLIP,
        DEFAULT_WIDTH: DEFAULT_WIDTH,
        DEFAULT_HEIGHT: DEFAULT_HEIGHT,
        DEFAULT_FONT: DEFAULT_FONT,
        defined: defined,
        template: template,
        rotatePoint: rotatePoint,
        round: round,
        supportsSVG: supportsSVG,
        uniqueId: uniqueId,
        Box2D: Box2D,
        Point2D: Point2D,
        Sector: Sector,
        Text: Text,
        BarLabel: BarLabel,
        ChartElement: ChartElement,
        RootElement: RootElement,
        BoxElement: BoxElement,
        TextBox: TextBox,
        NumericAxis: NumericAxis,
        CategoryAxis: CategoryAxis,
        Bar: Bar,
        BarChart: BarChart,
        ShapeElement: ShapeElement,
        LinePoint: LinePoint,
        LineChart: LineChart,
        AreaChart: AreaChart,
        ClusterLayout: ClusterLayout,
        StackLayout: StackLayout,
        Title: Title,
        Legend: Legend,
        CategoricalPlotArea: CategoricalPlotArea,
        PiePlotArea: PiePlotArea,
        XYPlotArea: XYPlotArea,
        Tooltip: Tooltip,
        Highlight: Highlight,
        PieSegment: PieSegment,
        PieChart: PieChart,
        ViewElement: ViewElement,
        ScatterChart: ScatterChart,
        ScatterLineChart: ScatterLineChart,
        ViewBase: ViewBase,
        deepExtend: deepExtend,
        Color: Color,
        measureText: measureText,
        ExpandAnimation: ExpandAnimation,
        BarAnimation: BarAnimation,
        BarAnimationDecorator: BarAnimationDecorator,
        PieAnimation: PieAnimation,
        PieAnimationDecorator: PieAnimationDecorator,
        FadeAnimation: FadeAnimation,
        FadeAnimationDecorator: FadeAnimationDecorator,
        categoriesCount: categoriesCount
    });

})(jQuery);(function () {

    // Imports ================================================================
    var $ = jQuery,
        $t = $.telerik,
        Class = $t.Class,
        Chart = $t.chart.Chart,
        BarAnimationDecorator = Chart.BarAnimationDecorator,
        PieAnimationDecorator = Chart.PieAnimationDecorator,
        FadeAnimationDecorator = Chart.FadeAnimationDecorator,
        Box2D = Chart.Box2D,
        Point2D = Chart.Point2D,
        ExpandAnimation = Chart.ExpandAnimation,
        ViewBase = Chart.ViewBase,
        ViewElement = Chart.ViewElement,
        deepExtend = Chart.deepExtend,
        defined = Chart.defined,
        template = Chart.template,
        uniqueId = Chart.uniqueId,
        round = Chart.round,
        doc = document,
        math = Math;

    // Constants ==============================================================
    var CLIP = Chart.CLIP,
        COORD_PRECISION = Chart.COORD_PRECISION,
        DEFAULT_WIDTH = Chart.DEFAULT_WIDTH,
        DEFAULT_HEIGHT = Chart.DEFAULT_HEIGHT,
        DEFAULT_FONT = Chart.DEFAULT_FONT,
        NONE = "none",
        RADIAL = "radial",
        SQUARE = "square",
        SVG_NS = "http://www.w3.org/2000/svg",
        SVG_DASH_TYPE = {
            dot: [1.5, 3.5],
            dash: [4, 3.5],
            longdash: [8, 3.5],
            dashdot: [3.5, 3.5, 1.5, 3.5],
            longdashdot: [8, 3.5, 1.5, 3.5],
            longdashdotdot: [8, 3.5, 1.5, 3.5, 1.5, 3.5]
        },
        TRANSPARENT = "transparent",
        UNDEFINED = "undefined";

    // View ===================================================================
    var SVGView = ViewBase.extend({
        init: function(options) {
            var view = this;

            ViewBase.fn.init.call(view, options);

            view.decorators.push(
                new SVGOverlayDecorator(view),
                new SVGGradientDecorator(view),
                new BarAnimationDecorator(view),
                new PieAnimationDecorator(view),
                new SVGClipAnimationDecorator(view),
                new FadeAnimationDecorator(view)
            );

            view.template = SVGView.template;
            if (!view.template) {
                view.template = SVGView.template = template(
                    "<svg xmlns='" + SVG_NS + "' version='1.1' " +
                    "width='#= d.options.width #px' height='#= d.options.height #px' " +
                    "style='position: relative; display: block;'>" +
                    "#= d.renderDefinitions() #" +
                    "#= d.renderContent() #</svg>"
                );
            }
        },

        options: {
            width: DEFAULT_WIDTH,
            height: DEFAULT_HEIGHT,
            idPrefix: ""
        },

        renderTo: function(container) {
            var view = this,
                viewElement;

            view.setupAnimations();

            renderSVG(container, view.render());
            viewElement = container.firstChild;
            view.alignToScreen(viewElement);

            view.playAnimations();

            return viewElement;
        },

        renderDefinitions: function() {
            var view = this,
                output = ViewBase.fn.renderDefinitions.call(view);

            return output.length > 0 ? "<defs>" + output + "</defs>" : "";
        },

        renderElement: function(element) {
            var container = doc.createElement("div"),
                element;

            renderSVG(container,
                "<svg xmlns='" + SVG_NS + "' version='1.1'>" +
                element.render() +
                "</svg>"
            );

            element = container.firstChild.firstChild;

            return element;
        },

        createGroup: function(options) {
            return this.decorate(
                new SVGGroup(options)
            );
        },

        createText: function(content, options) {
            return this.decorate(
                new SVGText(content, options)
            );
        },

        createRect: function(box, style) {
            return this.decorate(
                new SVGLine(box.points(), true, style)
            );
        },

        createLine: function(x1, y1, x2, y2, options) {
            return this.decorate(
                new SVGLine([new Point2D(x1, y1),
                             new Point2D(x2, y2)], false, options)
            );
        },

        createPolyline: function(points, closed, options) {
            return this.decorate(
                new SVGLine(points, closed, options)
            );
        },

        createCircle: function(center, radius, options) {
            return this.decorate(
                new SVGCircle(center, radius, options)
            );
        },

        createSector: function(sector, options) {
            return this.decorate(
                new SVGSector(sector, options)
            );
        },

        createGradient: function(options) {
            if (options.type === RADIAL) {
                return new SVGRadialGradient(options);
            } else {
                return new SVGLinearGradient(options)
            }
        },

        alignToScreen: function(element) {
            try {
                var ctm = element.getScreenCTM ? element.getScreenCTM() : null;
            } catch (e) { }

            if (ctm) {
                var left = - ctm.e % 1,
                    top = - ctm.f % 1,
                    style = element.style;

                if (left !== 0 || top !== 0) {
                    style.left = left + "px";
                    style.top = top + "px";
                }
            }
        }
    });

    SVGView.fromModel = function(model) {
        var view = new SVGView(model.options);
        [].push.apply(view.children, model.getViewElements(view));

        return view;
    }

    // Primitives =============================================================
    var SVGText = ViewElement.extend({
        init: function(content, options) {
            var text = this;
            ViewElement.fn.init.call(text, options);

            text.content = content;
            text.template = SVGText.template;
            if (!text.template) {
                text.template = SVGText.template = template(
                    "<text #= d.renderAttr(\"id\", d.options.id) # " +
                    "x='#= Math.round(d.options.x) #' " +
                    "y='#= Math.round(d.options.y + d.options.baseline) #' " +
                    "fill-opacity='#= d.options.fillOpacity #' " +
                    "#= d.options.rotation ? d.renderRotation() : '' # " +
                    "style='font: #= d.options.font #' fill='#= d.options.color #'>" +
                    "#= d.content #</text>"
                );
            }
        },

        options: {
            x: 0,
            y: 0,
            baseline: 0,
            font: DEFAULT_FONT,
            size: {
                width: 0,
                height: 0
            },
            fillOpacity: 1
        },

        refresh: function(domElement) {
            var options = this.options;

            $(domElement).attr({
                "fill-opacity": options.fillOpacity
            });
        },

        clone: function() {
            var text = this;
            return new SVGText(text.content, deepExtend({}, text.options));
        },

        renderRotation: function() {
            var text = this,
                options = text.options,
                size = options.size,
                cx = round(options.x + size.normalWidth / 2, COORD_PRECISION),
                cy = round(options.y + size.normalHeight / 2, COORD_PRECISION),
                rcx = round(options.x + size.width / 2, COORD_PRECISION),
                rcy = round(options.y + size.height / 2, COORD_PRECISION),
                offsetX = round(rcx - cx, COORD_PRECISION),
                offsetY = round(rcy - cy, COORD_PRECISION);

            return "transform='translate(" + offsetX + "," + offsetY + ") " +
                   "rotate(" + options.rotation + "," + cx + "," + cy + ")'";
        }
    });

    var SVGPath = ViewElement.extend({
        init: function(options) {
            var path = this;
            ViewElement.fn.init.call(path, options);

            path.template = SVGPath.template;
            if (!path.template) {
                path.template = SVGPath.template = template(
                    "<path #= d.renderAttr(\"id\", d.options.id) #" +
                    "d='#= d.renderPoints() #' " +
                    "#= d.renderAttr(\"stroke\", d.options.stroke) # " +
                    "#= d.renderAttr(\"stroke-width\", d.options.strokeWidth) #" +
                    "#= d.renderDashType() # " +
                    "stroke-linecap='#= d.renderLinecap() #' " +
                    "stroke-linejoin='round' " +
                    "fill-opacity='#= d.options.fillOpacity #' " +
                    "stroke-opacity='#= d.options.strokeOpacity #' " +
                    "fill='#= d.renderFill() #'></path>"
                );
            }
        },

        options: {
            fill: "",
            fillOpacity: 1,
            strokeOpacity: 1
        },

        refresh: function(domElement) {
            var options = this.options;

            $(domElement).attr({
                "d": this.renderPoints(),
                "fill-opacity": options.fillOpacity,
                "stroke-opacity": options.strokeOpacity
            });
        },

        clone: function() {
            var path = this;
            return new SVGPath(deepExtend({}, path.options));
        },

        renderPoints: function() {
            // Overriden by inheritors
        },

        renderDashType: function () {
            var path = this,
                options = path.options;

            return renderSVGDash(options.dashType, options.strokeWidth);
        },

        renderLinecap: function() {
            var dashType = this.options.dashType;

            return (dashType && dashType != "solid") ? "butt" : "square";
        },

        renderFill: function() {
            var fill = this.options.fill;
	
            if (fill && fill !== TRANSPARENT) {
                return fill;
            }
	
            return NONE;
        }
    });

    var SVGLine = SVGPath.extend({
        init: function(points, closed, options) {
            var line = this;
            SVGPath.fn.init.call(line, options);

            line.points = points;
            line.closed = closed;
        },

        renderPoints: function() {
            var line = this,
                points = line.points,
                i,
                count = points.length,
                first = points[0],
                result = "M" + line._print(first);

            for (i = 1; i < count; i++) {
                result += " " + line._print(points[i]);
            }

            if (line.closed) {
                result += " z";
            }

            return result;
        },

        clone: function() {
            var line = this;
            return new SVGLine(
                deepExtend([], line.points), line.closed,
                deepExtend({}, line.options)
            );
        },

        _print: function(point) {
            var line = this,
                strokeWidth = line.options.strokeWidth,
                shouldAlign = strokeWidth && strokeWidth % 2 !== 0,
                align = shouldAlign ? alignToPixel : math.round;

            return align(point.x) + " " + align(point.y);
        }
    });

    var SVGSector = SVGPath.extend({
        init: function(circleSector, options) {
            var sector = this;
            SVGPath.fn.init.call(sector, options);

            sector.pathTemplate = SVGSector.pathTemplate;
            if (!sector.pathTemplate) {
                sector.pathTemplate = SVGSector.pathTemplate = template(
                    "M #= d.firstPoint.x # #= d.firstPoint.y # " +
                    "A#= d.r # #= d.r # " +
                    "0 #= d.isReflexAngle ? '1' : '0' #,1 " +
                    "#= d.secondPoint.x # #= d.secondPoint.y # " +
                    "L #= d.cx # #= d.cy # z"
                );
            }

            sector.circleSector = circleSector || {};
        },

        options: {
            fill: "",
            fillOpacity: 1,
            strokeOpacity: 1,
            strokeLineCap: SQUARE
        },

        clone: function() {
            var sector = this;
            return new SVGSector(
                deepExtend({}, sector.circleSector),
                deepExtend({}, sector.options)
            );
        },

        renderPoints: function() {
            var sector = this,
                circleSector = sector.circleSector,
                startAngle = circleSector.startAngle,
                endAngle = circleSector.angle + startAngle,
                endAngle = (endAngle - startAngle) == 360 ? endAngle - 0.001 : endAngle,
                isReflexAngle = (endAngle - startAngle) > 180,
                r = math.max(circleSector.r, 0),
                cx = circleSector.c.x,
                cy = circleSector.c.y,
                firstPoint = circleSector.point(startAngle),
                secondPoint = circleSector.point(endAngle);

            return sector.pathTemplate({
                firstPoint: firstPoint,
                secondPoint: secondPoint,
                isReflexAngle: isReflexAngle,
                r: r,
                cx: cx,
                cy: cy
            });
        }
    });

    var SVGCircle = ViewElement.extend({
        init: function(center, radius, options) {
            var circle = this;
            ViewElement.fn.init.call(circle, options);

            circle.center = center;
            circle.radius = radius;

            circle.template = SVGCircle.template;
            if (!circle.template) {
                circle.template = SVGCircle.template = template(
                    "<circle #= d.renderAttr(\"id\", d.options.id) # " +
                    "cx='#= d.center[0] #' cy='#= d.center[1] #' " +
                    "r='#= d.radius #' " +
                    "#= d.renderAttr(\"stroke\", d.options.stroke) # " +
                    "#= d.renderAttr(\"stroke-width\", d.options.strokeWidth) #" +
                    "fill-opacity='#= d.options.fillOpacity #' " +
                    "stroke-opacity='#= d.options.strokeOpacity #'  " +
                    "fill='#= d.options.fill || \"none\" #'></circle>"
                );
            }
        },

        options: {
            fill: "",
            fillOpacity: 1,
            strokeOpacity: 1
        }
    });

    var SVGGroup = ViewElement.extend({
        init: function(options) {
            var group = this;
            ViewElement.fn.init.call(group, options);

            group.template = SVGGroup.template;
            if (!group.template) {
                group.template = SVGGroup.template =
                template("<g#= d.renderAttr(\"id\", d.options.id) #" +
                           "#= d.renderAttr(\"clip-path\", d.options.clipPath) #>" +
                         "#= d.renderContent() #</g>");
            }
        }
    });

    var SVGClipPath = ViewElement.extend({
        init: function(options) {
            var clip = this;
            ViewElement.fn.init.call(clip, options);

            clip.template = SVGClipPath.template;
            if (!clip.template) {
                clip.template = SVGClipPath.template =
                template("<clipPath#= d.renderAttr(\"id\", d.options.id) #>" +
                         "#= d.renderContent() #</clipPath>");
            }
        }
    });

    var SVGLinearGradient = ViewElement.extend({
        init: function(options) {
            var gradient = this;
            ViewElement.fn.init.call(gradient, options);

            gradient.template = SVGLinearGradient.template;
            gradient.stopTemplate = SVGLinearGradient.stopTemplate;
            if (!gradient.template) {
                gradient.template = SVGLinearGradient.template = template(
                    "<linearGradient id='#= d.options.id #' " +
                    "gradientTransform='rotate(#= d.options.rotation #)'> " +
                    "#= d.renderStops() #" +
                    "</linearGradient>"
                );

                gradient.stopTemplate = SVGLinearGradient.stopTemplate = template(
                    "<stop offset='#= Math.round(d.offset * 100) #%' " +
                    "style='stop-color:#= d.color #;stop-opacity:#= d.opacity #' />");
            }
        },

        options: {
            id: "",
            rotation: 0
        },

        renderStops: function() {
            var gradient = this,
                stops = gradient.options.stops,
                stopTemplate = gradient.stopTemplate,
                i,
                length = stops.length,
                currentStop,
                output = '';

            for (i = 0; i < length; i++) {
                currentStop = stops[i];
                output += stopTemplate(currentStop);
            }

            return output;
        }
    });

    var SVGRadialGradient = ViewElement.extend({
        init: function(options) {
            var gradient = this;

            ViewElement.fn.init.call(gradient, options);

            gradient.template = SVGRadialGradient.template;
            gradient.stopTemplate = SVGRadialGradient.stopTemplate;
            if (!gradient.template) {
                gradient.template = SVGRadialGradient.template = template(
                    "<radialGradient id='#= d.options.id #' " +
                    "cx='#= d.options.cx #' cy='#= d.options.cy #' " +
                    "fx='#= d.options.cx #' fy='#= d.options.cy #' " +
                    "r='#= d.options.r #' gradientUnits='userSpaceOnUse'>" +
                    "#= d.renderStops() #" +
                    "</radialGradient>"
                );

                gradient.stopTemplate = SVGRadialGradient.stopTemplate = template(
                    "<stop offset='#= Math.round(d.offset * 100) #%' " +
                    "style='stop-color:#= d.color #;stop-opacity:#= d.opacity #' />");
            }
        },

        options: {
            id: "",
            rotation: 0
        },

        renderStops: function() {
            var gradient = this,
                stops = gradient.options.stops,
                stopTemplate = gradient.stopTemplate,
                length = stops.length,
                currentStop,
                output = '',
                i;

            for (i = 0; i < length; i++) {
                currentStop = stops[i];
                output += stopTemplate(currentStop);
            }

            return output;
        }
    });

    // Decorators =============================================================
    function SVGOverlayDecorator(view) {
        this.view = view;
    }

    SVGOverlayDecorator.prototype = {
        decorate: function(element) {
            var decorator = this,
                view = decorator.view,
                options = element.options,
                id = options.id,
                group,
                overlay;

            if (options.overlay) {
                element.options.id = uniqueId();

                group = view.createGroup();
                overlay = element.clone();

                group.children.push(element, overlay);

                overlay.options.id = id;
                overlay.options.fill = options.overlay;

                return group;
            } else {
                return element;
            }
        }
    }

    function SVGGradientDecorator(view) {
        this.view = view;
    }

    SVGGradientDecorator.prototype = {
        decorate: function(element) {
            var decorator = this,
                options = element.options;

            options.fill = decorator.getPaint(options.fill);

            return element;
        },

        getPaint: function(paint) {
            var decorator = this,
                view = decorator.view,
                baseUrl = decorator.baseUrl(),
                definitions = view.definitions,
                overlay,
                overlayId,
                gradient;

            if (paint && defined(paint.gradient)) {
                overlay = view.buildGradient(paint);
                if (overlay) {
                    overlayId = overlay.id;
                    gradient = definitions[overlayId];
                    if (!gradient) {
                        gradient = view.createGradient(overlay);
                        definitions[overlayId] = gradient;
                    }

                    return "url(" + baseUrl + "#" + gradient.options.id + ")";
                } else {
                    return NONE;
                }
            } else {
                return paint;
            }
        },

        baseUrl: function() {
            var base = doc.getElementsByTagName("base")[0],
                baseUrl = "",
                href = doc.location.href,
                hashIndex = href.indexOf("#");
	
            if (base && !$.browser.msie) {
                if (hashIndex !== -1) {
                    href = href.substring(0, hashIndex);
                }
	
                baseUrl = href;
            }
            return baseUrl;
        }
    };

    var SVGClipAnimationDecorator = Class.extend({
        init: function(view) {
            this.view = view;
            this.clipId = uniqueId();
        },

        decorate: function(element) {
            var decorator = this,
                view = decorator.view,
                clipId = decorator.clipId,
                options = view.options,
                animation = element.options.animation,
                definitions = view.definitions,
                clipPath = definitions[clipId],
                clipRect;

            if (animation && animation.type === CLIP && options.transitions) {
                if (!clipPath) {
                    clipPath = new SVGClipPath({ id: clipId });
                    clipRect = view.createRect(
                        new Box2D(0, 0, options.width, options.height), { id: uniqueId() });
                    clipPath.children.push(clipRect);
                    definitions[clipId] = clipPath;

                    view.animations.push(
                        new ExpandAnimation(clipRect, { size: options.width })
                    );
                }

                element.options.clipPath = "url(#" + clipId + ")";
            }

            return element;
        }
    });

    // Helpers ================================================================
    function alignToPixel(coord) {
        return math.round(coord) + 0.5;
    }

    function renderSVGDash(dashType, strokeWidth) {
        var result = [],
            dashType = dashType ? dashType.toLowerCase() : null,
            dashTypeArray,
            i;

        if (dashType && dashType != "solid" && strokeWidth) {
            dashTypeArray = SVG_DASH_TYPE[dashType];
            for (i = 0; i < dashTypeArray.length; i++) {
                result.push(dashTypeArray[i] * strokeWidth);
            }

            return "stroke-dasharray='" + result.join(" ") + "' ";
        }

        return "";
    }

    function renderSVG(container, svg) {
        container.innerHTML = svg;
    }

    (function() {
        var testFragment = "<svg xmlns='" + SVG_NS + "'></svg>",
            testContainer = doc.createElement("div"),
            hasParser = typeof DOMParser != UNDEFINED;

        testContainer.innerHTML = testFragment;

        if (hasParser && testContainer.firstChild.namespaceURI != SVG_NS) {
            renderSVG = function(container, svg) {
                var parser = new DOMParser(),
                    chartDoc = parser.parseFromString(svg, "text/xml"),
                    importedDoc = doc.adoptNode(chartDoc.documentElement);

                container.innerHTML = "";
                container.appendChild(importedDoc);
            };
        }
    })();

    // Exports ================================================================
    deepExtend(Chart, {
        SVGView: SVGView,
        SVGText: SVGText,
        SVGPath: SVGPath,
        SVGLine: SVGLine,
        SVGSector: SVGSector,
        SVGCircle: SVGCircle,
        SVGGroup: SVGGroup,
        SVGClipPath: SVGClipPath,
        SVGLinearGradient: SVGLinearGradient,
        SVGRadialGradient: SVGRadialGradient,
        SVGOverlayDecorator: SVGOverlayDecorator,
        SVGGradientDecorator: SVGGradientDecorator,
        SVGClipAnimationDecorator: SVGClipAnimationDecorator
    });

})(jQuery);
(function () {

    // Imports ================================================================
    var $ = jQuery,
        $t = $.telerik,
        Class = $t.Class,
        Chart = $t.chart.Chart,
        Color = Chart.Color,
        Box2D = Chart.Box2D,
        Point2D = Chart.Point2D,
        BarAnimationDecorator = Chart.BarAnimationDecorator,
        PieAnimationDecorator = Chart.PieAnimationDecorator,
        FadeAnimationDecorator = Chart.FadeAnimationDecorator,
        ExpandAnimation = Chart.ExpandAnimation,
        ViewBase = Chart.ViewBase,
        ViewElement = Chart.ViewElement,
        deepExtend = Chart.deepExtend,
        template = Chart.template,
        uniqueId = Chart.uniqueId,
        rotatePoint = Chart.rotatePoint,
        round = Chart.round,
        supportsSVG = Chart.supportsSVG,
        doc = document,
        math = Math;

    // Constants ==============================================================
    var BLACK = "#000",
        CLIP = Chart.CLIP,
        DEFAULT_WIDTH = Chart.DEFAULT_WIDTH,
        DEFAULT_HEIGHT = Chart.DEFAULT_HEIGHT,
        DEFAULT_FONT = Chart.DEFAULT_FONT,
        OBJECT = "object",
        RADIAL = "radial",
        TRANSPARENT = "transparent";

    // View ===================================================================
    var VMLView = ViewBase.extend({
        init: function(options) {
            var view = this;
            ViewBase.fn.init.call(view, options);

            view.decorators.push(
                new VMLOverlayDecorator(view),
                new VMLGradientDecorator(view),
                new BarAnimationDecorator(view),
                new PieAnimationDecorator(view),
                new VMLClipAnimationDecorator(view)
            );

            if (!isIE9CompatibilityView()) {
                // Setting opacity on VML elements is broken in
                // IE9 Compatibility View
                view.decorators.push(
                    new FadeAnimationDecorator(view)
                );
            }

            view.template = VMLView.template;
            if (!view.template) {
                view.template = VMLView.template = template(
                    "<div style='width:#= d.options.width #px; " +
                    "height:#= d.options.height #px; " +
                    "position: relative;'>" +
                    "#= d.renderContent() #</div>"
                );
            }
        },

        options: {
            width: DEFAULT_WIDTH,
            height: DEFAULT_HEIGHT
        },

        renderTo: function(container) {
            var view = this;

            if (doc.namespaces) {
                doc.namespaces.add("kvml", "urn:schemas-microsoft-com:vml", "#default#VML");
            }

            view.setupAnimations();
            container.innerHTML = view.render();
            view.playAnimations();

            return container.firstChild;
        },

        renderElement: function(element) {
            var container = doc.createElement("div"),
                element;

            container.style.display = "none";
            doc.body.appendChild(container);
            container.innerHTML = element.render();

            element = container.firstChild;
            doc.body.removeChild(container);

            return element;
        },

        createText: function(content, options) {
            return this.decorate(
                (options && options.rotation) ?
                    new VMLRotatedText(content, options) :
                    new VMLText(content, options)
            );
        },

        createRect: function(box, style) {
            return this.decorate(
                new VMLLine(box.points(), true, style)
            );
        },

        createLine: function(x1, y1, x2, y2, options) {
            return this.decorate(
                new VMLLine([new Point2D(x1, y1),
                    new Point2D(x2, y2)], false, options)
            );
        },

        createPolyline: function(points, closed, options) {
            return this.decorate(
                new VMLLine(points, closed, options)
            );
        },

        createCircle: function(center, radius, options) {
            return this.decorate(
                new VMLCircle(center, radius, options)
            );
        },

        createSector: function(sector, options) {
            return this.decorate(
                new VMLSector(sector, options)
            );
        },

        createGroup: function(options) {
            return this.decorate(
                new VMLGroup(options)
            );
        },

        createGradient: function(options) {
            return new VMLLinearGradient(options);
        }
    });

    VMLView.fromModel = function(model) {
        var view = new VMLView(model.options);
        [].push.apply(view.children, model.getViewElements(view));

        return view;
    }

    // Primitives =============================================================
    var VMLText = ViewElement.extend({
        init: function(content, options) {
            var text = this;
            ViewElement.fn.init.call(text, options);

            text.content = content;
            text.template = VMLText.template;
            if (!text.template) {
                text.template = VMLText.template = template(
                    "<kvml:textbox #= d.renderAttr(\"id\", d.options.id) # " +
                    "style='position: absolute; " +
                    "left: #= d.options.x #px; top: #= d.options.y #px; " +
                    "font: #= d.options.font #; color: #= d.options.color #; " +
                    "visibility: #= d.renderVisibility() #; white-space: nowrap;'>" +
                    "#= d.content #</kvml:textbox>"
                );
            }
        },

        options: {
            x: 0,
            y: 0,
            font: DEFAULT_FONT,
            color: BLACK,
            fillOpacity: 1
        },

        refresh: function(domElement) {
            $(domElement).css("visibility", this.renderVisibility());
        },

        clone: function() {
            var text = this;
            return new VMLText(text.content, deepExtend({}, text.options));
        },

        renderVisibility: function() {
            return this.options.fillOpacity > 0 ? "visible" : "hidden";
        }
    });

    var VMLRotatedText = ViewElement.extend({
        init: function(content, options) {
            var text = this;
            ViewElement.fn.init.call(text, options);

            text.content = content;
            text.template = VMLRotatedText.template;
            if (!text.template) {
                text.template = VMLRotatedText.template = template(
                    "<kvml:shape #= d.renderAttr(\"id\", d.options.id) # " +
                    "style='position: absolute; top: 0px; left: 0px; " +
                    "width: 1px; height: 1px;' stroked='false' coordsize='1,1'>" +
                    "#= d.renderPath() #" +
                    "<kvml:fill color='#= d.options.color #' />" +
                    "<kvml:textpath on='true' style='font: #= d.options.font #;' " +
                    "fitpath='false' string='#= d.content #' /></kvml:shape>"
                );
            }
        },

        options: {
            x: 0,
            y: 0,
            font: DEFAULT_FONT,
            color: BLACK,
            size: {
                width: 0,
                height: 0
            }
        },

        renderPath: function() {
            var text = this,
                options = text.options,
                width = options.size.width,
                height = options.size.height,
                cx = options.x + width / 2,
                cy = options.y + height / 2,
                angle = -options.rotation,
                r1 = rotatePoint(options.x, cy, cx, cy, angle),
                r2 = rotatePoint(options.x + width, cy, cx, cy, angle);

            return "<kvml:path textpathok='true' " +
                   "v='m " + round(r1.x) + "," + round(r1.y) +
                   " l " + round(r2.x) + "," + round(r2.y) +
                   "' />";
        }
    });

    var VMLStroke = ViewElement.extend({
        init: function(options) {
            var stroke = this;
            ViewElement.fn.init.call(stroke, options);

            stroke.template = VMLStroke.template;
            if (!stroke.template) {
                stroke.template = VMLStroke.template = template(
                    "<kvml:stroke on='#= !!d.options.stroke #' " +
                    "#= d.renderAttr(\"color\", d.options.stroke) #" +
                    "#= d.renderAttr(\"weight\", d.options.strokeWidth) #" +
                    "#= d.renderAttr(\"dashstyle\", d.options.dashType) #" +
                    "#= d.renderAttr(\"opacity\", d.options.strokeOpacity) # />"
                );
            }
        }
    });

    var VMLFill = ViewElement.extend({
        init: function(options) {
            var stroke = this;
            ViewElement.fn.init.call(stroke, options);

            stroke.template = VMLFill.template;
            if (!stroke.template) {
                stroke.template = VMLFill.template = template(
                    "<kvml:fill on='#= d.isEnabled() #' " +
                    "#= d.renderAttr(\"color\", d.options.fill) #" +
                    "#= d.renderAttr(\"weight\", d.options.fillWidth) #" +
                    "#= d.renderAttr(\"opacity\", d.options.fillOpacity) # />"
                );
            }
        },

        isEnabled: function() {
            var fill = this.options.fill;
            return !!fill && fill.toLowerCase() !== TRANSPARENT;
        }
    });

    var VMLPath = ViewElement.extend({
        init: function(options) {
            var path = this;
            ViewElement.fn.init.call(path, options);

            path.template = VMLPath.template;
            if (!path.template) {
                path.template = VMLPath.template = template(
                    "<kvml:shape #= d.renderAttr(\"id\", d.options.id) # " +
                    "style='position:absolute; width:1px; height:1px;' " +
                    "coordorigin='0 0' coordsize='1 1'>" +
                        "<kvml:path v='#= d.renderPoints() # e' />" +
                        "#= d.fill.render() + d.stroke.render() #" +
                    "</kvml:shape>"
                );
            }

            path.stroke = new VMLStroke(path.options);
            path.fill = new VMLFill(path.options);
        },

        options: {
            fill: "",
            fillOpacity: 1,
            strokeOpacity: 1
        },

        render: function() {
            var path = this;
            path.fill.options.fillOpacity = path.options.fillOpacity;
            path.stroke.options.strokeOpacity = path.options.strokeOpacity;

            return ViewElement.fn.render.call(path);
        },

        renderPoints: function() {
            // Overriden by inheritors
        },

        refresh: function(domElement) {
            var path = this,
                options = path.options,
                element = $(domElement),
                parentNode = element[0].parentNode;

            if (parentNode) {
                element.find("path")[0].v = this.renderPoints();
                try {
                    element.find("fill")[0].opacity = options.fillOpacity;
                    element.find("stroke")[0].opacity = options.strokeOpacity;
                } catch(e) {
                    // Random exceptions in IE 8 Compatibility View
                }

                // Force redraw in order to remove artifacts in IE < 7
                parentNode.style.cssText = parentNode.style.cssText;
            }
        }
    });

    var VMLLine = VMLPath.extend({
        init: function(points, closed, options) {
            var line = this;
            VMLPath.fn.init.call(line, options);

            line.points = points;
            line.closed = closed;
        },

        renderPoints: function() {
            var line = this,
                points = line.points,
                i,
                count = points.length,
                result = "m " + line._print(points[0]);

            if (count > 1) {
                result += " l ";

                for (i = 1; i < count; i++) {
                    result += line._print(points[i]);

                    if (i < count - 1) {
                        result += ", ";
                    }
                }
            }

            if (line.closed) {
                result += " x";
            }

            return result;
        },

        clone: function() {
            var line = this;
            return new VMLLine(
                deepExtend([], line.points), line.closed,
                deepExtend({}, line.options)
            );
        },

        _print: function(point) {
            return math.round(point.x) + "," + math.round(point.y);
        }
    });

    var VMLSector = VMLPath.extend({
        init: function(circleSector, options) {
            var sector = this;
            VMLPath.fn.init.call(sector, options);

            sector.pathTemplate = VMLSector.pathTemplate;
            if (!sector.pathTemplate) {
                sector.pathTemplate = VMLSector.pathTemplate = template(
                   "M #= d.cx # #= d.cy # " +
                   "AE #= d.cx # #= d.cy # " +
                   "#= d.r # #= d.r # " +
                   "#= d.sa # #= d.a # X E"
                );
            }

            sector.circleSector = circleSector;
        },

        renderPoints: function() {
            var sector = this,
                circleSector = sector.circleSector,
                r = math.max(round(circleSector.r), 0),
                cx = round(circleSector.c.x),
                cy = round(circleSector.c.y),
                sa = -round((circleSector.startAngle + 180) * 65535),
                a = -round(circleSector.angle * 65536);

            return sector.pathTemplate({ r: r, cx: cx, cy: cy, sa: sa, a: a });
        },

        clone: function() {
            var sector = this;
            return new VMLSector(
                deepExtend({}, sector.circleSector),
                deepExtend({}, sector.options)
            );
        }
    });

    var VMLCircle = ViewElement.extend({
        init: function(center, radius, options) {
            var circle = this;
            ViewElement.fn.init.call(circle, options);

            circle.center = center;
            circle.radius = radius;

            circle.template = VMLCircle.template;
            if (!circle.template) {
                circle.template = VMLCircle.template = template(
                    "<kvml:oval #= d.renderAttr(\"id\", d.options.id) # " +
                            "style='position:absolute; " +
                            "width:#= d.radius * 2 #px; height:#= d.radius * 2 #px; " +
                            "top:#= d.center[1] - d.radius #px; " +
                            "left:#= d.center[0] - d.radius #px;'>" +
                        "#= d.fill.render() + d.stroke.render() #" +
                    "</kvml:oval>"
                );
            }

            circle.stroke = new VMLStroke(circle.options);
            circle.fill = new VMLFill(circle.options);
        },

        options: {
            fill: ""
        }
    });

    var VMLGroup = ViewElement.extend({
        init: function(options) {
            var group = this;
            ViewElement.fn.init.call(group, options);

            group.template = VMLGroup.template;
            if (!group.template) {
                group.template = VMLGroup.template = template(
                    "<div #= d.renderAttr(\"id\", d.options.id) #" +
                    "style='position: absolute; white-space: nowrap;'>" +
                    "#= d.renderContent() #</div>"
                );
            }
        }
    });

    var VMLClipRect = ViewElement.extend({
        init: function(box, options) {
            var clipRect = this;
            ViewElement.fn.init.call(clipRect, options);

            clipRect.template = VMLClipRect.template;
            clipRect.clipTemplate = VMLClipRect.clipTemplate;
            if (!clipRect.template) {
                clipRect.template = VMLClipRect.template = template(
                    "<div #= d.renderAttr(\"id\", d.options.id) #" +
                        "style='position:absolute; " +
                        "width:#= d.box.width() #px; height:#= d.box.height() #px; " +
                        "top:#= d.box.y1 #px; " +
                        "left:#= d.box.x1 #px; " +
                        "clip:#= d._renderClip() #;' >" +
                    "#= d.renderContent() #</div>"
                );

                clipRect.clipTemplate = VMLClipRect.clipTemplate = template(
                    "rect(#= d.points[0].y #px #= d.points[1].x #px " +
                         "#= d.points[2].y #px #= d.points[0].x #px)"
                );
            }

            clipRect.box = box;

            // Points defining the clipping rectangle
            clipRect.points = box.points();
        },

        clone: function() {
            var clipRect = this;
            return new VMLClipRect(
                clipRect.box, deepExtend({}, clipRect.options)
            );
        },

        refresh: function(domElement) {
            domElement.style.clip = this._renderClip();
        },

        _renderClip: function() {
            return this.clipTemplate(this);
        }
    });

    var VMLLinearGradient = ViewElement.extend({
        init: function(options) {
            var gradient = this;
            ViewElement.fn.init.call(gradient, options);

            gradient.template = VMLLinearGradient.template;
            if (!gradient.template) {
                gradient.template = VMLLinearGradient.template = template(
                    "<kvml:fill type='gradient' angle='#= 270 - d.options.rotation #' " +
                    "colors='#= d.renderColors() #' opacity='#= d.options.opacity #' />"
                );
            }
        },

        options: {
            rotation: 0,
            opacity: 1
        },

        renderColors: function() {
            var gradient = this,
                options = gradient.options,
                stops = options.stops,
                currentStop,
                i,
                length = stops.length,
                output = [],
                round = math.round;

            for (i = 0; i < length; i++) {
                currentStop = stops[i];
                output.push(
                    round(currentStop.offset * 100) + "% " +
                    currentStop.color
                );
            }

            return output.join(",");
        }
    });

    // Decorators =============================================================
    function VMLOverlayDecorator(view) {
        this.view = view;
    }

    VMLOverlayDecorator.prototype = {
        decorate: function(element) {
            var options = element.options,
                view = this.view,
                overlay;

            if (options.overlay) {
                overlay = view.buildGradient(
                    deepExtend({}, options.overlay, {
                        // Make the gradient definition unique for this color
                        _overlayFill: options.fill
                    })
                );
            }

            if (!overlay || overlay.type === RADIAL) {
                return element;
            }

            delete options.overlay;
            options.fill = deepExtend(
                blendGradient(options.fill, overlay),
                { opacity: options.fillOpacity }
            );

            return element;
        }
    };

    function VMLGradientDecorator(view) {
        this.view = view;
    }

    VMLGradientDecorator.prototype = {
        decorate: function(element) {
            var decorator = this,
                view = decorator.view,
                options = element.options,
                fill = options.fill;

            if (fill) {
                if (fill.gradient) {
                    fill = view.buildGradient(fill);
                }

                if (typeof fill === OBJECT) {
                    element.fill = view.createGradient(fill);
                }
            }

            return element;
        }
    };

    var VMLClipAnimationDecorator = Class.extend({
        init: function(view) {
            this.view = view;
        },

        decorate: function(element) {
            var decorator = this,
                view = decorator.view,
                options = view.options,
                animation = element.options.animation,
                clipRect;

            if (animation && animation.type === CLIP && options.transitions) {
                clipRect = new VMLClipRect(
                    new Box2D(0, 0, options.width, options.height),
                    { id: uniqueId() }
                );

                view.animations.push(
                    new ExpandAnimation(clipRect, { size: options.width })
                );

                clipRect.children.push(element);

                return clipRect;
            } else {
                return element;
            }
        }
    });

    // Helpers ================================================================
    function isIE9CompatibilityView() {
        return $.browser.msie && !supportsSVG() && typeof window.performance !== "undefined";
    }

    function blendColors(base, overlay, alpha) {
        var baseColor = new Color(base),
            overlayColor = new Color(overlay),
            r = blendChannel(baseColor.r, overlayColor.r, alpha),
            g = blendChannel(baseColor.g, overlayColor.g, alpha),
            b = blendChannel(baseColor.b, overlayColor.b, alpha);

        return new Color(r, g, b).toHex();
    }

    function blendChannel(a, b, alpha) {
        return math.round(alpha * b + (1 - alpha) * a);
    }

    function blendGradient(color, gradient) {
        var srcStops = gradient.stops,
            stopsLength = srcStops.length,
            result = deepExtend({}, gradient),
            i,
            stop,
            resultStop;

        result.stops = [];

        for (i = 0; i < stopsLength; i++) {
            stop = srcStops[i];
            resultStop = result.stops[i] = deepExtend({}, srcStops[i]);
            resultStop.color = blendColors(color, stop.color, stop.opacity);
            resultStop.opacity = 0;
        }

        return result;
    }

    // Exports ================================================================
    deepExtend(Chart, {
        VMLView: VMLView,
        VMLText: VMLText,
        VMLRotatedText: VMLRotatedText,
        VMLStroke: VMLStroke,
        VMLFill: VMLFill,
        VMLPath: VMLPath,
        VMLLine: VMLLine,
        VMLSector: VMLSector,
        VMLCircle: VMLCircle,
        VMLGroup: VMLGroup,
        VMLClipRect: VMLClipRect,
        VMLLinearGradient: VMLLinearGradient,
        VMLOverlayDecorator: VMLOverlayDecorator,
        VMLClipAnimationDecorator: VMLClipAnimationDecorator,
        blendColors: blendColors,
        blendGradient: blendGradient
    });

})(jQuery);
(function () {

    // Imports ================================================================
    var $t = $.telerik,
        Chart = $t.chart.Chart,
        deepExtend = Chart.deepExtend;

    // Constants ==============================================================
    var BLACK = "#000",
        WHITE = "#fff",
        SANS = "Arial,Helvetica,sans-serif",
        SANS11 = "11px " + SANS,
        SANS12 = "12px " + SANS,
        SANS16 = "16px " + SANS,
        NO_OVERLAY = {
            overlay: null
        };

    // Themes =================================================================
    var baseTheme = {
            title: {
                font: SANS16
            },
            legend: {
                labels: {
                    font: SANS12
                }
            },
            seriesDefaults: {
                labels: {
                    font: SANS11
                },
                area: {
                    opacity: 0.4,
                    markers: {
                        size: 6,
                        visible: false
                    }
                },
                verticalArea: {
                    opacity: 0.4,
                    markers: {
                        size: 6,
                        visible: false
                    }
                }
            },
            axisDefaults: {
                labels: {
                    font: SANS12
                },
                title: {
                    font: SANS16,
                    margin: 5
                }
            },
            tooltip: {
                font: SANS12
            }
        };

    var themes = { };
    themes.black = deepExtend({}, baseTheme, {
        title: {
            color: WHITE
        },
        legend: {
            labels: {
                color: WHITE
            }
        },
        seriesDefaults: {
            labels: {
                color: WHITE
            },
            line: {
                markers: {
                    background: "#3d3d3d"
                }
            },
            verticalLine: {
                markers: {
                    background: "#3d3d3d"
                }
            },
            scatter: {
                markers: {
                    background: "#3d3d3d"
                }
            },
            scatterLine: {
                markers: {
                    background: "#3d3d3d"
                }
            }
        },
        chartArea: {
            background: ""
        },
        seriesColors: ["#f9a319", "#1edee2", "#9eda29", "#ffce00", "#dd007f"],
        categoryAxis: {
            majorGridLines: {
                visible: true
            }
        },
        axisDefaults: {
            line: {
                color: "#919191"
            },
            labels: {
                color: WHITE
            },
            majorGridLines: {
                color: "#636363"
            },
            minorGridLines: {
                color: "#464646"
            },
            title: {
                color: WHITE
            }
        }
    });

    themes["default"] = deepExtend({}, baseTheme, {
        chartArea: {
            background: ""
        },
        seriesColors: ["#f6921e", "#d6de23", "#8bc53f", "#26a9e0", "#9e1f63"],
        categoryAxis: {
            majorGridLines: {
                visible: true
            }
        },
        axisDefaults: {
            majorGridLines: {
                color: "#aaaaaa"
            },
            minorGridLines: {
                color: "#cccccc"
            },
            line: {
                color: "#828282"
            }
        },
        tooltip: {
            background: WHITE,
            color: BLACK
        }
    });

    themes.forest = deepExtend({}, baseTheme, {
        title: {
            color: "#3c4c30"
        },
        legend: {
            labels: {
                color: "#3c4c30"
            }
        },
        seriesDefaults: {
            labels: {
                color: "#3c4c30"
            },
            verticalLine: {
                markers: {
                    background: "#d3e0c2"
                }
            },
            line: {
                markers: {
                    background: "#d3e0c2"
                }
            },
            scatter: {
                markers: {
                    background: "#d3e0c2"
                }
            },
            scatterLine: {
                markers: {
                    background: "#d3e0c2"
                }
            }
        },
        chartArea: {
            background: ""
        },
        seriesColors: ["#4d7924", "#6dba3a", "#efab22", "#f05a28", "#603813"],
        categoryAxis: {
            majorGridLines: {
                visible: true
            }
        },
        axisDefaults: {
            majorGridLines: {
                color: "#a7bc75"
            },
            minorGridLines: {
                color: "#cad7ac"
            },
            line: {
                color: "#5a8533"
            },
            labels: {
                color: "#3c4c30"
            },
            title: {
                color: "#3c4c30"
            }
        },
        tooltip: {
            background: "#D3E0C2",
            color: BLACK
        }
    });

    themes.hay = deepExtend({}, baseTheme, {
        title: {
            color: "#3c4c30"
        },
        legend: {
            labels: {
                color: "#3c4c30"
            }
        },
        seriesDefaults: {
            labels: {
                color: "#3c4c30"
            }
        },
        chartArea: {
            background: ""
        },
        seriesColors: ["#205b02", "#61c407", "#9cd65f", "#bbbe94", "#323323"],
        categoryAxis: {
            majorGridLines: {
                visible: true
            }
        },
        axisDefaults: {
            majorGridLines: {
                color: "#bfbdac"
            },
            minorGridLines: {
                color: "#d9d7cd"
            },
            line: {
                color: "#898772"
            },
            labels: {
                color: "#3c4c30"
            },
            title: {
                color: "#3c4c30"
            }
        },
        tooltip: {
            background: WHITE,
            color: BLACK
        }
    });

    themes.metro = deepExtend({}, baseTheme, {
        seriesDefaults: {
            bar: NO_OVERLAY,
            pie: NO_OVERLAY,
            column: NO_OVERLAY,
            pie: NO_OVERLAY
        },
        chartArea: {
            background: ""
        },
        seriesColors: ["#25a0da", "#309b46", "#d8e404", "#e61e26", "#313131"],
        categoryAxis: {
            majorGridLines: {
                visible: true
            }
        },
        axisDefaults: {
            majorGridLines: {
                color: "#b4b4b4"
            },
            line: {
                color: "#b4b4b4"
            },
            minorGridLines: {
                color: "#d2d2d2"
            }
        },
        tooltip: {
            background: WHITE,
            color: BLACK
        }
    });

    themes.office2007 = deepExtend({}, baseTheme, {
        chartArea: {
            background: ""
        },
        seriesColors: ["#99c62a", "#27adcc", "#2477c9", "#7042b2", "#d83636"],
        categoryAxis: {
            majorGridLines: {
                visible: true
            }
        },
        axisDefaults: {
            majorGridLines: {
                color: "#bdcce2"
            },
            minorGridLines: {
                color: "#d7e0ee"
            },
            line: {
                color: "#688CAF"
            }
        },
        tooltip: {
            background: WHITE,
            color: BLACK
        }
    });

    themes.office2010black = deepExtend({}, baseTheme, {
        title: {
            color: WHITE
        },
        legend: {
            labels: {
                color: WHITE
            }
        },
        seriesDefaults: {
            labels: {
                color: WHITE
            },
            verticalLine: {
                markers: {
                    background: "#6f6f6f"
                }
            },
            line: {
                markers: {
                    background: "#6f6f6f"
                }
            },
            scatter: {
                markers: {
                    background: "#6f6f6f"
                }
            },
            scatterLine: {
                markers: {
                    background: "#6f6f6f"
                }
            }
        },
        chartArea: {
            background: ""
        },
        seriesColors: ["#99c62a", "#27adcc", "#2477c9", "#7042b2", "#d83636"],
        categoryAxis: {
            majorGridLines: {
                visible: true
            }
        },
        axisDefaults: {
            line: {
                color: "#999999"
            },
            labels: {
                color: WHITE
            },
            majorGridLines: {
                color: "#888888"
            },
            minorGridLines: {
                color: "#7c7c7c"
            },
            title: {
                color: WHITE
            }
        },
        tooltip: {
            background: "#6F6F6F",
            color: WHITE
        }
    });

    themes.office2010blue = deepExtend({}, baseTheme, {
        title: {
            color: "#384E73"
        },
        legend: {
            labels: {
                color: "#384E73"
            }
        },
        chartArea: {
            background: ""
        },
        seriesDefaults: {
            labels: {
                color: "#384E73"
            }
        },
        seriesColors: ["#99c62a", "#27adcc", "#2477c9", "#7042b2", "#d83636"],
        categoryAxis: {
            majorGridLines: {
                visible: true
            }
        },
        axisDefaults: {
            line: {
                color: "#8ba0bc"
            },
            labels: {
                color: "#384e73"
            },
            majorGridLines: {
                color: "#d1dbe5"
            },
            minorGridLines: {
                color: "#e3e9ef"
            },
            title: {
                color: "#384e73"
            }
        },
        tooltip: {
            background: WHITE,
            color: BLACK
        }
    });

    themes.office2010silver = deepExtend({}, baseTheme, {
        title: {
            color: "#3b3b3b"
        },
        legend: {
            labels: {
                color: "#3b3b3b"
            }
        },
        chartArea: {
            background: ""
        },
        seriesDefaults: {
            labels: {
                color: "#3b3b3b"
            }
        },
        seriesColors: ["#99c62a", "#27adcc", "#2477c9", "#7042b2", "#d83636"],
        categoryAxis: {
            majorGridLines: {
                visible: true
            }
        },
        axisDefaults: {
            line: {
                color: "#a4abb2"
            },
            labels: {
                color: "#3b3b3b"
            },
            majorGridLines: {
                color: "#dbdfe4"
            },
            minorGridLines: {
                color: "#e9ecef"
            },
            title: {
                color: "#3b3b3b"
            }
        },
        tooltip: {
            background: WHITE,
            color: BLACK
        }
    });

    themes.outlook = deepExtend({}, baseTheme, {
        chartArea: {
            background: ""
        },
        seriesColors: ["#231f20", "#1b75bb", "#7da5e0", "#f9ec31", "#faaf40"],
        categoryAxis: {
            majorGridLines: {
                visible: true
            }
        },
        axisDefaults: {
            line: {
                color: "#5d8cc9"
            },
            majorGridLines: {
                color: "#aac3e8"
            },
            minorGridLines: {
                color: "#ccdbf1"
            }
        },
        tooltip: {
            background: WHITE,
            color: BLACK
        }
    });

    themes.simple = deepExtend({}, baseTheme, {
        title: {
            color: "#606060"
        },
        legend: {
            labels: {
                color: "#606060"
            }
        },
        chartArea: {
            background: ""
        },
        seriesDefaults: {
            labels: {
                color: "#606060"
            }
        },
        seriesColors: ["#231f20", "#404041", "#58595b", "#808184", "#929497"],
        categoryAxis: {
            majorGridLines: {
                visible: true
            }
        },
        axisDefaults: {
            line: {
                color: "#828282"
            },
            majorGridLines: {
                color: "#d1d1d1"
            },
            minorGridLines: {
                color: "#e3e3e3"
            },
            labels: {
                color: "#606060"
            },
            title: {
                color: "#606060"
            }
        },
        tooltip: {
            background: WHITE,
            color: BLACK
        }
    });

    themes.sitefinity = deepExtend({}, baseTheme, {
        chartArea: {
            background: ""
        },
        seriesColors: ["#a2d5e2", "#95b979", "#f9d67b", "#ea9d73", "#f19ca8", "#d06c6c"],
        categoryAxis: {
            majorGridLines: {
                visible: true
            }
        },
        axisDefaults: {
            line: {
                color: "#636363"
            },
            majorGridLines: {
                color: "#919191"
            },
            minorGridLines: {
                color: "#a1a1a1"
            }
        },
        tooltip: {
            background: WHITE,
            color: BLACK
        }
    });

    themes.sunset = deepExtend({}, baseTheme, {
        title: {
            color: "#854324"
        },
        legend: {
            labels: {
                color: "#854324"
            }
        },
        seriesDefaults: {
            labels: {
                color: "#854324"
            }
        },
        chartArea: {
            background: ""
        },
        seriesColors: ["#3f1c12", "#ba3b01", "#d95a1a", "#e7931e", "#f9bc12"],
        categoryAxis: {
            majorGridLines: {
                visible: true
            }
        },
        axisDefaults: {
            line: {
                color: "#b7836a"
            },
            labels: {
                color: "#854324"
            },
            majorGridLines: {
                color: "#cebab1"
            },
            minorGridLines: {
                color: "#e2d6d0"
            },
            title: {
                color: "#854324"
            }
        },
        tooltip: {
            background: WHITE,
            color: BLACK
        }
    });

    themes.telerik = deepExtend({}, baseTheme, {
        chartArea: {
            background: ""
        },
        seriesColors: ["#7e7e7e", "#cbcbcb", "#a2ea8b", "#63ac39", "#000000"],
        categoryAxis: {
            majorGridLines: {
                visible: true
            }
        },
        axisDefaults: {
            line: {
                color: "#828282"
            },
            majorGridLines: {
                color: "#c6c6c6"
            },
            minorGridLines: {
                color: "#b4b4b4"
            }
        },
        tooltip: {
            background: WHITE,
            color: BLACK
        }
    });

    themes.transparent = deepExtend({}, baseTheme, {
        seriesDefaults: {
            opacity: 0.6,
            verticalLine: {
                markers: {
                    background: ""
                }
            },
            line: {
                markers: {
                    background: ""
                }
            },
            scatter: {
                markers: {
                    background: ""
                }
            },
            scatterLine: {
                markers: {
                    background: ""
                }
            }
        },
        chartArea: {
            background: ""
        },
        seriesColors: ["#f2f2f2", "#4d4d4d", "#d4d4d4", "#0d0d0d", "#999999"],
        categoryAxis: {
            majorGridLines: {
                visible: true
            }
        },
        axisDefaults: {
            line: {
                color: "#828282"
            },
            majorGridLines: {
                color: "#828282"
            },
            minorGridLines: {
                color: "#b4b4b4"
            }
        },
        tooltip: {
            background: WHITE,
            color: BLACK,
            opacity: 0.7
        }
    });

    themes.vista = deepExtend({}, baseTheme, {
        title: {
            color: "#333333"
        },
        legend: {
            labels: {
                color: "#333333"
            }
        },
        chartArea: {
            background: ""
        },
        seriesDefaults: {
            labels: {
                color: "#333333"
            }
        },
        seriesColors: ["#83abc0", "#64d6f4", "#3399ff", "#03597a", "#000000"],
        categoryAxis: {
            majorGridLines: {
                visible: true
            }
        },
        axisDefaults: {
            line: {
                color: "#a7bac5"
            },
            majorGridLines: {
                color: "#d3d3d3"
            },
            labels: {
                color: "#333333"
            },
            minorGridLines: {
                color: "#e5e5e5"
            },
            title: {
                color: "#333333"
            }
        },
        tooltip: {
            background: WHITE,
            color: BLACK
        }
    });

    themes.web20 = deepExtend({}, baseTheme, {
        title: {
            color: "#001454"
        },
        legend: {
            labels: {
                color: "#001454"
            }
        },
        chartArea: {
            background: ""
        },
        seriesDefaults: {
            labels: {
                color: "#001454"
            }
        },
        seriesColors: ["#0e4302", "#64ba36", "#a0beea", "#3460b9", "#2c4072"],
        categoryAxis: {
            majorGridLines: {
                visible: true
            }
        },
        axisDefaults: {
            line: {
                color: "#708dc3"
            },
            majorGridLines: {
                color: "#cfd9e7"
            },
            labels: {
                color: "#001454"
            },
            minorGridLines: {
                color: "#e2e8f1"
            },
            title: {
                color: "#001454"
            }
        },
        tooltip: {
            background: WHITE,
            color: BLACK
        }
    });

    themes.webblue = deepExtend({}, baseTheme, {
        title: {
            color: "#0d202b"
        },
        legend: {
            labels: {
                color: "#0d202b"
            }
        },
        chartArea: {
            background: ""
        },
        seriesDefaults: {
            labels: {
                color: "#0d202b"
            }
        },
        seriesColors: ["#a2b3c7", "#76c8e8", "#358db0", "#426682", "#2d3d4f"],
        categoryAxis: {
            majorGridLines: {
                visible: true
            }
        },
        axisDefaults: {
            line: {
                color: "#708dc3"
            },
            majorGridLines: {
                color: "#d0d8dd"
            },
            labels: {
                color: "#0d202b"
            },
            minorGridLines: {
                color: "#e2e8f1"
            },
            title: {
                color: "#0d202b"
            }
        },
        tooltip: {
            background: WHITE,
            color: BLACK
        }
    });

    themes.windows7 = deepExtend({}, baseTheme, {
        title: {
            color: "#4c607a"
        },
        legend: {
            labels: {
                color: "#4c607a"
            }
        },
        chartArea: {
            background: ""
        },
        seriesDefaults: {
            labels: {
                color: "#4c607a"
            }
        },
        seriesColors: ["#a5b3c5", "#82afe5", "#358db0", "#03597a", "#152435"],
        categoryAxis: {
            majorGridLines: {
                visible: true
            }
        },
        axisDefaults: {
            line: {
                color: "#a5b3c5"
            },
            majorGridLines: {
                color: "#dae2e8"
            },
            labels: {
                color: "#4c607a"
            },
            minorGridLines: {
                color: "#e9eef1"
            },
            title: {
                color: "#4c607a"
            }
        },
        tooltip: {
            background: WHITE,
            color: BLACK
        },
        tooltip: {
            background: WHITE,
            color: BLACK
        }
    });

    // Exports ================================================================
    Chart.themes = themes;
    Chart.prototype.options.theme = "default";

})(jQuery);(function ($) {

    var $t = $.telerik;
    var whiteSpaceRegExp = /\s+/;

    $t.scripts.push("telerik.list.js");

    $t.list = {
        htmlBuilder: function (element, className, isSelect) {
            var val,
                text,
                id = element.id,
                name = element.name,
                builder = new $t.stringBuilder(),
                $element = $(element);

            if (isSelect) {
                text = $element.find('option:selected').text();
                val = $element.val();
            } else {
                text = element.value;
            }

            function wrapper() {
                return $(['<div class="t-widget', className, 't-header"></div>'].join(" "));
            }

            this.render = function () {
                $element.wrap(wrapper()).hide();
                var $innerWrapper = $('<div class="t-dropdown-wrap t-state-default"></div>').insertBefore($element);

                this.text({
                    builder: builder,
                    text: text,
                    id: id,
                    name: name
                })
                .appendTo($innerWrapper);

                //button
                $('<span class="t-select"><span class="t-icon t-arrow-down">select</span></span>')
                .appendTo($innerWrapper);

                if (isSelect) {
                    builder.buffer = [];
                    $(builder
                        .cat('<input style="display:none;" type="text" ')
                        .catIf('value="', val, '" ', val)
                        .catIf('name="', name, '" ', name)
                        .cat('/>')
                        .string())
                    .insertAfter($innerWrapper);
                }
            }

            this.text = function (options) {
                return $(['<span class="t-input">', options.text || '&nbsp;', '</span>'].join(""));
            }
        },

        initialize: function () {
            this.previousValue = this.value();

            $t.bind(this, {
                dataBinding: this.onDataBinding,
                dataBound: this.onDataBound,
                error: this.onError,
                open: this.onOpen,
                close: this.onClose,
                valueChange: this.onChange,
                load: this.onLoad
            });
        },

        common: function () {
            this.open = function () {
                if (!this.loader.isAjax() && (!this.data || this.data.length == 0)) {
                    return;
                }

                var $wrapper = this.$wrapper || this.$element,
                    dropDown = this.dropDown,
                    dropDownZ = dropDown.$element.css('z-index');

                var position = {
                    offset: $wrapper.offset(),
                    outerHeight: $wrapper.outerHeight(),
                    outerWidth: $wrapper.outerWidth(),
                    zIndex: dropDownZ && dropDownZ != 'auto' ? dropDownZ : $t.getElementZIndex($wrapper[0])
                }

                if (dropDown.$items) {
                    dropDown.open(position);
                } else {
                    this.fill(function () { dropDown.open(position); });
                }
            }

            this.close = function () {
                this.dropDown.close();
            }

            this.dataBind = function (data, preserveStatus) {
                this.data = data = (data || []);

                var index = -1,
                    length = data.length,
                    placeholder = this.placeholder;

                if (placeholder && data[0] && data[0].Text !== placeholder) {
                    var first = [{
                        Text: placeholder,
                        Value: ""
                    }];

                    for (var idx = 0; idx < length; idx++) {
                        first.push(data[idx]);
                    }
                    this.data = data = first;
                }

                for (var i = 0; i < length; i++) {
                    var item = data[i];
                    if (item) {
                        if (item.Selected) {
                            index = i;
                        }
                    }
                }

                this.dropDown.dataBind(data, this.encoded);

                if (index != -1) {
                    this.index = index;
                    this.select(index);
                }

                if (!preserveStatus) {
                    this.text('');
                    this.$element.val('');
                    if (this.filteredDataIndexes) {
                        this.filteredDataIndexes = null;
                    }
                }
            }

            this.highlight = function (argument) {

                var rebind = function (component) {
                    var dropDown = component.dropDown;

                    component.close();
                    if (!dropDown.$items) {
                        dropDown.dataBind(component.data, component.encoded);
                    }

                    dropDown.$items
                            .removeClass('t-state-selected')
                            .eq(index)
                            .addClass('t-state-selected');
                }

                var index = -1;

                if (!this.data) return index;

                if (!isNaN(argument - 0)) { // index
                    if (argument > -1 && argument < this.data.length) {

                        index = argument;

                        rebind(this);
                    }

                } else if ($.isFunction(argument)) { // predicate

                    for (var i = 0, len = this.data.length; i < len; i++) {
                        if (argument(this.data[i])) {
                            index = i;
                            break;
                        }
                    }

                    if (index != -1)
                        rebind(this);

                } else { // dom node
                    index = this.dropDown.highlight(argument);
                }

                return index;
            }
        },

        filtering: function () {
            this.filter = function (component) {
                component.isFiltered = true;

                var performAjax = true,
                    data = component.data,
                    input = component.$text[0],
                    text = input.value,
                    trigger = component.trigger,
                    dropDown = component.dropDown,
                    shouldFilter = true;

                if (component.minChars == 0 && text.length == 0) {
                    shouldFilter = false;
                }

                text = this.multiple(text);

                if (component.minChars > 0 && text.length < component.minChars) return;

                var filterIndex = component.filter;
                if (component.loader.isAjax()) {

                    if (shouldFilter && component.cache && data && data.length > 0) {

                        component.filters[filterIndex](component, data, text);

                        var filteredDataIndexes = component.filteredDataIndexes;

                        if ((filteredDataIndexes && filteredDataIndexes.length > 0)
                        || (filterIndex == 0 && component.selectedIndex != -1))
                            performAjax = false;
                    }

                    if (performAjax) {

                        var postData = {};
                        postData[component.queryString.text] = text;

                        component.loader.ajaxRequest(function (data) {
                            var trigger = component.trigger;
                            var dropDown = component.dropDown;

                            if (data && data.length == 0) {
                                dropDown.close();
                                dropDown.dataBind();
                                return;
                            }

                            component.data = data;

                            $t.trigger(component.element, 'dataBound');

                            component.filters[filterIndex](component, data, text);

                            var $items = dropDown.$items;
                            if ($items.length > 0) {
                                if (!dropDown.isOpened()) trigger.open();
                                component.filtering.autoFill(component, $items.first().text());
                            }
                            else trigger.close();

                        }, { data: postData });
                    }
                } else {
                    performAjax = false;
                    component.filters[filterIndex](component, component.data, text);
                }

                if (!performAjax) {
                    var $items = dropDown.$items;
                    if (!$items) {
                        return;
                    }

                    var itemsLength = $items.length,
                        selectedIndex = component.selectedIndex;

                    var itemText = filterIndex == 0
                    ? selectedIndex != -1
                    ? $items[selectedIndex].innerText || $items[selectedIndex].textContent
                    : ''
                    : $items.length > 0
                    ? $items.first().text()
                    : '';

                    this.autoFill(component, itemText);

                    if (itemsLength == 0) {
                        trigger.close();
                    } else {
                        if (!dropDown.isOpened()) {
                            trigger.open();
                        }
                    }
                }
            }

            this.multiple = function (text) { return text; } // overriden by autocomplete
        },

        filters: function () { //mixin
            this.filters = [
                function firstMatch(component, data, inputText) {
                    if (!data || data.length == 0) return;
                    var dropDown = component.dropDown;
                    var $items = dropDown.$items;

                    if (!$items || $items.length == 0 || component.loader.isAjax()) {
                        dropDown.dataBind(data, component.encoded);
                        $items = dropDown.$items;
                    }

                    for (var i = 0, length = data.length; i < length; i++) {
                        if (data[i].Text.slice(0, inputText.length).toLowerCase() == inputText.toLowerCase()) {
                            var item = $items[i];

                            component.selectedIndex = i;
                            dropDown.highlight(item);
                            dropDown.scrollTo(item);
                            return;
                        }
                    }

                    $items.removeClass('t-state-selected');
                    component.selectedIndex = -1;

                    $t.list.highlightFirstOnFilter(component, $items);
                },

                createItemsFilter(false, function (inputText, itemText) {
                    return itemText.slice(0, inputText.length).toLowerCase() == inputText.toLowerCase();
                }),

                createItemsFilter(true, function (inputText, itemText) {
                    return itemText && itemText.toLowerCase().indexOf(inputText.toLowerCase()) != -1
                })
            ]
        },

        loader: function (component) {
            this.ajaxError = false;
            this.component = component;

            this.isAjax = function () {
                return component.ajax || component.ws || component.onDataBinding;
            }

            function ajaxOptions(complete, options) {
                var result = {
                    url: (component.ajax || component.ws)['selectUrl'],
                    type: 'POST',
                    data: {},
                    dataType: 'text', // using 'text' instead of 'json' because of DateTime serialization
                    error: function (xhr, status) {
                        component.loader.ajaxError = true;
                        if ($t.ajaxError(component.element, 'error', xhr, status))
                            return;
                    },
                    complete: $.proxy(function () { this.hideBusy(); }, component.loader),

                    success: function (data, status, xhr) {
                        try {
                            data = eval('(' + data + ')');
                        } catch (e) {
                            // in case the result is not JSON raise the 'error' event
                            if (!$t.ajaxError(component.element, 'error', xhr, 'parseeror'))
                                alert('Error! The requested URL did not return JSON.');
                            component.loader.ajaxError = true;
                            return;
                        }
                        data = data.d || data; // Support the `d` returned by MS Web Services 

                        if (complete)
                            complete.call(component, data);

                    }
                }

                $.extend(result, options);

                if (component.ws) {
                    result.data = $t.toJson(result.data);
                    result.contentType = 'application/json; charset=utf-8';
                }

                return result;
            }

            this.ajaxRequest = function (complete, options) {
                var e = {};

                if ($t.trigger(component.element, 'dataBinding', e))
                    return;

                if (component.ajax || component.ws) {
                    this.showBusy();
                    $.ajax(ajaxOptions(complete, { data: $.extend({}, options ? options.data : {}, e.data) }));
                }
                else
                    if (complete) complete.call(component, component.data);
            },

            this.showBusy = function () {
                this.busyTimeout = setTimeout($.proxy(function () {
                    this.component.$wrapper.find('> .t-dropdown-wrap .t-icon').addClass('t-loading');
                }, this), 100);
            },

            this.hideBusy = function () {
                clearTimeout(this.busyTimeout);
                this.component.$wrapper.find('> .t-dropdown-wrap .t-icon').removeClass('t-loading');
            }
        },

        trigger: function (component) {
            this.component = component;
            this.change = function () {
                var previousValue = component.previousValue;
                var value = component.value();
                if (previousValue == undefined || value != previousValue) {
                    $t.trigger(component.element, 'valueChange', { value: value });
                    component._oldIndex = component.selectedIndex;
                } else if (component.selectedIndex !== component._oldIndex) {
                    $t.trigger(component.element, 'valueChange', { value: value });
                    component._oldIndex = component.selectedIndex;
                }

                component.previousValue = component.value();
            }

            this.open = function () {
                var dropDown = component.dropDown;
                if ((dropDown.$items && dropDown.$items.length > 0) && !dropDown.isOpened() && !$t.trigger(component.element, 'open')) {
                    component.open();
                }
            }

            this.close = function () {
                var dropDown = component.dropDown;
                if ((dropDown.$element.is(':animated') || dropDown.isOpened()) && !$t.trigger(component.element, 'close')) {
                    component.close();
                }
            }
        },

        retrieveData: function (select) {
            var items = [];
            var $options = $(select).find('option');

            for (var i = 0, length = $options.length; i < length; i++) {
                var $option = $options.eq(i);
                items[i] = {
                    Text: $option.text(),
                    Value: $option.val(),
                    Selected: $option.is(':selected')
                }
            }
            return items;
        },

        highlightFirstOnFilter: function (component, $items) {
            if (component.highlightFirst) {
                $items.first().addClass('t-state-selected');
                component.dropDown.scrollTo($items[0]);
            }
        },

        moveToEnd: function (element) {
            if (element.createTextRange) {
                var range = element.createTextRange();
                range.moveStart('textedit', 1);
                range.select();
            }
        },

        selection: function (input, start, end) {
            if (input.createTextRange) {
                var selRange = input.createTextRange();
                selRange.collapse(true);
                selRange.moveStart('character', start);
                selRange.moveEnd('character', end - start);
                selRange.select();
            } else if (input.selectionStart) {
                input.selectionStart = start;
                input.selectionEnd = end;
            }
        },

        updateTextAndValue: function (component, text, value) {
            component.text(text);

            var val = value === null ? text : value;
            component.$element.val(val);
        },

        getZIndex: function (element) {
            var zIndex = 'auto';
            $(element).parents().andSelf().each(function () { //get element 
                zIndex = $(this).css('zIndex');
                if (Number(zIndex)) {
                    zIndex = Number(zIndex) + 1;
                    return false;
                }
            });
            return zIndex;
        },

        keycodes: [8, // backspace
                   9, // tab
                  13, // enter
                  27, // escape
                  37, // left arrow
                  38, // up arrow
                  39, // right arrow
                  40, // down arrow
                  35, // end
                  36] // home
    }

    function createItemsFilter(global, condition) {
        return function (component, data, inputText) {
            if (!data || data.length == 0) return;

            var filteredDataIndexes = $.map(data, function (item, index) {
                var text = item.Text;
                if (condition(inputText, text !== undefined ? text : item)) {
                    return index;
                }
            });

            var formatRegExp = new RegExp("(?![^&;]+;)(?!<[^<>]*)(" + inputText.replace(/([\^\$\(\)\[\]\{\}\*\.\+\?\|\\])/gi, "\\$1") + ")(?![^<>]*>)(?![^&;]+;)", global ? 'ig' : 'i');

            component.filteredDataIndexes = filteredDataIndexes;
            component.selectedIndex = -1;

            component.dropDown.onItemCreate = function (e) { if (inputText) e.html = e.html.replace(formatRegExp, "<strong>$1</strong>"); }
            component.dropDown.dataBind($.map(filteredDataIndexes, function (item, index) {
                return data[item];
            }), component.encoded);

            var $items = component.dropDown.$items;
            $items.removeClass('t-state-selected');
            $t.list.highlightFirstOnFilter(component, $items);
        };
    }

    function firstMatch(data, $items, text) {
        if (!data || !$items) return null;

        var valueLength = text.length;
        text = text.toLowerCase();

        for (var i = 0, length = data.length; i < length; i++) {
            if (data[i].Text.slice(0, valueLength).toLowerCase() == text)
                return $items[i];
        }
    }

    $t.dropDownList = function (element, options) {
        if (options && options.enabled === undefined) {
            options.enabled = !$(element).is("[disabled]");
        }

        $.extend(this, options);

        var isSelect = element.nodeName.toLowerCase() == 'select';
        if (isSelect && !this.data) {
            this.data = $t.list.retrieveData(element);
            new $t.list.htmlBuilder(element, 't-dropdown', isSelect).render();
            element = element.previousSibling; //set element to input
        }

        var cachedInput = '';
        this.element = element;
        var that = this;
        var $element = this.$element = $(element).closest("form")
                                                 .bind("reset", function () {
                                                     setTimeout(function () {
                                                         that.value(element.value);
                                                     });
                                                 })
                                                 .end();

        this.loader = new $t.list.loader(this);
        this.trigger = new $t.list.trigger(this);
        this.$wrapper = $element.closest('.t-dropdown');
        var $text = this.$text = this.$wrapper.find('> .t-dropdown-wrap > .t-input');

        //allow element to be focused
        if (!this.$wrapper.attr('tabIndex')) this.$wrapper.attr('tabIndex', 0);

        this.dropDown = new $t.dropDown({
            attr: this.dropDownAttr,
            effects: this.effects,
            onClick: $.proxy(function (e) {
                this.select(e.item);
                this.trigger.change();
                this.trigger.close();
                this.$wrapper.focus();
            }, this)
        });

        this.dropDown.$element.css('direction', this.$wrapper.closest('.t-rtl').length ? 'rtl' : '');

        var updateCssOnPropertyChange = function (e) {
            var attr = 'class',
                classValue = $element.attr(attr);

            if ((e.attrName && e.attrName == "class") || (e.propertyName && e.propertyName == "className")) {

                var innerWrap = $element.prev(".t-dropdown-wrap");

                var stateClass = /\b(t-state-[\w]+)\b/.exec(innerWrap.attr(attr));
                if (!(stateClass && stateClass[0])) {
                    stateClass = "";
                } else {
                    stateClass = stateClass[0];
                }

                if (classValue != innerWrap.attr(attr)) {
                    innerWrap.attr(attr, classValue).addClass('t-dropdown-wrap ' + stateClass);
                }
            }
        }

        if ($.browser.msie) {
            element.attachEvent("onpropertychange", updateCssOnPropertyChange);

        } else {
            $element.bind("DOMAttrModified", updateCssOnPropertyChange);
        }

        this.fill = function (callback, options) {
            function updateSelectedItem(component) {
                var selector,
                    value = component.selectedValue || component.value();

                if (value) {
                    selector = function (dataItem) { return value == (dataItem.Value || dataItem.Text); };
                } else {
                    var $items = component.dropDown.$items,
                        selectedIndex = component.index,
                        selectedItemsLength = $items.filter('.t-state-selected').length;

                    selector = selectedIndex != -1 && selectedIndex < $items.length
                            ? selectedIndex
                            : selectedItemsLength > 0
                            ? selectedItemsLength - 1
                            : 0;
                }

                component.select(selector);
                component._oldIndex = component.selectedIndex;
            }

            var dropDown = this.dropDown,
                loader = this.loader;

            if (!dropDown.$items && !loader.ajaxError) {
                if (loader.isAjax()) {
                    options = options || {};
                    loader.ajaxRequest(function (data) {
                        this.dataBind(data, true);
                        updateSelectedItem(this);

                        $t.trigger(this.element, 'dataBound');
                        this.trigger.change();

                        if (callback) callback();
                    }, options);
                }
                else {
                    this.dataBind(this.data);
                    updateSelectedItem(this);

                    if (callback) callback();
                }
            }
        }

        this.enable = function () {
            var wrapper = this.$wrapper.removeClass('t-state-disabled');

            if (!wrapper.data("events")) {
                this.$wrapper
                    .removeClass('t-state-disabled')
                    .bind({
                        keydown: $.proxy(keydown, this),
                        keypress: $.proxy(keypress, this),
                        click: $.proxy(function (e) {
                            var trigger = this.trigger;
                            var dropDown = this.dropDown;

                            this.$wrapper.focus();

                            if (dropDown.isOpened())
                                trigger.close();
                            else if (!dropDown.$items)
                                this.fill(trigger.open);
                            else
                                trigger.open();
                        }, this),
                        focus: $.proxy(function () {
                            this.$wrapper.find(".t-dropdown-wrap").addClass("t-state-focused").removeClass("t-state-default");
                        }, this),
                        blur: $.proxy(function () {
                            this.$wrapper.find(".t-dropdown-wrap").addClass("t-state-default").removeClass("t-state-focused");
                        }, this)
                    });
            }

            $element.removeAttr("disabled");
        }

        this.disable = function () {
            $element.attr("disabled", "disabled");
            this.$wrapper
                .addClass('t-state-disabled')
                .unbind();
        }

        this.reload = function () {
            this.dropDown.$items = null;
            if (arguments.length) {
                this.fill(arguments[0], arguments[1]);
            } else {
                this.fill();
            }
        }

        this.select = function (item) {
            var index = this.highlight(item);

            if (index != -1) {
                this.selectedIndex = index;

                $t.list.updateTextAndValue(this, this.data[index].Text, this.data[index].Value);
            }

            return index;
        }

        this.text = function (text) {
            if (text !== undefined) {
                if (this.encoded) {
                    text = $t.encode(text);
                }
                this.$text.html(text && text.replace(whiteSpaceRegExp, '') ? text : '&nbsp;');
            } else {
                return this.$text.html();
            }
        }

        this.value = function (value) {
            if (value !== undefined) {
                var index = this.select(function (dataItem) {
                    return value == dataItem.Value;
                });

                if (index == -1) {
                    index = this.select(function (dataItem) {
                        return value == dataItem.Text;
                    });
                }

                if (index != -1) {
                    this.previousValue = this.$element.val(); //prevent change event
                }

            } else {
                return this.$element.val();
            }
        }

        $t.list.common.call(this);
        $t.list.initialize.call(this);

        $(document.documentElement).bind('mousedown', $.proxy(function (e) {
            var $dropDown = this.dropDown.$element;
            var isDropDown = $dropDown && $dropDown.parent().length > 0;

            if ($.contains(this.$wrapper[0], e.target)
                || (isDropDown && $.contains($dropDown.parent()[0], e.target)))
                return;

            this.trigger.change();
            this.trigger.close();
        }, this));

        this[this.enabled ? 'enable' : 'disable']();

        // PRIVATE methods
        function resetTimer() {
            clearTimeout(this.timeout);
            this.timeout = setTimeout($.proxy(function () { cachedInput = '' }, this), this.delay);
        }

        function keydown(e) {
            var trigger = this.trigger;
            var dropDown = this.dropDown;
            var key = e.keyCode || e.which;

            if (e.altKey && (key == 38 || key == 40)) {
                var action = key == 38 ? trigger.close : trigger.open;
                if (!dropDown.$items) {
                    this.fill(action); //creates items 
                } else {
                    action();
                }

                return;
            }

            if (key > 34 && key < 41) {

                e.preventDefault();

                if (!dropDown.$items) {
                    this.fill();
                    return;
                }

                var $items = dropDown.$items,
                    $selectedItem = $($items[this.selectedIndex]);

                var $item = (key == 35) ? $items.last() // end
                         : (key == 36) ? $items.first() // home
                         : (key == 37 || key == 38) ? $selectedItem.prev() // up
                         : (key == 39 || key == 40) ? $selectedItem.next() // down
                         : [];

                if ($item.length) {
                    var item = $item[0];

                    this.select(item);
                    dropDown.scrollTo(item);

                    if (!dropDown.isOpened())
                        trigger.change();
                }
            }

            if (key == 8) {
                $.proxy(resetTimer, this)();
                e.preventDefault();
                cachedInput = cachedInput.slice(0, -1);
            }

            if (key == 9 || key == 13 || key == 27) {
                trigger.change();
                trigger.close();
            }
        }

        function keypress(e) {
            var dropDown = this.dropDown;
            var key = e.keyCode || e.charCode;

            if (key == 0 || $.inArray(key, $t.list.keycodes) != -1 || e.ctrlKey || e.altKey || e.shiftKey) return;

            if (!dropDown.$items) {
                this.fill($.proxy(function () {
                    _filter(key);
                }, this));
                return;
            }

            _filter(key);
        }

        var _filter = $.proxy(function _filter(key) {
            var dropDown = this.dropDown;
            var tempInputValue = cachedInput;
            tempInputValue += String.fromCharCode(key);

            if (tempInputValue) {

                var item = firstMatch(this.data, dropDown.$items, tempInputValue);

                if (item) {
                    this.select(item);
                    dropDown.scrollTo(item);
                }

                cachedInput = tempInputValue;
            }

            $.proxy(resetTimer, this)();
        }, this);

        if (that.cascadeTo) {
            var cascadingElement = $("#" + that.cascadeTo).attr("disabled", "disabled");

            cascadingElement.bind("load", function () {
                if (that.value()) {
                    that.$element.trigger("valueChange");
                }
            })

            that.$element.bind("valueChange", $.proxy(function () {
                var ddl = cascadingElement.data("tDropDownList");
                if (ddl) {
                    var tempData = [],
                        data = {};

                    data[that.$element.attr("name")] = that.value();

                    if (ddl.loader.isAjax()) {
                        if (that.placeholder) {
                            tempData[0] = {
                                Text: that.placeholder,
                                Value: ""
                            };
                        }
                        ddl.dataBind(tempData);
                    }

                    ddl.select(0);
                    ddl.disable();
                    if (that.value() === "" && that.placeholder) {
                        ddl.$element.trigger("valueChange");
                        return;
                    }

                    ddl.reload(function () {
                        var idx = tempData[0] ? 1 : 0;
                        if (ddl.data[idx]) {
                            ddl.enable();
                        }
                    }, { data: data });
                }
            }, that));
        }
    }

    $.fn.tDropDownList = function (options) {
        return $t.create(this, {
            name: 'tDropDownList',
            init: function (element, options) {
                return new $t.dropDownList(element, options)
            },
            options: options
        });
    };

    // default options
    $.fn.tDropDownList.defaults = {
        effects: $t.fx.slide.defaults(),
        accessible: false,
        index: 0,
        delay: 500,
        encoded: true
    };

})(jQuery);
(function ($) {
    var $t = $.telerik;

    $t.scripts.push("telerik.autocomplete.js");

    $t.autocomplete = function (element, options) {
        $.extend(this, options);

        var $element = this.$element = $(element)
                                    .addClass('t-widget t-autocomplete t-input')
                                    .attr('autocomplete', 'off')
                                    .bind("paste", $.proxy(function (e) {
                                        resetTimer(this);
                                    }, this));

        this.$text = $element;
        this.element = element;
        this.trigger = new $t.list.trigger(this);
        this.trigger.change = function () {
            var text = this.component.text();
            var previousValue = this.component.previousValue;

            if (previousValue == undefined || text != previousValue)
                $t.trigger(this.component.element, 'valueChange', { value: text });

            this.component.previousValue = text;
        }

        this.loader = new $t.list.loader(this);
        this.loader.showBusy = function () {
            this.busyTimeout = setTimeout($.proxy(function () {
                this.component.$element.addClass('t-loading');
            }, this), 100);
        }
        this.loader.hideBusy = function () {
            clearTimeout(this.busyTimeout);
            this.component.$element.removeClass('t-loading');
        }

        this.filtering = new $t.list.filtering(this);
        this.filtering.autoFill = function (component, itemText) {
            if (component.autoFill && (component.lastKeyCode != 8 && component.lastKeyCode != 46)) {

                var input = component.$text[0],
                    textBoxValue = input.value,
                    separator = component.separator,
                    endIndex = $t.caretPos(input),
                    multiple = component.multiple;

                var lastSeparatorIndex = multiple && separator ? $t.lastIndexOf(textBoxValue.substring(0, endIndex), separator) : -1;
                var startIndex = lastSeparatorIndex != -1 ? lastSeparatorIndex + separator.length : 0;

                var filterString = textBoxValue.substring(startIndex, endIndex);
                var matchIndex = itemText.toLowerCase().indexOf(filterString.toLowerCase());

                if (matchIndex != -1) {

                    var stringToAppend = itemText.substring(matchIndex + filterString.length);

                    if (multiple) {
                        var split = textBoxValue.split(separator),
                            wordIndex = valueArrayIndex(input, separator);

                        split[wordIndex] = filterString + stringToAppend;
                        input.value = split.join(separator) + (component.multiple && wordIndex != 0 && wordIndex == split.length - 1 ? separator : '');
                    } else {
                        input.value = filterString + stringToAppend;
                    }

                    $t.list.selection(input, endIndex, endIndex + stringToAppend.length);
                }
            }
        }

        this.enable = function () {
            $element
            .removeClass('t-state-disabled')
            .removeAttr("disabled");
        }

        this.disable = function () {
            $element
            .addClass('t-state-disabled')
            .attr('disabled', 'disabled');
        }

        this.filtering.multiple = $.proxy(function (text) {
            if (this.multiple) {
                text = text.split(this.separator);
                text = text[valueArrayIndex(this.$text[0], this.separator)];
            }
            return text;
        }, this);

        this.dropDown = new $t.dropDown({
            attr: this.dropDownAttr,
            effects: this.effects,
            onClick: $.proxy(function (e) {
                this.select(e.item);
                this.trigger.change();
                this.trigger.close();
            }, this)
        });

        this.dropDown.$element.css('direction', $element.closest('.t-rtl').length ? 'rtl' : '');

        this.fill = function (callback) {
            function highlightItem(component) {
                var $item = component.highlightFirst ? dropDown.$items.first() : null;
                if ($item) $item.addClass('t-state-selected');
            }

            var loader = this.loader;
            var dropDown = this.dropDown;
            var minChars = this.minChars;
            var textValue = this.text();
            var textValueLength = textValue.length;

            if (!dropDown.$items && !loader.ajaxError) {
                if ((loader.isAjax() || this.onDataBinding) && textValueLength >= minChars) {

                    var postData = {};
                    postData[this.queryString.text] = textValue;

                    loader.ajaxRequest(function (data) {
                        this.dataBind(data, true);
                        highlightItem(this);

                        $t.trigger(this.element, 'dataBound');
                        this.trigger.change();

                        if (callback) callback();
                    },
                    { data: postData });
                }
                else {
                    this.dataBind(this.data, true);
                    highlightItem(this);
                    if (callback) callback();
                }
            }
        }

        this.text = function () {
            if (arguments.length > 0) {
                this.previousValue = arguments[0];
            }
            return this.$text.val.apply(this.$text, arguments);
        }

        this.value = function () {
            return this.text.apply(this, arguments);
        }

        this.select = function (item) {

            var index = this.highlight(item);

            if (index == -1) return index;

            var filteredDataIndexes = this.filteredDataIndexes;
            var itemIndex = (filteredDataIndexes && filteredDataIndexes.length) > 0 ? filteredDataIndexes[index] : index;

            var item = this.data[itemIndex];
            var dataText = item.Text ? item.Text : item;
            var value = dataText;

            if (this.multiple) {

                var $element = this.$element
                var separator = this.separator;
                var wordIndex = valueArrayIndex($element[0], separator);

                value = $element.val().split(separator);
                value[wordIndex] = dataText;
                value = value.join(separator) + (wordIndex == value.length - 1 ? separator : '');
            }

            this.$text.val(value);
        }

        $t.list.common.call(this);
        $t.list.filters.call(this);
        $t.list.initialize.call(this);

        //overrides common.databind method
        this.dataBind = function (data, preserveStatus) {
            this.data = data = (data || []);
            this.dropDown.dataBind(data, this.encoded);
            if (!preserveStatus) {
                this.$text.val('');
            }
        }

        $element
            .bind({
                focus: $.proxy(function (e) { e.stopPropagation(); }, this),
                keydown: $.proxy(keydown, this),
                keypress: $.proxy(function (e) {
                    var key = e.keyCode || e.charCode;

                    if (key == 0 || $.inArray(key, $t.list.keycodes) != -1 || e.ctrlKey) return true;

                }, this)
            });

        $(document.documentElement).bind('mousedown', $.proxy(function (e) {
            var $parent = this.dropDown.$element.parent();
            var parentLength = $parent.length;

            if ((!parentLength && element !== e.target) || (parentLength && !$.contains(element, e.target) && !$.contains($parent[0], e.target))) {
                this.trigger.change();
                this.trigger.close();
            }
        }, this));

        //PRIVATE
        function valueArrayIndex(input, separator) {
            return input.value.substring(0, $t.caretPos(input)).split(separator).length - 1;
        }

        function resetTimer(component) {
            clearTimeout(component.timeout);
            component.timeout = setTimeout(function () { component.filtering.filter(component) }, component.delay);
        }

        function keydown(e) {
            var trigger = this.trigger;
            var dropDown = this.dropDown;
            var key = e.keyCode || e.which;
            this.lastKeyCode = key;

            if (!e.shiftKey && key > 36 && key < 41 && key != 37 && key != 39) {

                e.preventDefault();

                if (dropDown.isOpened()) {

                    if (!dropDown.$items) this.fill();

                    var $items = dropDown.$items;

                    var $selectedItem = $items.filter('.t-state-selected:first');

                    var $item = [];

                    if (key == 38) {
                        var prevItem = $selectedItem.prev();
                        $item = prevItem.length ? prevItem : $items.last();
                    } else if (key == 40) {
                        var nextItem = $selectedItem.next();
                        $item = nextItem.length ? nextItem : $items.first();
                    }

                    if ($item.length) {
                        var item = $item[0];

                        this.highlight(item);
                        dropDown.scrollTo(item);

                        this.filtering.autoFill(this, $item.text());
                    }
                }
                return;
            }

            if (key == 8 || key == 46) {
                var $element = this.$element;

                if ($element.val() != '') resetTimer(this); //reset and start filtering after delay

                setTimeout($.proxy(function () {
                    if ($element.val() == '') {
                        trigger.close();
                    }
                }, this), 0);
                return;
            }

            if (key == 13) {

                if (dropDown.isOpened()) e.preventDefault();

                if (dropDown.$items) {
                    var $selectedItems = dropDown.$items.filter('.t-state-selected:first');

                    if ($selectedItems.length > 0) {
                        this.select($selectedItems[0]);
                    }
                }
                trigger.change();
                trigger.close();
                $t.list.moveToEnd(this.element);
                return;
            }

            if (key == 27 || key == 9) {
                clearTimeout(this.timeout);
                trigger.change();
                trigger.close();
                return;
            }

            resetTimer(this); //reset and start filtering after delay
        }
    }

    // jQuery extender
    $.fn.tAutoComplete = function (options) {
        return $t.create(this, {
            name: 'tAutoComplete',
            init: function (element, options) {
                return new $t.autocomplete(element, options)
            },
            options: options
        });
    };

    // default options
    $.fn.tAutoComplete.defaults = {
        encoded: true,
        effects: $t.fx.slide.defaults(),
        filter: 1,
        delay: 200,
        minChars: 1,
        cache: true,
        autoFill: false,
        highlightFirst: false,
        queryString: {
            text: 'text'
        },
        multiple: false,
        separator: ', '
    };
})(jQuery);
(function ($) {
    var $t = $.telerik,
        replaceUrlRegExp = /{0:?/,
        dateFormatRegExp = /{0:?(\S|\s)*}/;

    $t.scripts.push("telerik.calendar.js");

    function defineViewedMonth(selectedValue, minValue, maxValue) {
        var today = new $t.datetime();
        if (selectedValue) {
            today = new $t.datetime(selectedValue);
        }

        if (minValue > today.value) {
            today = new $t.datetime(minValue);
        } else if (maxValue < today.value) {
            today = new $t.datetime(maxValue);
        }
        return $t.datetime.firstDayOfMonth(today);
    }

    $.extend($t, {
        calendar: function (element, options) {
            this.element = element;

            $.extend(this, options);

            var minDate = new $t.datetime(this.minDate);
            var maxDate = new $t.datetime(this.maxDate);

            this.currentView = $t.calendar.views[0];
            this.viewedMonth = defineViewedMonth(this.selectedDate, this.minDate, this.maxDate);

            var header = new $t.stringBuilder()
                         .cat('<a href="#" class="t-link t-nav-prev')
                         .catIf(' t-state-disabled', this.currentView.compare(this.viewedMonth, minDate, false) <= 0)
                         .cat('">')
			             .cat('<span class="t-icon t-arrow-prev"></span></a><a href="#" class="t-link t-nav-fast">')
			             .cat(this.currentView.title(this.viewedMonth))
			             .cat('</a>')
			             .cat('<a href="#" class="t-link t-nav-next')
                         .catIf(' t-state-disabled', this.currentView.compare(this.viewedMonth, maxDate, true) >= 0)
                         .cat('"><span class="t-icon t-arrow-next"></span></a>');

            $('.t-header', this.element).html(header.string());

            /* header */
            $('.t-nav-next:not(.t-state-disabled)', element)
			    .live('click', $.proxy(this.navigateToFuture, this));

            $('.t-nav-prev:not(.t-state-disabled)', element)
			    .live('click', $.proxy(this.navigateToPast, this));

            $('.t-nav-fast:not(.t-state-disabled)', element)
			    .live('click', $.proxy(this.navigateUp, this));

            $('.t-link.t-state-disabled', element)
			    .live('click', $t.preventDefault);

            $('td:not(.t-state-disabled):has(.t-link)', element)
				.live('mouseenter', $t.hover)
			    .live('mouseleave', $t.leave)
			    .live('click', $.proxy(this.navigateDown, this));

            $t.bind(this, {
                change: this.onChange,
                load: this.onLoad
            });

            this._footer(this.todayFormat);
        }
    });

    $t.calendar.prototype = {
        stopAnimation: false, // used by tests

        updateSelection: function () {
            var firstDayOfMonth = $t.datetime.firstDayOfMonth(this.viewedMonth).toDate();
            var lastDayOfMonth = new $t.datetime(firstDayOfMonth).date(32).date(0).toDate();

            if (this.selectedDate === null || !$t.calendar.isInRange(this.selectedDate, firstDayOfMonth, lastDayOfMonth)) {
                var viewedMonth = defineViewedMonth(this.selectedDate, this.minDate, this.maxDate);
                this.goToView(0, viewedMonth);
            }

            var me = this;
            var days = $('.t-content td:not(.t-other-month)', this.element)
		                .removeClass('t-state-selected');

            if (this.selectedDate !== null) {
                days.filter(function () {
                    return (parseInt($(this).text(), 10) == me.selectedDate.getDate());
                })
		        .addClass('t-state-selected');
            }
        },

        value: function () {
            if (arguments.length == 0)
                return this.selectedDate;
            if (arguments.length == 1)
                this.selectedDate = arguments[0] === null ? null : new Date(arguments[0].value ? arguments[0].value : arguments[0]);
            else if (arguments.length > 1)
                this.selectedDate = new Date(arguments[0], arguments[1], arguments[2]);

            this.updateSelection();

            return this;
        },

        overlay: function (show) {
            if (!show)
                return $('.t-overlay', this.element).remove();

            var overlay = $('<div/>')
		        .addClass('t-overlay')
		        .css({
		            opacity: 0,
		            width: this.element.offsetWidth,
		            height: this.element.offsetHeight,
		            position: 'absolute',
		            top: 0,
		            left: 0,
		            zIndex: 3,
		            backgroundColor: '#fff'
		        });

            $(this.element).find(".t-header").after(overlay);
        },

        goToView: function (viewIndex, viewedMonth) {
            if (viewIndex < 0 || $t.calendar.views.length <= viewIndex)
                return;

            var minDate = new $t.datetime(this.minDate);
            var maxDate = new $t.datetime(this.maxDate);

            if (typeof viewedMonth != 'undefined') {
                viewedMonth = viewedMonth.value ? viewedMonth : new $t.datetime(viewedMonth);
                this.viewedMonth = $t.datetime.firstDayOfMonth(viewedMonth);
            }

            this.currentView = $t.calendar.views[viewIndex];
            $('.t-nav-prev', this.element)
				.toggleClass('t-state-disabled', this.currentView.compare(viewedMonth, minDate, false) <= 0);

            $('.t-nav-next', this.element)
				.toggleClass('t-state-disabled', this.currentView.compare(viewedMonth, maxDate, true) >= 0);

            $('.t-nav-fast', this.element)
                .html(this.currentView.title(viewedMonth))
                .toggleClass('t-state-disabled', viewIndex == $t.calendar.views.length - 1);

            $('.t-content', this.element)
                .html(this.currentView.body(viewedMonth, minDate, maxDate, this.selectedDate ? new $t.datetime(this.selectedDate) : null, this.urlFormat, this.dates))
                .toggleClass('t-meta-view', viewIndex == 1 || viewIndex == 2);

            return this;
        },

        navigateVertically: function (viewIndex, viewedMonth, plunge, target) {
            viewedMonth = new $t.datetime(viewedMonth);
            this.viewedMonth = $t.datetime.firstDayOfMonth(viewedMonth);

            this.currentView = $t.calendar.views[viewIndex];

            this.overlay(true);

            var minDate = new $t.datetime(this.minDate);
            var maxDate = new $t.datetime(this.maxDate);

            var oldView = $('.t-content', this.element);

            var oldViewWidth = oldView.outerWidth();
            var oldViewHeight = oldView.outerHeight();
            var oldViewFontSize = oldView.css('font-size');
            var oldViewLineHeight = oldView.css('line-height');

            if (oldViewLineHeight === 'normal') oldViewLineHeight = parseInt(oldViewFontSize) * 1.5;

            oldView.find('td').removeClass('t-state-hover');

            $('.t-nav-fast', this.element)
		        .html(this.currentView.title(viewedMonth))
		        .toggleClass('t-state-disabled', viewIndex == $t.calendar.views.length - 1);

            $('.t-nav-prev', this.element)
		        .toggleClass('t-state-disabled', this.currentView.compare(this.viewedMonth, minDate, false) <= 0);

            $('.t-nav-next', this.element)
		        .toggleClass('t-state-disabled', this.currentView.compare(this.viewedMonth, maxDate, true) >= 0);

            var newView = $('<table class="t-content" cellspacing="0"></table>')
		                    .html(this.currentView.body(viewedMonth, minDate, maxDate, this.selectedDate ? new $t.datetime(this.selectedDate) : null, this.urlFormat, this.dates))
		                    .toggleClass('t-meta-view', viewIndex == 1 || viewIndex == 2);

            var me = this;

            var maximizedViewProperties = {
                fontSize: oldViewFontSize,
                lineHeight: oldViewLineHeight,
                top: 0, left: 0,
                width: oldViewWidth,
                height: oldViewHeight,
                opacity: 1
            };

            var outerAnimationContainer;

            if (plunge) {
                outerAnimationContainer =
		            $t.fx._wrap(oldView)
		                 .css({
		                     overflow: 'hidden',
		                     position: 'relative'
		                 });
                newView.wrap($('<div/>')
		               .addClass('t-animation-container')
		               .css($.extend({
		                   position: 'absolute',
		                   zIndex: 1,
		                   fontSize: 1,
		                   lineHeight: 1,
		                   width: target.outerWidth(),
		                   height: target.outerHeight(),
		                   opacity: 0
		               }, target.position())))
		               .parent()
		               .insertAfter(oldView);

                if (!this.stopAnimation) {
                    newView.parent()
		                   .animate({
		                       fontSize: oldViewFontSize,
		                       lineHeight: oldViewLineHeight,
		                       top: 0, left: 0,
		                       width: oldViewWidth,
		                       height: oldViewHeight,
		                       opacity: 1
		                   }, 'normal', function () {
		                       $(me.element).find(".t-header").after(newView);
		                       outerAnimationContainer.remove();
		                       me.overlay(false);
		                   });
                } else { //animation is stopped for test purposes
                    oldView.remove();
                    $(me.element).find(".t-header").after(newView);
                    outerAnimationContainer.remove();
                    me.overlay(false);
                }
            } else {

                newView.insertBefore(oldView);

                outerAnimationContainer =
		            $t.fx._wrap(newView)
		                 .css({
		                     overflow: 'hidden',
		                     position: 'relative'
		                 });

                var coordinatesMod;
                if (viewIndex != 0)
                    coordinatesMod = $t.calendar.views[viewIndex].verticalDate(this.viewedMonth);

                var collapseCoordinates = {
                    top: (Math.floor(coordinatesMod / 4.0) * oldViewHeight) / 3.0,
                    left: ((coordinatesMod % 4) * oldViewWidth) / 4.0
                };

                oldView.wrap($('<div/>')
		               .addClass('t-animation-container')
		               .css($.extend({
		                   position: 'absolute'
		               }, maximizedViewProperties)))
		               .parent()
		               .insertAfter(newView)

                if (!this.stopAnimation) {
                    oldView.parent()
		                   .animate($.extend({
		                       fontSize: 1,
		                       lineHeight: 1,
		                       width: 48,
		                       height: 54,
		                       opacity: 0
		                   }, collapseCoordinates), 'normal', function () {
		                       $(me.element).find(".t-header").after(newView);
		                       outerAnimationContainer.remove();
		                       me.overlay(false);
		                   });
                } else {//animation is stopped for test purposes
                    oldView.remove();
                    $(me.element).find(".t-header").after(newView);
                    outerAnimationContainer.remove();
                    me.overlay(false);
                }
            }
            $t.trigger(this.element, 'navigate', {
                direction: plunge
            });
        },

        navigateHorizontally: function (viewIndex, viewedMonth, forward) {
            viewedMonth = new $t.datetime(viewedMonth);

            var minDate = new $t.datetime(this.minDate);
            var maxDate = new $t.datetime(this.maxDate);
            this.viewedMonth = $t.datetime.firstDayOfMonth($t.calendar.fitDateToRange(viewedMonth, minDate, maxDate));

            this.currentView = $t.calendar.views[viewIndex];

            $('.t-nav-fast', this.element)
		        .html(this.currentView.title(viewedMonth))
		        .toggleClass('t-state-disabled', viewIndex == $t.calendar.views.length - 1);

            $('.t-nav-prev', this.element)
		        .toggleClass('t-state-disabled', this.currentView.compare(this.viewedMonth, minDate, false) <= 0);

            $('.t-nav-next', this.element)
		        .toggleClass('t-state-disabled', this.currentView.compare(this.viewedMonth, maxDate, true) >= 0);

            this.overlay(true);

            var newView = $('<table class="t-content" cellspacing="0"></table>')
		                      .html(this.currentView.body(viewedMonth, minDate, maxDate, this.selectedDate ? new $t.datetime(this.selectedDate) : null, this.urlFormat, this.dates))
		                      .toggleClass('t-meta-view', viewIndex == 1 || viewIndex == 2);

            var oldView = $('.t-content', this.element);

            var viewWidth = oldView.outerWidth();

            oldView.add(newView)
		           .css({ width: viewWidth, 'float': 'left' });

            var animationContainer =
		           $t.fx._wrap(oldView)
		                .css({
		                    position: 'relative',
		                    width: viewWidth * 2,
		                    'float': 'left',
		                    left: (forward ? 0 : -200)
		                });

            newView[forward ? 'insertAfter' : 'insertBefore'](oldView);

            var me = this;
            if (!this.stopAnimation) {
                animationContainer.animate({ left: (forward ? -200 : 0) }, 'normal', function () {
                    $(me.element).find(".t-header").after(newView);
                    animationContainer.remove();
                    me.overlay(false);
                });
            } else { //animation is stopped for test purposes
                oldView.remove();
                $(me.element).find(".t-header").after(newView);
                animationContainer.remove();
                me.overlay(false);
            }

            $t.trigger(this.element, 'navigate', {
                direction: forward
            });
        },

        navigateUp: function (e) {
            if (e) e.preventDefault();
            var currentViewIndex = this.currentView.index;
            this.navigateVertically(currentViewIndex + 1, this.viewedMonth.toDate(), false);
        },

        navigateDown: function (e, target, viewIndex) {
            var $target = $($(e.target).hasClass('t-input') ? target : e.target);
            var clickedText = $target.text();
            var currentViewIndex = viewIndex || this.currentView.index;

            var href = $target.attr('href');
            if (href && (href.charAt(href.length - 1) == '#'))
                e.preventDefault();

            if (currentViewIndex == 0) {
                var date = parseInt(clickedText, 10);

                var month = this.viewedMonth.month();

                if ($target.parent().hasClass('t-other-month'))
                    month += (date < 15 ? 1 : -1);

                var newlySelectedDate = new Date(this.viewedMonth.year(), month, date);

                if (!this.selectedDate || (this.selectedDate > newlySelectedDate || newlySelectedDate > this.selectedDate)) {
                    if ($t.trigger(this.element, 'change', {
                        previousDate: this.selectedDate,
                        date: newlySelectedDate
                    }))
                        return this;

                    this.selectedDate = newlySelectedDate;
                }

                this.updateSelection();
            } else {
                if (currentViewIndex != 0)
                    $t.calendar.views[currentViewIndex].verticalDate(this.viewedMonth, clickedText);

                this.viewedMonth = $t.calendar.fitDateToRange(this.viewedMonth, new $t.datetime(this.minDate), new $t.datetime(this.maxDate));

                this.navigateVertically(currentViewIndex - 1, this.viewedMonth.toDate(), true, $target.add($target.parent()).filter('td'));
            }
        },

        navigateToPast: function (e) {
            if (e) e.preventDefault();
            var currentViewIndex = this.currentView.index;

            if (currentViewIndex == 0) {
                this.viewedMonth.date(1).date(-1);
            } else
                this.viewedMonth.addYear(-Math.pow(10, currentViewIndex - 1));

            this.navigateHorizontally(currentViewIndex, this.viewedMonth.toDate(), false);
        },

        navigateToFuture: function (e) {
            if (e) e.preventDefault();
            var currentViewIndex = this.currentView.index;

            if (currentViewIndex == 0)
                this.viewedMonth.date(32).date(1);
            else
                this.viewedMonth.addYear(Math.pow(10, currentViewIndex - 1));

            this.navigateHorizontally(currentViewIndex, this.viewedMonth.toDate(), true);
        },

        _footer: function (format) {
            var that = this,
                footer = that.footer,
                today = new Date(),
                formattedValue = $.telerik.datetime.format(today, format || "d");


            if (!footer) {
                that.footer = footer = $('<div style="display:none" class="t-footer"><a href="#" class="t-link t-nav-today"></a></div>');
                $(that.element).append(footer);
                footer.find("a").click(function (e) {
                    e.preventDefault();

                    if (!that.selectedDate || (that.selectedDate > today || today > that.selectedDate)) {
                        if (!$t.trigger(that.element, 'change', {
                            previousDate: that.selectedDate,
                            date: today
                        })) {
                            that.selectedDate = today;
                            that.updateSelection();
                        }
                    }
                });
            }

            footer.find("a")
                  .attr("title", formattedValue)
                  .html(formattedValue);

            footer.toggle(!!format);
        }
    }

    $.fn.tCalendar = function (options) {
        return $t.create(this, {
            name: 'tCalendar',
            init: function (element, options) {
                return new $t.calendar(element, options);
            },
            options: options
        });
    };

    $.fn.tCalendar.defaults = {
        selectedDate: null,
        minDate: new Date(1899, 11, 31),
        maxDate: new Date(2100, 0, 1)
    };

    $.extend($t.calendar, {
        views: [{
            /* Month */
            index: 0,
            title: function (viewedMonth) {
                return new $t.stringBuilder()
			        .cat($t.cultureInfo.months[viewedMonth.month()])
			        .cat(' ')
			        .cat(viewedMonth.year()).string();
            },
            body: function (viewedMonth, minDate, maxDate, selectedDate, urlFormat, dates) {
                var html = (new $t.stringBuilder())
			               .cat('<thead><tr>');

                var firstDayIndex = $t.cultureInfo.firstDayOfWeek,
                    days = $t.cultureInfo.days,
                    abbrDays = $t.cultureInfo.abbrDays,
                    shortestDays = $t.cultureInfo.shortestDays;

                days = days.slice(firstDayIndex).concat(days.slice(0, firstDayIndex));
                abbrDays = abbrDays.slice(firstDayIndex).concat(abbrDays.slice(0, firstDayIndex));
                shortestDays = shortestDays.slice(firstDayIndex).concat(shortestDays.slice(0, firstDayIndex));

                for (var i = 0; i < 7; i++) {
                    html.cat('<th scope="col" abbr="')
                        .cat(abbrDays[i])
                        .cat('" title="')
                        .cat(days[i])
                        .cat('">')
                        .cat(shortestDays[i])
                        .cat('</th>');
                }

                html.cat('</tr></thead><tbody>');

                var currentDayInCalendar = $t.datetime.firstVisibleDay(viewedMonth);

                var month = viewedMonth.month();

                var selectedDateInViewedMonth = selectedDate === null ? false :
                                                viewedMonth.year() == selectedDate.year();
                var cellClass;

                for (var weekRow = 0; weekRow < 6; weekRow++) {

                    html.cat('<tr>');

                    for (var day = 0; day < 7; day++) {
                        cellClass =
			            currentDayInCalendar.month() != month ? 't-other-month' :
			            (selectedDateInViewedMonth
			            && currentDayInCalendar.month() == selectedDate.month()
			            && currentDayInCalendar.date() == selectedDate.date()) ? ' t-state-selected' : '';

                        html.cat('<td')
			                .catIf(' class="' + cellClass + '"', cellClass)
			                .cat('>');

                        if ($t.calendar.isInRange(currentDayInCalendar.toDate(), minDate.toDate(), maxDate.toDate())) {
                            html.cat('<a href="')
                            var url = '#';
                            if (urlFormat) {
                                url = $t.calendar.formatUrl(urlFormat, currentDayInCalendar);
                                if (dates && !$t.calendar.isInCollection(currentDayInCalendar, dates)) {
                                    url = '#';
                                }
                            }

                            html.cat(url)
			                    .cat('" class="t-link')
			                    .cat(url != '#' ? ' t-action-link' : '')
                                .cat('" title="')
                                .cat($t.datetime.format(currentDayInCalendar.toDate(), $t.cultureInfo.longDate))
			                    .cat('">')
			                    .cat(currentDayInCalendar.date())
			                    .cat('</a>');
                        } else {
                            html.cat('&nbsp;');
                        }
                        html.cat('</td>');

                        $t.datetime.modify(currentDayInCalendar, $t.datetime.msPerDay);
                    }

                    html.cat('</tr>');
                }
                html.cat('</tbody>');
                return html.string();
            },
            compare: function (date1, date2) {
                var result;
                var date1Month = date1.month();
                var date1Year = date1.year();
                var date2Month = date2.month();
                var date2Year = date2.year();

                if (date1Year > date2Year)
                    result = 1;
                else if (date1Year < date2Year)
                    result = -1;
                else // date1Year == date2Year
                    result = date1Month == date2Month ? 0 :
			                 date1Month > date2Month ? 1 : -1;
                return result;
            },
            firstLastDay: function (date, isFirstDay, calendar) {
                return isFirstDay ? $t.datetime.firstDayOfMonth(date) : new $t.datetime(date.year(), date.month() + 1, 0);
            },
            navCheck: function (date1, date2, isBigger) {
                if (isBigger) {
                    return new $t.datetime(date2.year(), date2.month() + 1, date2.date()).value - date1.value <= 0;
                } else {
                    return this.compare(date1, date2) === -1;
                }
            }
        },
			 {   /*Year*/
			     index: 1,
			     title: function (viewedMonth) { return viewedMonth.year(); },
			     body: function (viewedMonth, minDate, maxDate) {
			         return $t.calendar.metaView(true, viewedMonth, function () {
			             var result = [];

			             var startMonth = 0;
			             var endMonth = 11;

			             if (minDate.year() == maxDate.year()) {
			                 startMonth = minDate.month();
			                 endMonth = maxDate.month();
			             }
			             else if (viewedMonth.year() == minDate.year())
			                 startMonth = minDate.month();
			             else if (viewedMonth.year() == maxDate.year())
			                 endMonth = maxDate.month();

			             for (var i = 0; i < 12; i++) {
			                 if (i >= startMonth && i <= endMonth)
			                     result.push($t.cultureInfo.abbrMonths[i]);
			                 else
			                     result.push('&nbsp;');
			             }

			             return result;
			         });
			     },
			     compare: function (date1, date2) {
			         return date1.year() > date2.year() ? 1 : date1.year() < date2.year() ? -1 : 0;
			     },
			     verticalDate: function (date, clickedText) {
			         if (!clickedText)
			             return date.month();
			         date.month($.inArray(clickedText, $t.cultureInfo.abbrMonths));
			     },
			     firstLastDay: function (date, isFirstDay) {
			         return new $t.datetime(date.year(), isFirstDay ? 0 : 11, 1);
			     },
			     navCheck: function (date1, date2, isBigger) {
			         var tmp = this.compare(date1, date2);
			         return isBigger ? tmp == 1 : tmp == -1;
			     }
			 },
			 {   /*Decade*/
			     index: 2,
			     title: function (viewedMonth) {
			         var firstYearInDecade = viewedMonth.year() - viewedMonth.year() % 10;
			         return firstYearInDecade + '-' + (firstYearInDecade + 9);
			     },
			     body: function (viewedMonth, minDate, maxDate) {
			         return $t.calendar.metaView(false, viewedMonth, function () {
			             var result = [];
			             var minYear = minDate.year();
			             var maxYear = maxDate.year();
			             var year = viewedMonth.year() - viewedMonth.year() % 10 - 1;

			             for (var i = 0; i < 12; i++)
			                 result.push(year + i >= minYear && year + i <= maxYear ? year + i : '&nbsp;');

			             return result;
			         });
			     },
			     compare: function (date1, date2, checkBigger) {
			         var year = date1.year();
			         var minDecade = (year - year % 10);
			         var maxDecade = (year - year % 10 + 9);
			         return $t.calendar.check(minDecade, maxDecade, date2, checkBigger);
			     },
			     verticalDate: function (date, clickedText) {
			         if (!clickedText)
			             return date.year() % 10 + 1;
			         date.year(clickedText);
			     },
			     firstLastDay: function (date, isFirstDay) {
			         return new $t.datetime(date.year() - date.year() % 10 + (isFirstDay ? 0 : 9), 0, 1);
			     },
			     navCheck: function (date1, date2, isBigger) {
			         var tmp = this.compare(date2, date1, isBigger);
			         return isBigger ? tmp == -1 : tmp == 1;
			     }
			 },
			 {   /*Century*/
			     index: 3,
			     title: function (viewedMonth) {
			         var firstYearInCentury = viewedMonth.year() - viewedMonth.year() % 100;

			         return firstYearInCentury + '-' + (firstYearInCentury + 99);
			     },
			     body: function (viewedMonth, minDate, maxDate) {
			         return $t.calendar.metaView(false, viewedMonth, function () {
			             var firstYearInCentury = viewedMonth.year() - viewedMonth.year() % 100;

			             var result = [];

			             for (var i = -1; i < 11; i++) {
			                 var firstYearInCenturyTemp = firstYearInCentury + i * 10;
			                 if ((firstYearInCenturyTemp + 10) >= minDate.year() && firstYearInCenturyTemp <= maxDate.year())
			                     result.push(firstYearInCenturyTemp + '-<br />' +
			                     (firstYearInCenturyTemp + 9) + '&nbsp;');
			                 else
			                     result.push('&nbsp;<br />&nbsp;');
			             }
			             return result;
			         });
			     },
			     compare: function (date1, date2, checkBigger) {
			         var year = date1.year();
			         var minCentury = (year - year % 100);
			         var maxCentury = (year - year % 100 + 99);
			         return $t.calendar.check(minCentury, maxCentury, date2, checkBigger);
			     },
			     verticalDate: function (date, clickedText) {
			         if (!clickedText)
			             return Math.ceil(date.year() / 10) % 10 + 1;

			         date.year(clickedText.substring(0, clickedText.indexOf('-')));
			     },
			     firstLastDay: function (date, isFirstDay) {
			         return isFirstDay ? new $t.datetime(date.year() - (date.year() % 100), 0, 1) :
			                new $t.datetime(date.year() - (date.year() % 100) + 99, 0, 1);
			     },
			     navCheck: function (date1, date2, isBigger) {
			         var tmp = this.compare(date2, date1, isBigger);
			         return isBigger ? tmp == -1 : tmp == 1;
			     }
			 }],

        check: function (value1, value2, date, checkBigger) {
            var check = function (val) {
                return val < date.year() ? -1 :
			 val > date.year() ? 1 : 0;
            }
            return checkBigger ? check(value2) : check(value1);
        },

        html: function (viewedMonth, selectedDate, minDate, maxDate, urlFormat, dates) {
            viewedMonth = viewedMonth || new $t.datetime();
            minDate = minDate || new $t.datetime($.fn.tCalendar.defaults.minDate);
            maxDate = maxDate || new $t.datetime($.fn.tCalendar.defaults.maxDate);

            return new $t.stringBuilder().cat('<div class="t-widget t-calendar">')
			                             .cat('<div class="t-header">')
			                             .cat('<a href="#" class="t-link t-nav-prev">')
			                             .cat('<span class="t-icon t-arrow-prev"></span></a><a href="#" class="t-link t-nav-fast">')
			                             .cat($t.calendar.views[0].title(viewedMonth))
			                             .cat('</a>')
			                             .cat('<a href="#" class="t-link t-nav-next"><span class="t-icon t-arrow-next"></span></a>')
			                             .cat('</div>')
			                             .cat('<table class="t-content" cellspacing="0">')
			                             .cat($t.calendar.views[0].body(viewedMonth, minDate, maxDate, selectedDate, urlFormat, dates))
			                             .cat('</table></div>')
			                             .string();
        },

        metaView: function (isYearView, viewedMonth, getCollection) {
            var html = new $t.stringBuilder();

            var collection = getCollection();

            html.cat('<tr>');

            // build 4x3 table
            for (var i = 0, len = collection.length; i < len; i++) {

                html.catIf('</tr><tr>', i > 0 && i % 4 == 0)
			        .cat('<td')
			        .catIf(' class="t-other-month"', (i == 0 || i == len - 1) && isYearView == false)
			        .cat('>');

                if (collection[i] !== '&nbsp;' && collection[i] !== '&nbsp;<br />&nbsp;')
                    html.cat('<a href="#" class="t-link">')
			            .cat(collection[i]).cat('</a>')
                else
                    html.cat(collection[i]);

                html.cat('</td>');
            }

            html.cat('</tr>');

            return html.string();
        },

        isInRange: function (date, minDate, maxDate) {
            if (!date) return false;

            var d = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            var min = new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate());
            var max = new Date(maxDate.getFullYear(), maxDate.getMonth(), maxDate.getDate());

            return min - d <= 0 && max - d >= 0;
        },

        fitDateToRange: function (date, minDate, maxDate) {
            if (date.value < minDate.value) date = new $t.datetime(minDate.value)
            if (date.value > maxDate.value) date = new $t.datetime(maxDate.value)
            return date;
        },

        isInCollection: function (date, dates) {
            var months = dates[date.year()];
            if (months) {
                var days = months[date.month()];
                if (days && $.inArray(date.date(), days) != -1)
                    return true;
            }
            return false;
        },

        findTarget: function (focusedDate, viewedIndex, calendar, isFuture) {
            focusedDate = focusedDate.value ? focusedDate : new $t.datetime(focusedDate);
            var findTarget = function (collection, searchedText) {
                return $.grep(collection, function (item) {
                    return $(item).children().eq(0).text().indexOf(searchedText) > -1;
                })[0];
            }

            var selector = isFuture ? 'last' : 'first';
            var cells = $('.t-content:' + selector + ' td:has(> .t-link)', calendar).removeClass('t-state-focus');

            var $target;
            if (viewedIndex == 0) {
                $target = $(findTarget(cells.filter(':not(.t-other-month)'), focusedDate.date()));
            } else if (viewedIndex == 1) {
                $target = $(findTarget(cells, $t.cultureInfo.abbrMonths[focusedDate.month()]));
            } else if (viewedIndex == 2 || viewedIndex == 3) {
                var year = focusedDate.year();
                $target = $(findTarget(cells, viewedIndex == 2 ? year : year - (year % 10)));
                if ($target.length == 0 && viewedIndex == 3)
                    $target = $(findTarget(cells, year - (year % 10) + 99));
            }
            return $target;
        },

        focusDate: function (focusedDate, viewedIndex, calendar, isFuture) {
            $t.calendar.findTarget(focusedDate, viewedIndex, calendar, isFuture).addClass('t-state-focus');
        },

        formatUrl: function (urlFormat, date) {
            var format = urlFormat.match(dateFormatRegExp);
            if (format) {
                format = format[0];
                var dateFormat = format === "{0}" ? $t.cultureInfo.generalDateTime : format.replace(replaceUrlRegExp, "").replace("}", "");

                return urlFormat.replace(format, $t.datetime.format(date.toDate(), dateFormat));
            }
            return urlFormat;
        }
    });

})(jQuery);
(function ($) {

    var $t = $.telerik;
    $t.scripts.push("telerik.combobox.js");

    $t.combobox = function (element, options) {
        if (options && options.enabled === undefined) {
            options.enabled = !$(element).is("[disabled]");
        }

        $.extend(this, options);

        var isTextBox = element.nodeName.toLowerCase() == 'input' && element.type.toLowerCase() == 'text';
        var isSelect = element.nodeName.toLowerCase() == 'select';

        if ((isTextBox || isSelect) && !$(element).parent().hasClass("t-combobox")) {
            if (isSelect && !this.data) {
                this.data = $t.list.retrieveData(element);
            }

            var htmlBuilder = new $t.list.htmlBuilder(element, 't-combobox', isSelect);

            htmlBuilder.text = function (options) {
                var builder = options.builder;
                builder.buffer = [];
                return $(builder
                        .cat('<input class="t-input" autocomplete="off" type="text" ')
                        .catIf('value="', options.text, '" ', options.text)
                        .catIf('name="', options.name, '-input" ', options.name)
                        .cat('/>')
                        .string());
            }

            htmlBuilder.render();

            if (isSelect) {
                element = element.previousSibling; //set element to input
            }
        }

        this.element = element;

        var that = this;
        var $element = this.$element = $(element).closest("form")
                                            .bind("reset", function () {
                                                setTimeout(function () {
                                                    that.value(element.value);
                                                });
                                            })
                                            .end();

        this.loader = new $t.list.loader(this);
        this.trigger = new $t.list.trigger(this);
        var $wrapper = this.$wrapper = $element.closest('.t-combobox');
        var $selectIcon = this.$wrapper.find('.t-select');

        var $text = this.$text = this.$wrapper.find('> .t-dropdown-wrap > .t-input')
                                     .attr('autocomplete', 'off')
                                     .bind("paste", $.proxy(function (e) {
                                         setTimeout($.proxy(function () {
                                             this.$element.val(e.target.value);
                                             resetTimer(this);
                                         }, this), 0);
                                     }, this));

        var updateCssOnPropertyChange = function (e) {
            var attr = "class",
                classValue = $element.attr(attr) || "";

            if ((e.attrName && e.attrName == attr) || (e.propertyName && e.propertyName == "className")) {
                if (classValue != $text.attr(attr)) {
                    $text.attr(attr, classValue).addClass('t-input');
                }
            }
        }

        if ($.browser.msie) {
            element.attachEvent("onpropertychange", updateCssOnPropertyChange);

        } else {
            $element.bind("DOMAttrModified", updateCssOnPropertyChange);
        }

        $element.closest("form").bind("reset", $.proxy(function (e) {
            var that = this;
            window.setTimeout(function () {
                if ($element.val() != "") {
                    that.value($element.val());
                } else {
                    that.highlight(0);
                    that.selectedIndex = 0;
                }
            }, 1);
        }, this));

        this.filtering = new $t.list.filtering(this);
        this.filtering.autoFill = function (component, itemText) {
            if (component.autoFill && (component.lastKeyCode != 8 && component.lastKeyCode != 46)) {

                var input = component.$text[0];

                var endIndex = $t.caretPos(input);

                var filterString = input.value.substring(0, endIndex);

                var matchIndex = itemText.toLowerCase().indexOf(filterString.toLowerCase());

                if (matchIndex != -1) {

                    var stringToAppend = itemText.substring(matchIndex + filterString.length);

                    input.value = filterString + stringToAppend;

                    $t.list.selection(input, endIndex, endIndex + stringToAppend.length);
                }
            }
        }

        this.dropDown = new $t.dropDown({
            attr: this.dropDownAttr,
            effects: this.effects,
            onOpen: $.proxy(function () {
                var data = this.data;
                var dropDown = this.dropDown;
                if (data.length == 0) return;

                var text = this.$text.val();
                var selectedIndex = this.selectedIndex;

                if (selectedIndex != -1 && this.isFiltered) {
                    if (text == data[selectedIndex].Text) {
                        this.filteredDataIndexes = [];
                        dropDown.onItemCreate = null;
                        if (this.filter) {
                            dropDown.dataBind(this.data, this.encoded);
                        }
                        this.select(dropDown.$items[selectedIndex]);
                    } else
                        this.filters[this.filter](this, this.data, text);

                    this.isFiltered = false;
                }
            }, this),
            onClick: $.proxy(function (e) {
                this.select(e.item);
                this.trigger.change();
                this.trigger.close();
                $text.focus();
            }, this)
        });

        this.dropDown.$element.css('direction', $wrapper.closest('.t-rtl').length ? 'rtl' : '');

        this.enable = function () {
            $wrapper.removeClass('t-state-disabled');
            $text.removeAttr("disabled");
            $element.removeAttr("disabled");
            if (!$selectIcon.data("events")) {
                $selectIcon.bind('click', $.proxy(togglePopup, this));
            }
        }

        this.disable = function () {
            $wrapper.addClass('t-state-disabled')
            $text.attr('disabled', 'disabled');
            $element.attr('disabled', 'disabled');
            $selectIcon.unbind('click');
        }

        this[this.enabled ? 'enable' : 'disable']();

        this.fill = function (callback, options, ignoreInputValue) {
            function updateSelection(component) {
                var value = component.selectedValue || component.value();

                if (value) {
                    component.value(value);
                    return;
                }

                var $items = dropDown.$items;
                var selectedIndex = component.index;
                var $selectedItems = $items.filter('.t-state-selected')
                var selectedItemsLength = $selectedItems.length;

                var item = selectedIndex != -1 && selectedIndex < $items.length
                    ? $items[selectedIndex]
                    : selectedItemsLength > 0
                    ? $selectedItems[selectedItemsLength - 1]
                    : null;

                if (item)
                    component.select(item);
                else {
                    component.selectedIndex = -1;
                    if (component.highlightFirst)
                        component.highlight($items[0]);
                }

                component._oldIndex = component.selectedIndex;
            }

            var loader = this.loader;
            var dropDown = this.dropDown;
            var minChars = this.minChars;
            var textValue = this.text();
            var textValueLength = textValue.length;

            if (!dropDown.$items && !loader.ajaxError) {
                if ((loader.isAjax() || this.onDataBinding) && textValueLength >= minChars) {
                    options = options || {};
                    var postData = $.extend({}, options);
                    if (ignoreInputValue) {
                        textValue = "";
                    }
                    postData[this.queryString.text] = textValue;

                    loader.ajaxRequest(function (data) {
                        this.dataBind(data, true);
                        updateSelection(this);

                        $t.trigger(this.element, 'dataBound');
                        this.trigger.change();

                        if (callback) callback();
                    },
                    { data: postData });
                }
                else {
                    this.dataBind(this.data, true);
                    updateSelection(this);
                    if (callback) callback();
                }
            }
        }

        this.reload = function () {
            this.dropDown.$items = null;
            if (arguments.length) {
                this.fill(arguments[0], arguments[1]);
            } else {
                this.fill();
            }
        }

        this.select = function (item) {
            var index = this.highlight(item);

            if (index != -1) {
                var filteredDataIndexes = this.filteredDataIndexes;

                //set selected Index
                this.selectedIndex = (filteredDataIndexes && filteredDataIndexes.length) > 0 ? filteredDataIndexes[index] : index;

                var dataItem = this.data[this.selectedIndex];

                $t.list.updateTextAndValue(this, dataItem.Text, dataItem.Value);
            }

            return index;
        }

        this.text = function () {
            return this.$text.val.apply(this.$text, arguments);
        }

        this.value = function () {
            if (arguments.length) {
                var value = arguments[0];
                var index = this.select(function (dataItem) {
                    return value == (dataItem.Value || dataItem.Text);
                });

                if (index == -1) {
                    this.selectedIndex = index;
                    this.$element.val(value);
                    this.text(value);
                }
                this.previousValue = this.$element.val(); //prevent change event
                this._oldIndex = this.selectedIndex;

            } else {
                return this.$element.val();
            }
        }

        $t.list.common.call(this);
        $t.list.filters.call(this);
        $t.list.initialize.call(this);

        $(document.documentElement).bind('mousedown', $.proxy(function (e) {
            var $dropDown = this.dropDown.$element;
            var isDropDown = $dropDown && $dropDown.parent().length > 0;

            if ($.contains(this.$wrapper[0], e.target)
                || (isDropDown && $.contains($dropDown.parent()[0], e.target)))
                return;

            if (this._textChanged) {
                this._textChanged = false;
                var data = findItemByText(this.data, this.$text.val(), this.ignoreCase);
                if (data) {
                    this.selectedIndex = data.index;
                    this.text(data.dataItem.Text);
                    this.$element.val(data.dataItem.Value || data.dataItem.Text);
                } else {
                    this.selectedIndex = -1;
                    this.$element.val(this.$text.val());
                }
            }

            this.trigger.change();
            this.trigger.close();
        }, this));

        this.$text
            .bind({
                keydown: $.proxy(keydown, this),
                keypress: $.proxy(keypress, this),
                focus: $.proxy(function (e) {
                    if (this.openOnFocus) {
                        var trigger = this.trigger;
                        var dropDown = this.dropDown;
                        if (!dropDown.$items) {
                            this.fill(trigger.open);
                        } else {
                            trigger.open();
                        }
                    }
                    var $text = this.$text;

                    clearTimeout(this.selectTextTimeout);
                    this.selectTextTimeout = window.setTimeout(function () { $t.list.selection($text[0], 0, $text.val().length); }, 130); //depends on the PC :(
                }, this),
                blur: $.proxy(function () {
                    clearTimeout(this.selectTextTimeout);
                }, this)
            });

        function togglePopup(e) {
            var dropDown = this.dropDown,
                trigger = this.trigger;

            this.loader.ajaxError = false;
            if (!dropDown.isOpened()) {
                if (!dropDown.$items) {
                    this.fill(trigger.open, {}, true);
                } else {
                    trigger.open();
                }
                $text[0].focus();
            } else {
                trigger.close();
            }
        }

        //PRIVATE
        function resetTimer(component) {
            clearTimeout(component.timeout);
            component.timeout = setTimeout(function () { component.filtering.filter(component) }, component.delay);
        }

        function keydown(e) {
            var trigger = this.trigger;
            var dropDown = this.dropDown;
            var key = e.keyCode || e.which;
            this.lastKeyCode = key;

            if (e.altKey) {
                if (key == 38 || key == 40) {
                    var action = key == 38 ? trigger.close : trigger.open;
                    if (!dropDown.$items) {
                        this.fill(action); //creates items 
                    } else {
                        action();
                    }
                }
                return;
            }

            if (!e.shiftKey && (key == 38 || key == 40)) {

                e.preventDefault();

                var selectItem = $.proxy(function () {
                    var $items = dropDown.$items,
                        $selectedItem = $items.filter('.t-state-selected:first');

                    var $item = $selectedItem.length == 0 || $items.length == 1 || this.selectedIndex == -1 ? $items.first()
                                 : (key == 38) ? $selectedItem.prev() // up
                                 : (key == 40) ? $selectedItem.next() // down
                                 : [];

                    if ($item.length) {
                        var item = $item[0];

                        this.select(item);
                        dropDown.scrollTo(item);

                        if (!dropDown.isOpened()) {
                            trigger.change();
                        }
                    }
                }, this);

                if (!dropDown.$items) {

                    if (this.index != -1 || this.value() || this.selectedValue) {
                        selectItem = null;
                    }

                    this.fill(selectItem); //creates items 
                    return;
                }

                selectItem();
                return;
            }

            if (key == 8 || key == 46 || (e.ctrlKey && key == 88)) {
                var $text = this.$text;

                if ($text.val() != '') resetTimer(this); //reset and start filtering after delay

                setTimeout($.proxy(function () {
                    if ($text.val() == '') {
                        this.selectedIndex = -1;
                        this.$element.val('');
                    } else {
                        this.$element.val(this.$text.val());
                    }
                }, this), 0);

                return;
            }

            if (key == 13) {
                if (dropDown.isOpened()) {
                    e.preventDefault();

                    var $selectedItems = dropDown.$items.filter('.t-state-selected:first');

                    if ($selectedItems.length > 0)
                        this.select($selectedItems[0]);
                    else
                        this.$element.val(this.$text.val());

                    trigger.change();
                    trigger.close();
                    $t.list.moveToEnd(this.$text[0]);
                }
                return;
            }

            if (key == 27 || key == 9) {
                clearTimeout(this.timeout);
                var data;

                if (this.selectedIndex !== undefined && this.selectedIndex > -1 && this.data[this.selectedIndex].Text === this.$text.val()) {
                    data = { dataItem: this.data[this.selectedIndex], index: this.selectedIndex };
                } else {
                    data = findItemByText(this.data, this.$text.val(), this.ignoreCase);
                }

                if (data) {
                    this.selectedIndex = data.index;
                    this.text(data.dataItem.Text);
                    this.$element.val(data.dataItem.Value || data.dataItem.Text);
                } else {
                    this.selectedIndex = -1;
                    this.$element.val(this.$text.val());
                }

                trigger.change();
                trigger.close();
                if (key == 27) this.$text.blur();
                return;
            }

            resetTimer(this);
        }

        function keypress(e) {
            this._textChanged = true;
            var key = e.keyCode || e.charCode;

            if (!e.shiftKey && (key == 0 || $.inArray(key, $t.list.keycodes) != -1 || e.ctrlKey)) return true;

            // always set value. Select(item) will override it if needed.
            setTimeout($.proxy(function () { this.$element.val(this.$text.val()); }, this), 0);
        }

        if (that.cascadeTo) {
            var cascadingElement = $("#" + that.cascadeTo).attr("disabled", "disabled");

            cascadingElement.bind("load", function () {
                if (that.selectedValue || that.value()) { //that.value()) {
                    that.$element.trigger("valueChange");
                }
            })

            that.$element.bind("valueChange", $.proxy(function () {
                var combobox = cascadingElement.data("tComboBox");
                if (combobox) {
                    var tempData = [],
                        data = {};

                    data[that.$element.attr("name")] = that.value();

                    if (combobox.loader.isAjax()) {
                        if (that.placeholder) {
                            tempData[0] = {
                                Text: that.placeholder,
                                Value: ""
                            };
                        }
                        combobox.dataBind(tempData);
                    }

                    combobox.select(0);
                    combobox.disable();
                    if ((that.selectedValue || that.value()) === "" && that.placeholder) {
                        combobox.$element.trigger("valueChange");
                        return;
                    }

                    combobox.reload(function () {
                        var idx = tempData[0] ? 1 : 0;
                        if (combobox.data[idx]) {
                            combobox.enable();
                        } else {
                            combobox.value("");
                        }
                    }, data);
                }
            }, that));
        }
    }

    function findItemByText(data, inputText, ignoreCase) {
        if (!inputText) {
            return;
        }

        if (data) {
            //find if text has exact match with one of data items.
            for (var i = 0, len = data.length; i < len; i++) {
                var dataItem = data[i],
                    text = dataItem.Text;

                if (ignoreCase) {
                    text = text.toLowerCase();
                    inputText = inputText.toLowerCase();
                }

                if (text == inputText) {
                    return { dataItem: dataItem, index: i };
                }
            }
        }
    }

    $.fn.tComboBox = function (options) {
        return $t.create(this, {
            name: 'tComboBox',
            init: function (element, options) {
                return new $t.combobox(element, options)
            },
            options: options
        });
    };

    // default options
    $.fn.tComboBox.defaults = {
        ignoreCase: true,
        encoded: true,
        openOnFocus: false,
        effects: $t.fx.slide.defaults(),
        index: -1,
        autoFill: true,
        highlightFirst: true,
        filter: 0,
        delay: 200,
        minChars: 0,
        cache: true,
        queryString: {
            text: 'text'
        }
    };
})(jQuery);
(function ($) {

    var $t = $.telerik;
    $t.scripts.push("telerik.datepicker.js");

    var sharedCalendar = null,
		mobileSafari = (navigator.userAgent.search(/like\sMac\sOS\sX;.*Mobile\/\S+/) != -1),
		mobileSafari41 = (navigator.userAgent.search(/4_1\slike\sMac\sOS\sX;.*Mobile\/\S+/) != -1); // The bug is undetectable there.

    $t.datetime.parseByToken = function (value, today) {
        if (value === null || value === '') return null;

        today = today || new $t.datetime(); // required for unit tests
        var firstToken = null;
        var secondToken = null;
        var tokenType = null;
        var pos = 0;

        var Matches = function (name) {
            var token = null;
            if (name && value.substring(pos, pos + name.length).toLowerCase() == name.toLowerCase()) {
                token = name;
            }
            return token;
        }

        var searchForDayMonth = function () {
            var token = null;
            $.each(['days', 'abbrDays', 'months', 'abbrMonths'], function (index, key) {
                if (token !== null) return;

                $.each($t.cultureInfo[key], function (index, name) {
                    if (token !== null) return;
                    token = Matches(name);
                });

                tokenType = key;
            });
            return token;
        }

        var adjustDate = function () {
            var gap;
            var modifyDate = function (mod, isday) {
                today[isday ? 'date' : 'month']
                    (today[isday ? 'date' : 'month']()
                     + (gap != 0 ? ((gap + ((gap > 0 ? 1 : -1) * mod)) % mod) : 0)
                        + (secondToken ?
                            (firstToken == $t.cultureInfo['next'] ? 1 : -1) * mod : 0));
            }
            var arrayPosition = $.inArray(secondToken || firstToken, $t.cultureInfo[tokenType]);
            if (tokenType.toLowerCase().indexOf('day') > -1) {
                gap = (arrayPosition == 0 ? 7 : arrayPosition) - today.day();
                modifyDate(7, true)
            } else {
                gap = arrayPosition - today.month();
                modifyDate(12, false)
            }
        }

        var adjustDateBySecondToken = function () {
            var gapDiff = function (possition) {
                var gap;
                switch (secondToken) {
                    case 'year': gap = possition == 1 ? 1 : 0; break;
                    case 'month': gap = possition == 2 ? 1 : 0; break;
                    case 'week': gap = possition == 3 ? 7 : 0; break;
                    case 'day': gap = possition == 3 ? 1 : 0; break;
                }
                return gap;
            }
            var direction = (firstToken == $t.cultureInfo['next'] ? 1 : -1);
            today.year(
                    today.year() + gapDiff(1) * direction,
                    today.month() + gapDiff(2) * direction,
                    today.date() + gapDiff(3) * direction
                );
        }

        // search for first token
        $.each(['today', 'tomorrow', 'yesterday', 'next', 'last'], function (index, name) {
            if (firstToken !== null) return;
            firstToken = Matches($t.cultureInfo[name]);
        })

        if (firstToken !== null) {
            pos += firstToken.length;

            if (/[^\s\d]\s+[^\s\d]/i.test(value)) {
                pos++;
                $.each(['year', 'month', 'week', 'day'], function (index, name) {
                    if (secondToken !== null) return;
                    secondToken = Matches($t.cultureInfo[name]);
                })
                tokenType = null;

                if (secondToken === null) {
                    secondToken = searchForDayMonth();
                }
                if (secondToken === null)
                    return null; // invalid date.
            } else {
                switch (firstToken) {
                    case $t.cultureInfo['today']: break;
                    case $t.cultureInfo['tomorrow']:
                        today.date(today.date() + 1);
                        break;
                    case $t.cultureInfo['yesterday']:
                        today.date(today.date() - 1);
                        break;
                    default:
                        today = null; // incorrect token
                        break;
                }

                return today;
            }

        } else {
            firstToken = searchForDayMonth();
            if (firstToken != null) {
                adjustDate();
                return today;
            } else {
                return null;
            }
        }

        // first and second tokens are not null
        if (tokenType !== null)
            adjustDate();
        else // second token is year, month, week, day
            adjustDateBySecondToken();

        return today;
    };

    function defineFocusedDate(focusedValue, selectedValue, minValue, maxValue) {
        if (selectedValue) {
            focusedValue = new Date(selectedValue);
        }

        if (minValue > focusedValue) {
            focusedValue = new Date(minValue);
        } else if (maxValue < focusedValue) {
            focusedValue = new Date(maxValue);
        }

        return focusedValue;
    }

    /*
    options.minValue
    options.maxValue
    options.selectedValue
    options.effects
    options.onChange
    options.isRtl
    options.zIndex
    */

    $t.dateView = function (options) {
        $.extend(this, options);
        this.isValueChanged = false;

        this.focusedValue = defineFocusedDate(new Date(), this.selectedValue, this.minValue, this.maxValue);

        this.$calendar = this._createSharedCalendar();
    }

    $t.dateView.prototype = {
        _createSharedCalendar: function () {
            if (!sharedCalendar) {
                sharedCalendar = $($t.calendar.html(new $t.datetime(this.focusedValue), this.selectedValue ? new $t.datetime(this.selectedValue) : null, new $t.datetime(this.minValue), new $t.datetime(this.maxValue)))
                                .hide()
                                .addClass('t-popup t-datepicker-calendar')
                                .appendTo(document.body)
                                .tCalendar({
                                    selectedValue: this.selectedValue,
                                    minDate: this.minValue,
                                    maxDate: this.maxValue
                                });

                if ($.browser.msie && parseInt($.browser.version) < 7) {
                    sharedCalendar.prepend('<iframe src="javascript:\'\';" style="position:absolute; width: 100%; height: 190px; border: 0; top: 0; left: 0; opacity: 0; filter:alpha(opacity=0);"></iframe>');
                }

                $t.fx._wrap(sharedCalendar).css('display', 'none');

                if ($.browser.msie && $.browser.version <= 6)
                    $('<iframe class="t-iframe-overlay" src="javascript:false;"></iframe>')
                        .prependTo(sharedCalendar)
                        .height(sharedCalendar.height());
            }

            return sharedCalendar;
        },

        _getCalendar: function () {
            return sharedCalendar.data('tCalendar');
        },

        _reassignSharedCalendar: function () {
            var calendar = this._getCalendar();

            if (sharedCalendar.data('associatedDateView') != this) {
                sharedCalendar.stop(true, true);

                this.focusedValue = defineFocusedDate(this.focusedValue, this.selectedValue, this.minValue, this.maxValue);

                calendar.minDate = this.minValue;
                calendar.maxDate = this.maxValue;
                calendar.selectedValue = this.selectedValue;
                calendar.goToView(0, this.focusedValue);
                calendar._footer(this.todayFormat);

                sharedCalendar
                    .unbind('change')
                    .bind('change', $.proxy(function (e) {
                        var selectedValue = this.selectedValue;
                        var newValue = new $t.datetime(e.date);
                        if (selectedValue !== null)
                            newValue.hours(selectedValue.getHours())
                                    .minutes(selectedValue.getMinutes())
                                    .seconds(selectedValue.getSeconds())
                                    .milliseconds(selectedValue.getMilliseconds());
                        this.onChange(newValue.toDate());
                    }, this))
                    .unbind('navigate')
                    .bind('navigate', $.proxy(function (e) {
                        var focusedValue = this.focusedValue;
                        var viewedMonth = calendar.viewedMonth;
                        var viewIndex = calendar.currentView.index;

                        focusedValue.setFullYear(viewedMonth.year(), viewedMonth.month(), focusedValue.getDate());

                        $t.calendar.focusDate(focusedValue, viewIndex, sharedCalendar, e.direction);

                    }, this))
                    .data('associatedDateView', this);

                calendar.value(this.selectedValue);

                $t.calendar.focusDate(this.focusedValue, calendar.currentView.index, sharedCalendar);
            }
        },

        open: function (position) {
            if (this.isOpened())
                return;

            this._reassignSharedCalendar();

            var isRtl = this.isRtl;
            var $calendar = this.$calendar;

            // reposition & rewire the shared calendar
            elementPosition = position.offset;
            elementPosition.top += position.outerHeight;

            if (mobileSafari) {
                if (!document.body.scrollLeft && !mobileSafari41)
                    elementPosition.left -= window.pageXOffset;
                if (!document.body.scrollTop && !mobileSafari41)
                    elementPosition.top -= window.pageYOffset;
            }

            if (isRtl)
                elementPosition.left -= (sharedCalendar.outerWidth() || sharedCalendar.parent().outerWidth()) - position.outerWidth;

            $t.fx._wrap(sharedCalendar).css($.extend({
                position: 'absolute',
                direction: isRtl ? 'rtl' : '',
                display: sharedCalendar.is(':visible') ? '' : 'none'
            }, elementPosition));

            var calendar = this._getCalendar();
            var viewIndex = calendar.currentView.index;

            if (!sharedCalendar.is(':visible') && calendar.viewedMonth.value - this.focusedValue != 0) {
                calendar.goToView(viewIndex, this.focusedValue)
                        .value(this.selectedValue);
            }

            $t.calendar.focusDate(this.focusedValue, calendar.currentView.index, sharedCalendar);

            $t.fx._wrap($calendar).css('zIndex', position.zIndex).show();

            $t.fx.play(this.effects, $calendar, { direction: 'bottom' });
        },

        close: function () {
            if (this.isOpened())
                $t.fx.rewind(this.effects, this.$calendar, { direction: 'bottom' }, function () {
                    if (sharedCalendar)
                        $t.fx._wrap(sharedCalendar).hide();
                });
        },

        isOpened: function () {
            return sharedCalendar && sharedCalendar.data('associatedDateView') == this && sharedCalendar.is(':visible');
        },

        value: function (value) {
            if (value === undefined)
                return this.selectedValue;

            var isNull = value === null;
            var calendar = this._getCalendar();

            //set selected date
            if (!isNull)
                value = value.value ? new Date(value.value) : value;

            calendar.value(value);
            this.selectedValue = value;

            //update focused date;
            if (isNull)
                value = new Date();

            this.focusedValue = new Date(value);
            $t.calendar.focusDate(value, calendar.currentView.index, sharedCalendar);
        },

        navigate: function (e) {
            if (this.isOpened() && $('.t-overlay', sharedCalendar).length > 0)
                return;

            var isFuture;
            var isNavProcessed = false;
            var $calendar = this.$calendar;
            var calendar = this._getCalendar();
            var viewedMonth = calendar.viewedMonth;
            var currentView = calendar.currentView;
            var viewIndex = currentView.index;
            var date = new $t.datetime(this.focusedValue);

            var navigate = function (className, method, futureNav) {
                if (!$(className, $calendar).hasClass('t-state-disabled')) {
                    if ('navigateUp' == method) viewIndex += 1;
                    isFuture = futureNav || false;
                    calendar[method]();
                    return true;
                }
                else return false;
            }

            var navigateDown = function () {
                var target = $t.calendar.findTarget(date, viewIndex, $calendar, false)[0];
                calendar.navigateDown(e, target, viewIndex);
                viewIndex = viewIndex == 0 ? 0 : viewIndex - 1;
                isFuture = true;
            }

            var navPrevNext = function (className, method, futureNav) {
                var diff = !futureNav ? -1 : 1;
                if (!navigate(className, method, futureNav)) return false;
                if (viewIndex == 0)
                    date.addMonth(diff);
                else
                    date.addYear(diff * (viewIndex == 1 ? 1 : viewIndex == 2 ? 10 : 100));
                return true;
            }

            var adjustDate = $t.datepicker.adjustDate;

            if ($calendar.is(':visible') && !e.shiftKey) {
                isNavProcessed = true;
                switch (e.keyCode) {
                    case 37: // left arrow
                        if (e.ctrlKey) {
                            if (!navPrevNext('.t-nav-prev', 'navigateToPast')) return;
                        } else {
                            adjustDate(viewIndex, date, -1, -1); // date modified by reference
                            if (currentView.navCheck(date, viewedMonth, false))
                                if (!navigate('.t-nav-prev', 'navigateToPast')) return;
                        }
                        break;
                    case 38: // up arrow
                        if (e.ctrlKey) {
                            navigate('.t-nav-fast', 'navigateUp');
                        } else {
                            adjustDate(viewIndex, date, -7, -4); // date modified by reference
                            if (currentView.navCheck(date, viewedMonth, false))
                                if (!navigate('.t-nav-prev', 'navigateToPast')) return;
                        }
                        break;
                    case 39: // right arrow
                        if (e.ctrlKey) {
                            if (!navPrevNext('.t-nav-next', 'navigateToFuture', true)) return;
                        } else {
                            adjustDate(viewIndex, date, 1, 1); // date modified by reference
                            if (currentView.navCheck(date, viewedMonth, true))
                                if (!navigate('.t-nav-next', 'navigateToFuture', true)) return;
                        }
                        break;
                    case 40: //down arrow
                        if (e.ctrlKey) {
                            navigateDown();
                        } else {
                            adjustDate(viewIndex, date, 7, 4); // date modified by reference
                            if (currentView.navCheck(date, viewedMonth, true))
                                if (!navigate('.t-nav-next', 'navigateToFuture', true)) return;
                        }
                        break;
                    case 33: // page up
                        if (!navPrevNext('.t-nav-prev', 'navigateToPast')) return;
                        break;
                    case 34: //page down
                        if (!navPrevNext('.t-nav-next', 'navigateToFuture', true)) return;
                        break;
                    case 35: //end
                        date = $t.calendar.views[viewIndex].firstLastDay(date, false, calendar);
                        break;
                    case 36: //home
                        date = $t.calendar.views[viewIndex].firstLastDay(date, true, calendar);
                        break;
                    case 13: // enter
                        e.stopPropagation();

                        if (viewIndex == 0)
                            this.onChange(this.focusedValue);
                        else
                            navigateDown();
                        break;
                    default:
                        isNavProcessed = false;
                        break;
                }
            }

            if (isNavProcessed) {
                e.preventDefault();
                date = $t.calendar.fitDateToRange(date, new $t.datetime(this.minValue), new $t.datetime(this.maxValue));

                $t.calendar.focusDate(date.toDate(), viewIndex, $calendar, isFuture);
                this.focusedValue = date.toDate();
            }
        }
    }

    $.each(['min', 'max'], $.proxy(function (index, method) {
        $t.dateView.prototype[method] =
            function (value) {
                var propertyName = method + 'Value';
                if (value === undefined)
                    return this[propertyName];

                this[propertyName] = new Date(value.value ? value.value : value);

                if (sharedCalendar.data("associatedDateView") === this) {
                    sharedCalendar.data("associatedDateView", null);
                    this._reassignSharedCalendar();
                }
            };
    }, this));

    $t.datepicker = function (element, options) {
        $.extend(this, options);

        if (element.nodeName.toLowerCase() !== "input" && element.type.toLowerCase() !== "text") {
            throw "Target element is not a INPUT";
        }

        this.element = element;
        var $element = this.$element = $(element)
                    .addClass('t-input')
                    .attr('autocomplete', 'off')
                    .bind({
                        keydown: $.proxy(this._keydown, this),
                        focus: $.proxy(function (e) {
                            if (this.openOnFocus) {
                                this._open();
                            }
                            this.$element.removeClass('t-state-error');
                        }, this),
                        blur: $.proxy(function (e) {
                            this._bluring = setTimeout($.proxy(function () {
                                if ($element.val() && this.parse($element.val()) === null) {
                                    this.$element.addClass('t-state-error');
                                }

                                if (!this.dateView.isOpened() && this.dateView === this.dateView.$calendar.data("associatedDateView")) {
                                    this._update($element.val());
                                }
                            }, this), 100);
                        }, this)
                    }); ;

        if (!$element.parent().hasClass('t-picker-wrap')) {

            $element.wrap('<div class="t-widget t-datepicker"><div class="t-picker-wrap"></div></div>');

            if (options.showButton) {
                var builder = new $t.stringBuilder(),
                    title = options.buttonTitle;

                $(builder
                    .cat('<span class="t-select">')
                    .cat('<span class="t-icon t-icon-calendar" ')
                    .catIf('title="', title)
                    .catIf(title, title)
                    .cat('"></span></span>')
                    .string())
                .insertAfter($element);
            }
        }

        this.dateView = new $t.dateView({
            todayFormat: this.todayFormat,
            selectedValue: this.selectedValue,
            minValue: this.minValue,
            maxValue: this.maxValue,
            effects: this.effects,
            isRtl: $element.closest('.t-rtl').length,
            onChange: $.proxy(function (value) {
                this._update(value);
                this._close();
            }, this)
        });

        this.dateView.$calendar
            .bind("click", $.proxy(function (e) {
                e.stopPropagation();
                clearTimeout(this._bluring);
                if (this.dateView !== this.dateView.$calendar.data("associatedDateView")) {
                    return;
                }
                if (e.target.parentNode.className.indexOf("t-state-selected") != -1) {
                    this._close();
                }
                window.setTimeout(function () { $element.focus(); }, 1);
            }, this));

        this.inputValue = $element.val();
        var value = this.selectedValue || this.inputValue;
        if (value) {
            this._value(this.parse(value));
        }

        var clickHandler = this.enabled
                         ? $.proxy(this._togglePopup, this)
                         : $t.preventDefault;

        this.$wrapper = $element.closest('.t-datepicker')
            .find('.t-icon')
            .bind('click', clickHandler)
            .end();

        $(document.documentElement).bind('mousedown', $.proxy(function (e) {
            var val = this.$element.val();
            if (val != this.inputValue) {
                this._update(val);
            }

            if (!sharedCalendar) return;

            var associatedDateView = sharedCalendar.data('associatedDateView');
            if (!associatedDateView || associatedDateView != this.dateView) {
                return;
            }

            if (!$.contains(this.$wrapper[0], e.target) && !$.contains(sharedCalendar[0], e.target)) {
                this._close();
            }
        }, this));

        $t.bind(this, {
            open: this.onOpen,
            close: this.onClose,
            valueChange: this.onChange,
            load: this.onLoad
        });
    }

    $t.datepicker.prototype = {
        _togglePopup: function () {
            if (this.dateView.isOpened()) {
                this._close();
            } else {
                this.element.focus();
                this._open();
            }
        },

        _close: function () {
            if (!sharedCalendar.is(':animated') && this.dateView.isOpened())
                this._trigger('close');
        },

        _open: function () {
            if (!this.dateView.isOpened())
                this._trigger('open');
        },

        _trigger: function (methodName) {
            if (!$t.trigger(this.element, methodName))
                this[methodName]();
        },

        _update: function (val) {
            val = this.parse(val);

            if (val != null) {
                if (val - this.minValue <= 0) {
                    val = this.minValue;
                }
                else if (val - this.maxValue >= 0) {
                    val = this.maxValue;
                }
            }

            var oldValue = this.selectedValue,
                formattedSelectedValue = oldValue ? $t.datetime.format(oldValue, this.format) : '',
                formattedValue = val ? $t.datetime.format(val, this.format) : '';

            this._value(val);

            if (formattedValue != formattedSelectedValue) {
                var data = {
                    previousValue: oldValue,
                    value: val,
                    previousDate: oldValue,
                    date: val
                };

                if ($t.trigger(this.element, 'valueChange', data)) {
                    this._value(oldValue)
                }
            }
        },

        _keydown: function (e) {
            var keyCode = e.keyCode;

            if (keyCode == 9 || (keyCode == 13 && this.inputValue != this.$element.val())) {
                this._update(this.$element.val());
                this._close();
            } else if (keyCode == 27) {
                this._close();
            } else if (e.altKey) {
                if (keyCode == 40) {
                    this._open();
                } else if (keyCode == 38) {
                    this._close();
                }
            } else {
                this.dateView.navigate(e);
            }
        },

        enable: function () {
            this.$element.attr('disabled', false);
            this.$wrapper
                .removeClass('t-state-disabled')
                .find('.t-icon')
                .unbind('click')
                .bind('click', $.proxy(this._togglePopup, this));
        },

        disable: function (e) {
            this.$element.attr('disabled', true);
            this.$wrapper
                .addClass('t-state-disabled')
                .find('.t-icon')
                .unbind('click')
                .bind('click', $t.preventDefault);
        },

        _value: function (value) {
            var text = this.$element.val();
            var isNull = value === null;

            this.selectedValue = value;

            this.dateView.value(value);

            if (!isNull) {
                text = $t.datetime.format(value, this.format);
            }

            this.inputValue = text;
            this.$element.toggleClass('t-state-error', isNull && text != '')
                         .val(text);
        },

        value: function (val) {
            if (val === undefined)
                return this.selectedValue;

            var parsedValue = this.parse(val);
            parsedValue = $t.datepicker.isInRange(parsedValue, this.minValue, this.maxValue) ? parsedValue : null;

            if (parsedValue === null) {
                this.$element.removeClass('t-state-error').val('');
            }

            this._value(parsedValue);

            return this;
        },

        //obsolete
        showPopup: function () {
            this.open();
        },

        //obsolete
        hidePopup: function () {
            this.close();
        },

        open: function () {
            var $element = this.$element;

            this.dateView.open({
                offset: $element.offset(),
                outerHeight: $element.outerHeight(),
                outerWidth: $element.outerWidth(),
                zIndex: $t.getElementZIndex($element[0])
            });
        },

        close: function () {
            this.dateView.close();
        },

        parse: function (value, format) {
            if (value === null || value.getDate)
                return value;

            var result = $t.datetime.parse({
                value: value,
                format: format || this.format,
                shortYearCutOff: this.shortYearCutOff
            });
            return result != null ? result.toDate() : null;

        }
    }

    $.each(["min", "max"], $.proxy(function (index, method) {
        $t.datepicker.prototype[method] =
        function (value) {
            var propertyName = method + 'Value';
            if (value === undefined)
                return this[propertyName];

            var parsedValue = this.parse(value);

            if (parsedValue !== null) {
                var oldValue = this[propertyName];
                this[propertyName] = parsedValue;

                if (this.minValue > this.maxValue) {
                    this[propertyName] = oldValue;
                    return;
                }

                this.dateView[method](parsedValue);
            }
        };
    }, this));

    $.extend($t.datepicker, {
        adjustDate: function (viewIndex, date, monthValue, otherViewValue) {
            if (viewIndex == 0)
                $t.datetime.modify(date, $t.datetime.msPerDay * monthValue);
            else if (viewIndex == 1)
                date.addMonth(otherViewValue);
            else
                date.addYear((viewIndex == 2 ? otherViewValue : 10 * otherViewValue));
        },

        isInRange: function (date, minDate, maxDate) {
            if (!date) return false;
            return minDate - date <= 0 && maxDate - date >= 0;
        }
    });

    $.fn.tDatePicker = function (options) {
        return $t.create(this, {
            name: 'tDatePicker',
            init: function (element, options) {
                return new $t.datepicker(element, options);
            },
            options: options
        });
    };

    $.fn.tDatePicker.defaults = {
        effects: $t.fx.slide.defaults(),
        selectedValue: null,
        format: $t.cultureInfo.shortDate,
        minValue: new Date(1899, 11, 31),
        maxValue: new Date(2100, 0, 1),
        shortYearCutOff: 30,
        showButton: true,
        buttonTitle: 'Open the calendar',
        enabled: true,
        openOnFocus: false
    };

})(jQuery);(function ($) {

    var $t = $.telerik;
    $t.scripts.push("telerik.timepicker.js");

    $t.timeView = function (options) {
        $.extend(this, options);

        var dropDown = this.dropDown = new $t.dropDown({
            attr: this.dropDownAttr,
            effects: this.effects,
            onClick: function (e) {
                var item = e.item;
                options.onChange(item.innerText || item.textContent);
            }
        });

        dropDown.$element
                .addClass('t-time-popup')
                .css('direction', this.isRtl ? 'rtl' : '');
    }

    $t.timeView.prototype = {
        _ensureItems: function () {
            if (!this.dropDown.$items)
                this.bind()
        },

        open: function (position) {
            this._ensureItems();
            this.dropDown.open(position);
        },

        close: function () {
            this.dropDown.close();
        },

        bind: function () {
            var getTimeMilliseconds = $t.timeView.getTimeMilliseconds;

            var availableHours = [];
            var format = this.format;
            var interval = this.interval;
            var tmpDate = new $t.datetime(this.minValue);
            var msMinTime = getTimeMilliseconds(tmpDate);
            var msMaxTime = getTimeMilliseconds(this.maxValue);
            var msInterval = interval * $t.datetime.msPerMinute;
            var dst = $t.datetime.dst() * $t.datetime.msPerMinute;
            var ignoreDST = dst < 0;

            if (!ignoreDST) {
                dst = 0;
            }

            var records = parseInt(($t.datetime.msPerDay + dst) / (interval * $t.datetime.msPerMinute));

            if (msMinTime != msMaxTime) {
                var result = msMinTime < msMaxTime ?
                             msMaxTime - msMinTime :
                             msMaxTime + $t.datetime.msPerDay - msMinTime;

                records = parseInt(result / msInterval) + 1;
            }

            var add = $t.datetime.add;
            var formater = $t.datetime.format;
            for (var i = 0; i < records; i++) {
                availableHours[i] = formater(tmpDate.toDate(), format);
                tmpDate = add(tmpDate, msInterval, ignoreDST);
            }

            if (getTimeMilliseconds(tmpDate) - msInterval - msMaxTime != 0 && msMinTime != msMaxTime && availableHours[records - 1] != formater(this.maxValue, format)) {
                availableHours[records] = formater(this.maxValue, format);
            }

            this.dropDown.dataBind(availableHours);
        },

        isOpened: function () {
            return this.dropDown.isOpened();
        },

        value: function (value) {
            this._ensureItems();
            var dropDown = this.dropDown;

            if (value === undefined)
                return dropDown.$items.filter('.t-state-selected').text();

            var $items = dropDown.$items;
            if (!$items) return;

            $items.removeClass('t-state-selected');
            if (value) {
                dropDown.highlight($.grep($items, function (li) {
                    return (li.innerText || li.textContent) == value;
                }));
            }
        },

        navigate: function (e) {
            var key = e.keyCode || e.which;

            if (key == 38 || key == 40)
                e.preventDefault();

            this._ensureItems();
            var dropDown = this.dropDown;
            var $items = dropDown.$items;
            var $selectedItem = $items.filter('.t-state-selected');

            var $item = $selectedItem.length == 0 || $items.length == 1
                            ? $items.first()
                            : (key == 38) ? $selectedItem.prev() // up
                            : (key == 40) ? $selectedItem.next() // down
                            : [];

            if ($item.length) {
                var text = $item.text();
                dropDown.scrollTo($item[0]);
                dropDown.highlight($item[0]);
                if (!dropDown.isOpened())
                    this.onChange(text);
                else
                    this.onNavigateWithOpenPopup(text);
            }
        }
    }

    $.each(["min", "max"], $.proxy(function (index, method) {
        $t.timeView.prototype[method] =
            function (value) {
                var propertyName = method + 'Value';
                if (value === undefined)
                    return this[propertyName];

                this[propertyName] = new Date(value.value ? value.value : value);
                this.bind();
            };
    }, this));

    $.extend($t.timeView, {
        isInRange: function (value, minValue, maxValue) {
            if (value === null) return true;

            var getTimeMilliseconds = $t.timeView.getTimeMilliseconds;
            var msPerDay = $t.datetime.msPerDay;
            var msValue = getTimeMilliseconds(value);
            var msMinTime = getTimeMilliseconds(minValue);
            var msMaxTime = getTimeMilliseconds(maxValue);

            msValue = msMinTime > msValue
                    ? msValue + msPerDay
                    : msValue;

            msMaxTime = msMinTime > msMaxTime
                        ? msMaxTime + msPerDay
                        : msMaxTime;

            return msMinTime - msMaxTime == 0 || msValue >= msMinTime && msValue <= msMaxTime;
        },

        getTimeMilliseconds: function (value) {
            value = value.value ? value : new $t.datetime(value);
            return ((value.hours() * 60) + value.minutes()) * $t.datetime.msPerMinute + value.seconds() * 1000 + value.milliseconds();
        }
    });

    $t.timepicker = function (element, options) {

        $.extend(this, options);

        if (element.nodeName.toLowerCase() !== "input" && element.type.toLowerCase() !== "text") {
            throw "Target element is not a INPUT";
        }

        this.element = element;
        var $element = this.$element = $(element)
                    .addClass('t-input')
                    .attr('autocomplete', 'off')
                    .bind({
                        keydown: $.proxy(this._keydown, this),
                        focus: $.proxy(function (e) {
                            if (this.openOnFocus) {
                                this._open();
                            }
                            this.$element.removeClass('t-state-error');
                        }, this),
                        blur: $.proxy(function (e) {
                            this._bluring = setTimeout($.proxy(function () {
                                if ($element.val() && this.parse($element.val()) === null) {
                                    this.$element.addClass('t-state-error');
                                }

                                this._update($element.val());
                            }, this), 100);
                        }, this)
                    });


        if (!$element.parent().hasClass('t-picker-wrap')) {

            $element.wrap('<div class="t-widget t-timepicker"><div class="t-picker-wrap"></div></div>');

            if (options.showButton) {
                var builder = new $t.stringBuilder(),
                title = options.buttonTitle;

                $(builder
                    .cat('<span class="t-select">')
                    .cat('<span class="t-icon t-icon-clock" ')
                    .catIf('title="', title)
                    .catIf(title, title)
                    .cat('"></span></span>')
                    .string())
                .insertAfter($element);
            }
        }

        this.timeView = new $t.timeView({
            effects: this.effects,
            dropDownAttr: this.dropDownAttr,
            format: this.format,
            interval: this.interval,
            isRtl: $element.closest('.t-rtl').length,
            minValue: this.minValue,
            maxValue: this.maxValue,
            onNavigateWithOpenPopup: $.proxy(function (value) {
                this.$element.val(value);
            }, this),
            onChange: $.proxy(function (value) {
                clearTimeout(this._bluring);
                if (value != this.inputValue) {
                    this._update(value);
                }
                this._close();
                window.setTimeout(function () { $element.focus(); }, 1);
            }, this)
        });

        this.inputValue = $element.val();

        var value = this.selectedValue || this.inputValue;
        if (value) {
            this._value(this.parse(value));
        }

        var clickHandler = this.enabled
                         ? $.proxy(this._togglePopup, this)
                         : $t.preventDefault;

        this.$wrapper = $element.closest('.t-timepicker')
            .find('.t-icon')
            .bind('click', clickHandler)
            .end();

        $(document.documentElement).bind('mousedown', $.proxy(function (e) {
            var val = this.$element.val();
            if (val != this.inputValue) {
                this._update(val);
            }

            var $dropDown = this.timeView.dropDown.$element;
            var isDropDown = $dropDown && $dropDown.parent().length > 0;

            if (!isDropDown
            || $.contains(this.$wrapper[0], e.target)
            || $.contains($dropDown.parent()[0], e.target))
                return;

            this._close();

        }, this));

        $t.bind(this, {
            open: this.onOpen,
            close: this.onClose,
            valueChange: this.onChange,
            load: this.onLoad
        });
    }

    $t.timepicker.prototype = {
        _close: function () {
            var dropDown = this.timeView.dropDown;
            if (!dropDown.$element.is(':animated') && dropDown.isOpened())
                this._trigger('close');
        },

        _open: function () {
            if (!this.timeView.isOpened())
                this._trigger('open');
        },

        _trigger: function (methodName) {
            if (!$t.trigger(this.element, methodName))
                this[methodName]();
        },

        _togglePopup: function () {
            if (this.timeView.isOpened()) {
                this._close();
            } else {
                this.element.focus();
                this._open();
            }
        },

        _update: function (val) {

            var minValue = this.minValue,
                maxValue = this.maxValue,
                val = this.parse(val),
                oldValue = this.selectedValue;

            if (val != null && !$t.timeView.isInRange(val, minValue, maxValue)) {
                var getTimeMilliseconds = $t.timeView.getTimeMilliseconds,
                    msValue = getTimeMilliseconds(val),
                    minDiff = Math.abs(getTimeMilliseconds(minValue) - msValue),
                    maxDiff = Math.abs(getTimeMilliseconds(maxValue) - msValue);

                val = new Date(minDiff < maxDiff ? minValue : maxValue);
            }

            var formattedSelectedValue = oldValue ? $t.datetime.format(oldValue, this.format) : '',
                formattedValue = val ? $t.datetime.format(val, this.format) : '';

            this._value(val);

            if (formattedValue != formattedSelectedValue) {
                if ($t.trigger(this.element, 'valueChange', { previousValue: oldValue, value: val })) {
                    this._value(oldValue)
                }
            }
        },

        _value: function (value) {
            var text = this.$element.val();
            var isNull = value === null;

            this.selectedValue = value;
            this.timeView.value(isNull ? null : $t.datetime.format(value, this.format));

            if (!isNull)
                text = $t.datetime.format(value, this.format);

            this.inputValue = text;
            this.$element.toggleClass('t-state-error', isNull && text != '')
                         .val(text);
        },

        _keydown: function (e) {
            var key = e.keyCode || e.which;

            if (e.altKey) {
                if (key == 40) {
                    this._open();
                } else if (key == 38) {
                    this._close();
                }
                return;
            }

            if (!e.shiftKey && (key === 38 || key === 40)) {
                this.timeView.navigate(e);
                return;
            }

            if (key == 9 || key == 13 || key == 27) {
                this._update(this.$element.val());
                this._close();
            }
        },

        enable: function () {
            this.$element.attr('disabled', false);
            this.$wrapper.removeClass('t-state-disabled')
                         .find('.t-icon')
                         .unbind('click')
                         .bind('click', $.proxy(this._togglePopup, this));
        },

        disable: function (e) {
            this.$element.attr('disabled', true);
            this.$wrapper.addClass('t-state-disabled')
                         .find('.t-icon')
                         .unbind('click')
                         .bind('click', $t.preventDefault);
        },

        value: function (val) {
            if (val === undefined)
                return this.selectedValue;

            var parsedValue = this.parse(val);
            parsedValue = $t.timeView.isInRange(parsedValue, this.minValue, this.maxValue) ? parsedValue : null;

            if (parsedValue === null)
                this.$element.removeClass('t-state-error').val('');

            this._value(parsedValue);

            return this;
        },

        parse: function (value) {
            if (value === null || value.getDate)
                return value;

            var result = $t.datetime.parse({
                AM: $t.cultureInfo.am,
                PM: $t.cultureInfo.pm,
                value: value,
                format: this.format,
                baseDate: this.selectedValue ? new $t.datetime(this.selectedValue) : new $t.datetime()
            });
            return result != null ? result.toDate() : null;
        },

        open: function () {
            var $element = this.$element;
            this.timeView.open({
                offset: $element.offset(),
                outerHeight: $element.outerHeight(),
                outerWidth: $element.outerWidth(),
                zIndex: $t.getElementZIndex($element[0])
            });
        },

        close: function () {
            this.timeView.close();
        }
    }

    $.each(["min", "max"], $.proxy(function (index, method) {
        $t.timepicker.prototype[method] =
            function (value) {
                var propertyName = method + 'Value';
                if (value === undefined)
                    return this[propertyName];

                var parsedValue = this.parse(value);
                if (parsedValue !== null) {
                    this[propertyName] = parsedValue;
                    this.timeView[method](parsedValue);
                }
            };
    }, this));

    $.fn.tTimePicker = function (options) {
        return $t.create(this, {
            name: 'tTimePicker',
            init: function (element, options) {
                return new $t.timepicker(element, options);
            },
            options: options
        });
    };

    $.fn.tTimePicker.defaults = {
        effects: $t.fx.slide.defaults(),
        minValue: new $t.datetime().hours(0).minutes(0).seconds(0).toDate(),
        maxValue: new $t.datetime().hours(0).minutes(0).seconds(0).toDate(),
        selectedValue: null,
        format: $t.cultureInfo.shortTime,
        interval: 30,
        showButton: true,
        buttonTitle: 'Open the calendar',
        enabled: true,
        openOnFocus: false
    };

})(jQuery);(function ($) {

    var $t = $.telerik;

    $t.scripts = $t.scripts || [];
    $t.scripts.push("telerik.datetimepicker.js");

    function getButtonHtml(type, titleText) {
        var builderHtml = new $t.stringBuilder();
        return builderHtml.cat('<span class="t-icon t-icon-')
                                      .cat(type)
                                      .cat('" ')
                                      .catIf('title="', titleText)
                                      .catIf(titleText, titleText)
                                      .cat('"></span>')
                                      .string();
    }

    $t.datetimepicker = function (element, options) {
        $.extend(this, options);
        
        if (element.nodeName.toLowerCase() !== "input" && element.type.toLowerCase() !== "text") {
            throw "Target element is not a INPUT";
        }

        this.element = element;
        var $element = this.$element = $(element)
                    .addClass('t-input')
                    .attr('autocomplete', 'off')
                    .bind({
                        keydown: $.proxy(this._keydown, this),
                        focus: $.proxy(function (e) {
                            this.$element.removeClass('t-state-error');
                        }, this),
                        blur: $.proxy(function(e) {
                            this._bluring = setTimeout($.proxy(function() {
                                if ($element.val() && this.parse($element.val()) === null) {
                                    this.$element.addClass('t-state-error');
                                }

                                if (!this.dateView.isOpened() && this.dateView === this.dateView.$calendar.data("associatedDateView")) {
                                    this._update($element.val());
                                }
                            }, this), 100);
                        }, this)
                    });

        if (!$element.parent().hasClass('t-picker-wrap')) {

            $element.wrap('<div class="t-widget t-datetimepicker"><div class="t-picker-wrap"></div></div>');

            if (options.showCalendarButton || options.showTimeButton) {
                $(new $t.stringBuilder()
                    .cat('<span class="t-select">')
                    .catIf(getButtonHtml('calendar', options.calendarButtonTitle), options.showCalendarButton)
                    .cat(getButtonHtml('clock', options.timeButtonTitle), options.showTimeButton)
                    .cat('</span>')
                    .string())
                .insertAfter($element);
            }
        }

        this.$wrapper = $element.closest('.t-datetimepicker')
                    .find('.t-icon-clock')
                    .bind('click', this.enabled ? $.proxy(this._toggleTimeView, this) : $t.preventDefault)
                    .end()
                    .find('.t-icon-calendar')
                    .bind('click', this.enabled ? $.proxy(this._toggleDateView, this) : $t.preventDefault)
                    .end();

        this.timeView = new $t.timeView({
            effects: this.effects,
            dropDownAttr: this.dropDownAttr,
            format: this.timeFormat,
            interval: this.interval,
            isRtl: $element.closest('.t-rtl').length,
            minValue: this.startTimeValue,
            maxValue: this.endTimeValue,
            onNavigateWithOpenPopup: $.proxy(function (value) {
                var date = this.parse(value, this.timeFormat);
                this.$element.val($t.datetime.format(date, this.format));
            }, this),
            onChange: $.proxy(function (value) {
                clearTimeout(this._bluring);
                this._update(this.parse(value, this.timeFormat));
                this._close('time');
                window.setTimeout(function(){$element.focus();}, 1);
            }, this)
        });

        this.dateView = new $t.dateView({
            todayFormat: this.todayFormat,
            selectedValue: this.selectedValue,
            minValue: this.minValue,
            maxValue: this.maxValue,
            effects: this.effects,
            isRtl: $element.closest('.t-rtl').length,
            onChange: $.proxy(function (value) {
                this._update(value);
                this._close('date');
            }, this)
        });

        this.dateView.$calendar
            .bind("click", $.proxy(function(e) {
                e.stopPropagation();
                clearTimeout(this._bluring);
                if (this.dateView !== this.dateView.$calendar.data("associatedDateView")) {
                    return;
                }
                if (e.target.parentNode.className.indexOf("t-state-selected") != -1) {
                    this._close("date");
                }
                window.setTimeout(function(){$element.focus();}, 1);
            }, this));

        this.inputValue = $element.val();
        var value = this.selectedValue || this.inputValue;
        if (value) {
            var parsedValue = this.parse(value);
            this.dateView.selectedValue = parsedValue; //should set it if dateView has never been open;
            this._value(this.parse(value));
        }

        $(document.documentElement).bind('mousedown', $.proxy(function (e) {
            var val = this.$element.val();
            if (val != this.inputValue) {
                this._update(val);
            }
            
            var $calendar = this.dateView.$calendar;
            if (!$calendar) return;

            var $dropDown = this.timeView.dropDown.$element;
            var isDropDown = $dropDown && $dropDown.parent().length > 0;
            var associatedDateView = $calendar.data('associatedDateView');

            var target = e.target;
            if ($.contains(this.$wrapper[0], target)
            || (associatedDateView && associatedDateView == this.dateView && $.contains($calendar[0], target))
            || (isDropDown && $.contains($dropDown.parent()[0], target)))
                return;

            this._close('date');
            this._close('time');

        }, this));

        $t.bind(this, {
            open: this.onOpen,
            close: this.onClose,
            valueChange: this.onChange,
            load: this.onLoad
        });
    }

    $t.datetimepicker.prototype = {
        _update: function (val) {
            val = this.parse(val);
            
            if (val != null) {
                if (val - this.minValue <= 0) {
                    val = this.minValue;
                }
                else if (val - this.maxValue >= 0) {
                    val = this.maxValue;
                }
            }

            var oldValue = this.selectedValue,
                formattedSelectedValue = oldValue ? $t.datetime.format(oldValue, this.format) : '',
                formattedValue = val ? $t.datetime.format(val, this.format) : '';

            this._value(val);

            if (formattedValue != formattedSelectedValue) {
                var data = {
                    previousValue: oldValue,
                    value: val
                };

                if ($t.trigger(this.element, 'valueChange', data)) {
                    this._value(oldValue);
                }
            }
        },

        _value: function (value) {
            var text = this.$element.val();
            var isNull = value === null;

            this.selectedValue = value;
            this.timeView.value(isNull ? null : $t.datetime.format(value, this.timeFormat));
            this.dateView.value(value);

            if (!isNull)
                text = $t.datetime.format(value, this.format);

            this.inputValue = text;
            this.$element.toggleClass('t-state-error', isNull && text != '')
                         .val(text);
        },

        _open: function (popup) {
            if (!this[popup == "time" ? 'timeView' : 'dateView'].isOpened())
                this._trigger(popup, 'open');
        },

        _close: function (popup) {
            var dateView = this.dateView;
            var dropDown = this.timeView.dropDown;

            if ((popup == "time" && !dropDown.$element.is(':animated') && dropDown.isOpened())
            || (!dateView.$calendar.is(':animated') && dateView.isOpened()))
                this._trigger(popup, 'close');
        },

        _trigger: function (popup, methodName) {
            if (!$t.trigger(this.element, methodName, { popup: popup }))
                this[methodName](popup)
        },

        _keydown: function (e) {
            var keyCode = e.keyCode,
                isDateViewOpened = this.dateView.isOpened();

            if (keyCode == 9 || keyCode == 27 || (keyCode == 13 && this.inputValue != this.$element.val())) {
                this._update(this.$element.val());
                this._close('date');
                this._close('time');
                return;
            }

            if (e.altKey) {
                if (keyCode == 40) {
                    this._close(isDateViewOpened ? 'date' : 'time');
                    this._open(isDateViewOpened ? 'time' : 'date');
                } else if (keyCode == 38) {
                    this._close(isDateViewOpened ? 'date' : 'time');
                }
                return;
            }

            if (isDateViewOpened) {
                this.dateView.navigate(e);
                return;
            }

            if (this.timeView.isOpened() && (keyCode === 38 || keyCode === 40)) {
                this.timeView.navigate(e);
                return;
            }
        },

        _toggleDateView: function () {
            if (this.dateView.isOpened()) {
                this._close('date')
            } else {
                this.element.focus();
                this._open('date')
                this._close('time')
            }
        },

        _toggleTimeView: function () {
            if (this.timeView.isOpened()) {
                this._close('time')
            } else {
                this.element.focus();
                this._open('time');
                this._close('date');
            }
        },

        enable: function () {
            this.$element.attr('disabled', false);
            this.$wrapper
                .removeClass('t-state-disabled')
                .find('.t-icon-clock')
                .unbind('click')
                .bind('click', $.proxy(this._toggleTimeView, this))
                .end()
                .find('.t-icon-calendar')
                .unbind('click')
                .bind('click', $.proxy(this._toggleDateView, this));
        },

        disable: function (e) {
            this.$element.attr('disabled', true);
            this.$wrapper
                .addClass('t-state-disabled')
                .find('.t-icon')
                .unbind('click')
                .bind('click', $t.preventDefault);
        },

        open: function (popup) {
            var $element = this.$element;
            var position = {
                offset: $element.offset(),
                outerHeight: $element.outerHeight(),
                outerWidth: $element.outerWidth(),
                zIndex: $t.getElementZIndex($element[0])
            }

            this[popup == "time" ? 'timeView' : 'dateView'].open(position);
        },

        close: function (popup) {
            this[popup == "time" ? 'timeView' : 'dateView'].close();
        },

        value: function (val) {
            if (val === undefined)
                return this.selectedValue;

            var parsedValue = this.parse(val);
            parsedValue = $t.datepicker.isInRange(parsedValue, this.minValue, this.maxValue) ? parsedValue : null;

            if (parsedValue === null)
                this.$element.removeClass('t-state-error').val('');

            this._value(parsedValue);

            return this;
        },

        parse: function (value, format) {
            if (value === null || value.getDate)
                return value;

            format = format || this.format;

            var result = $t.datetime.parse({
                AM: $t.cultureInfo.am,
                PM: $t.cultureInfo.pm,
                value: value,
                format: format,
                baseDate: this.selectedValue ? new $t.datetime(this.selectedValue) : new $t.datetime()
            });

            return result != null ? result.toDate() : null;
        }
    }

    $.each(["min", "max"], $.proxy(function (index, method) {
        $t.datetimepicker.prototype[method] =
        function (value) {
            var propertyName = method + 'Value';
            if (value === undefined)
                return this[propertyName];

            var parsedValue = this.parse(value);

            if (parsedValue !== null) {
                var oldValue = this[propertyName];
                this[propertyName] = parsedValue;

                if (this.minValue > this.maxValue) {
                    this[propertyName] = oldValue;
                    return;
                }

                this.dateView[method](parsedValue);
            }
        };
    }, this));

    $.each(["startTime", "endTime"], $.proxy(function (index, method) {
        $t.datetimepicker.prototype[method] =
            function (value) {
                var propertyName = method + 'Value';
                if (value === undefined)
                    return this[propertyName];

                var parsedValue = this.parse(value, $t.cultureInfo.shortTime);
                if (parsedValue !== null) {
                    this[propertyName] = parsedValue;
                    method == 'startTime' ? this.timeView.min(parsedValue) : this.timeView.max(parsedValue)
                }
            };
    }, this));

    $.fn.tDateTimePicker = function (options) {
        $.fn.tDateTimePicker.defaults.timeFormat = $t.cultureInfo.shortTime;

        return $t.create(this, {
            name: 'tDateTimePicker',
            init: function (element, options) {
                return new $t.datetimepicker(element, options);
            },
            options: options
        });
    };

    $.fn.tDateTimePicker.defaults = {
        effects: $t.fx.slide.defaults(),
        selectedValue: null,
        format: $t.cultureInfo.generalDateTime,
        focusedDate: new $t.datetime(),
        minValue: new Date(1899, 11, 31),
        maxValue: new Date(2100, 0, 1),
        startTimeValue: new $t.datetime().hours(0).minutes(0).seconds(0).toDate(),
        endTimeValue: new $t.datetime().hours(0).minutes(0).seconds(0).toDate(),
        calendarButtonTitle: "Open the calendar",
        timeButtonTitle: "Open the time view",
        showCalendarButton: true,
        showTimeButton: true,
        shortYearCutOff: 30,
        enabled: true,
        interval: 30
    };

})(jQuery);
(function ($) {
    var $t = $.telerik,
        nop = function () { },
        draggables = {},
        droppables = {},
        cues = {},
        lastDropTarget = { owner: [ null ] },
        MOUSEUP = $t.isTouch ? "touchend" : "mouseup",
        MOUSEDOWN = $t.isTouch ? "touchstart" : "mousedown",
        MOUSEMOVE = $t.isTouch ? "touchmove" : "mousemove",
        droppableDefaults = {
            scope: 'default',
            drop: nop,
            over: nop,
            out: nop,
            owner: document.body
        },
        draggableDefaults = {
            distance: 5, /* Dinstance in pixels the mouse should move before dragging should start. */
            cursorAt: { left: 10, top: $t.isTouch ? -40 / $t.zoomLevel() : 10 }, /* The offset of the cursor from the dragging cue. */
            scope: 'default', /* Used to group draggables and droppables. */
            start: nop, /* Called when dragging starts. Return `false` to prevent dragging. */
            drag: nop, /* Called when the mouse is moved during dragging. */
            stop: nop, /* Called when dragging stops. Return `false` to prevent the stop animation. */
            destroy: nop, /* Called when the draggable is destroyed. Used to remove any dragging/dropping cues from DOM. */
            owner: document.body, /* The DOM element to which events are attached. Used with 'selector' and 'delegate'. */
            cue: function () { /* Called to create the dragging cue. Return a jQuery object representing the cue. */
                return $('<span />');
            }
        };

    $t.scripts.push("telerik.draganddrop.js");

    function size(obj) {
        var size = 0, key;
        for (key in obj) {
            obj.hasOwnProperty(key) && size++;
        }

        return size;
    }

    function findTarget(needle, targets) {
        var result = { owner: [ null ] };

        $.each(targets, function() {
            var that = this,
                element = that.owner;

            if (element && $.contains(element, needle)) {
                result = $.extend(result, that);
                result.selector && (result.owner = $(needle).closest(result.selector)[0]);
                return false;
            }
        });

        return result;
    }


    $t.droppable = function (options) {
        $.extend(this, droppableDefaults, options);
        $(this.owner).delegate(this.selector, 'mouseenter', $.proxy(this._over, this))
                    .delegate(this.selector, MOUSEUP, $.proxy(this._drop, this))
                    .delegate(this.selector, 'mouseleave', $.proxy(this._out, this));

        if (!(this.scope in droppables)) {
            droppables[this.scope] = [ this ];
        } else {
            droppables[this.scope].push( this );
        }
    };

    $t.droppable.prototype = {
        _over: function (e) {
            this._raise(e, this.over);
        },
        _out: function (e) {
            this._raise(e, this.out);
        },
        _drop: function (e) {            
            this._raise(e, $.proxy(function (e) {
                this.drop(e);
                e.destroy(e);
            }, this));
        },
        _raise: function (e, callback) {
            var draggable = draggables[this.scope],
                target = $($t.eventCurrentTarget(e)).closest(this.selector);

            if (draggable)
                callback($.extend(e, draggable, { $droppable: target }));
        }
    };

    $t.dragCue = function (html) {
        return $('<div class="t-header t-drag-clue" />')
            .html(html)
            .prepend('<span class="t-icon t-drag-status t-denied" />')
            .appendTo(document.body);
    };

    $t.dragCueStatus = function ($cue, status) {
        $cue.find('.t-drag-status')
            .attr('class', 't-icon t-drag-status')
            .addClass(status);
    };

    $t.draggable = function (options) {
        $.extend(this, draggableDefaults, options);

        $(this.owner).delegate(this.selector, MOUSEDOWN, $.proxy(this._wait, this))
                     .delegate(this.selector, 'dragstart', $t.preventDefault);

        this._startProxy = $.proxy(this._start, this);
        this._destroyProxy = $.proxy(this._destroy, this);
        this._stopProxy = $.proxy(this._stop, this);
        this._dragProxy = $.proxy(this._drag, this);
    };

    $t.draggable.get = function (scope) {
        return draggables[scope];
    };

    $t.draggable.prototype = {
        _raise: function (e, callback) {
            var draggable = draggables[this.scope];
            if (draggable)
                return callback($.extend(e, draggable));
        },

        _startDrag: function (target, position) {
            target = $(target);
            this.$target = target;

            if (position) {
                this._startPosition = position;
            } else {
                var offset = target.offset();
                this._startPosition = { x: offset.left, y: offset.top };
            }

            $(document).bind(MOUSEMOVE + "." + this.scope, this._startProxy)
                .bind(MOUSEUP + "." + this.scope, this._destroyProxy);
        },

        _wait: function (e) {
            if ($t.isTouch)
                e.stopImmediatePropagation();

            this._startDrag(e.currentTarget, $t.touchLocation(e));

            $(document.documentElement).trigger(MOUSEDOWN, e); // manually triggering 'mousedown' because the next statement will prevent that.

            // required to avoid selection in Gecko
            if (!$t.isTouch)
                return false;
        },

        _start: function (e) {
            var location = $t.touchLocation(e),
                x = this._startPosition.x - location.x,
                y = this._startPosition.y - location.y;

            var distance = Math.sqrt((x * x) + (y * y));

            if (distance >= this.distance) {
                if ($t.isTouch) {
                    e.stopImmediatePropagation();
                    e.preventDefault();
                }

                var $cue = cues[this.selector];

                if (!$cue) {
                    $cue = cues[this.selector] = this.cue({ $draggable: this.$target });
                }

                $(document).unbind("." + this.scope)
                    .bind(MOUSEMOVE + "." + this.scope, this._dragProxy)
                    .bind(MOUSEUP + "." + this.scope, this._stopProxy)
                    .bind("keydown." + this.scope, this._stopProxy)
                    .bind("selectstart." + this.scope, false);

                draggables[this.scope] = {
                    $cue: $cue.css({ position: 'absolute', left: location.x + this.cursorAt.left, top: location.y + this.cursorAt.top }),
                    $draggable: this.$target,
                    destroy: this._destroyProxy
                };

                if (this._raise(e, this.start) === false)
                    this._destroy(e);
            }
        },

        _drag: function (e) {
            if ($t.isTouch)
                e.stopImmediatePropagation();

            var location = $t.touchLocation(e);

            if ($t.isTouch && size(droppables)) {
                var dropTarget = $t.eventTarget(e);

                if (dropTarget) {
                    var droppable = droppables[this.scope],
                        target = findTarget(dropTarget, droppable),
                        element = target.owner,
                        lastTarget = lastDropTarget.owner,
                        difference = lastTarget != element;

                    if (difference) {
                        if (lastTarget != null && "_out" in lastDropTarget) {
                            lastDropTarget._out(e);
                        }

                        if (element && $.contains(element, dropTarget) && "_over" in target) {
                            target._over(e);
                        }

                        lastDropTarget = target;
                    }
                }
            }

            this._raise(e, this.drag);
            draggables[this.scope].$cue.css({ left: location.x + this.cursorAt.left, top: location.y + this.cursorAt.top });
        },

        _stop: function (e) {            
            if ($t.isTouch)
                e.stopImmediatePropagation();

            if (e.type == MOUSEUP || e.keyCode == 27)
                $(document).unbind("." + this.scope);
            
                if ($t.isTouch && size(droppables)) {
                    var dropTarget = $t.eventTarget(e);

                    if (dropTarget) {
                        var droppable = droppables[this.scope],
                            target = findTarget(dropTarget, droppable);

                        if (target.owner && "_drop" in target) {
                            lastDropTarget = { owner: [ null ] };
                            target._drop(e);
                        }
                    }
                }

                if (this._raise(e, this.stop) === false) {
                    this._destroy(e);
                } else {
                    var draggable = draggables[this.scope];
                    if (draggable)
                        draggable.$cue.animate(draggable.$draggable.offset(), 'fast', this._destroyProxy);
                }
        },

        _destroy: function (e) {
            $(document).unbind("." + this.scope);

            this._raise(e, this.destroy);

            draggables[this.scope] = null;
            cues[this.selector] = null;
        }
    }
})(jQuery);
(function ($, undefined) {

    var $t = $.telerik;
    $t.scripts.push("telerik.window.js");

    function isLocalUrl(url) {
        return url && !(/^([a-z]+:)?\/\//i).test(url);
    }

    function fixIE6Sizing($element) {
        if ($.browser.msie && $.browser.version < 7) {
            $element
                .find('.t-resize-e,.t-resize-w').css('height', $element.height()).end()
                .find('.t-resize-n,.t-resize-s').css('width', $element.width()).end()
                .find('.t-overlay').css({ width: $element.width(), height: $element.height() });
        }
    }

    // zoom animation

    $t.fx.zoom = function (element) {
        this.element = element;
    };

    $t.fx.zoom.prototype = {
        play: function (options, end) {
            var $element = this.element.show();

            var resizeElement = $element.find('> .t-window-content');

            var endValues = {
                width: resizeElement.width(),
                height: resizeElement.height(),
                left: parseInt($element.css('left')) || 0,
                top: parseInt($element.css('top')) || 0
            };

            $element
                .css({
                    left: endValues.left + 20,
                    top: endValues.top + 20
                })
                .animate({
                    left: endValues.left,
                    top: endValues.top
                }, options.openDuration);

            resizeElement
                .css({
                    width: endValues.width - 40,
                    height: endValues.height - 40
                })
                .animate({
                    width: endValues.width,
                    height: endValues.height
                }, options.openDuration, function () {
                    if (end) end();
                });
        },

        rewind: function (options, end) {
            var $element = this.element;

            var resizeElement = $element.find('> .t-window-content');
            var endValues = {
                width: resizeElement.width(),
                height: resizeElement.height(),
                left: parseInt($element.css('left')),
                top: parseInt($element.css('top'))
            };

            resizeElement.animate({
                width: endValues.width - 40,
                height: endValues.height - 40
            }, options.closeDuration);

            $element.animate({
                left: endValues.left + 20,
                top: endValues.top + 20
            }, options.closeDuration, function () {
                $element.css({
                    left: endValues.left,
                    top: endValues.top
                }).hide();

                setTimeout(function () {
                    resizeElement.css({
                        width: endValues.width,
                        height: endValues.height
                    });
                }, 0);

                if (end) end();
            });
        }
    };

    $t.fx.zoom.defaults = function () {
        return { list: [{ name: 'zoom'}], openDuration: 'fast', closeDuration: 'fast' };
    };

    $t.window = function (element, options) {
        this.element = element;
        var $element = $(element),
            normalized = $.extend({}, options);

        delete normalized.title;
        delete normalized.content;

        $.extend(this, normalized);

        if (!$element.is('.t-window')) {
            $element.addClass('t-widget t-window');
            $t.window.create(element, options);
        }

        if (!$element.is('body')) {
            var offset;

            if ($element.is(':visible')) {
                offset = $element.offset();
                $element.css({ top: offset.top, left: offset.left });
            } else {
                $element.css({ visibility: 'hidden', display: '' });
                offset = $element.offset();
                $element.css({ top: offset.top, left: offset.left })
                        .css({ visibility: 'visible', display: 'none' });
            }

            // Collect the src attributes of all iframes and then set them to empty string.
            // This seems to fix this IE9 "feature": http://msdn.microsoft.com/en-us/library/gg622929%28v=VS.85%29.aspx?ppud=4
            var iframeSrcAttributes = $element.find("iframe").map(function(iframe) {
                var src = this.getAttribute("src");
                this.src = "";
                return src;
            });
            
            // Make sure the wrapper is appended to the body only once. IE9+ will throw exceptions if you move iframes in DOM
            $element
                .toggleClass('t-rtl', $element.closest('.t-rtl').length > 0)
                .appendTo(document.body)
                .find("iframe").each(function(index) {
                   // Restore the src attribute of the iframes when they are part of the live DOM tree
                   this.src = iframeSrcAttributes[index];
                });
        }

        this.bringToTop();
        $element.find(".t-window-titlebar").andSelf().bind("mousedown", $.proxy(this.bringToTop, this));

        if (this.modal && $element.is(':visible')) {
            this.overlay(true).css({ opacity: 0.5, zIndex: parseInt($element.css('zIndex'), 10) - 1 });
        }

        var windowActions = '.t-window-titlebar .t-link';

        $element
            .delegate(windowActions, 'mouseenter', $t.hover)
            .delegate(windowActions, 'mouseleave', $t.leave)
            .delegate(windowActions, 'click', $.proxy(this.windowActionHandler, this));
        
        if (this.resizable) {
            $element
                .delegate('.t-window-titlebar', 'dblclick', $.proxy(this.toggleMaximization, this))
                .append($t.window.getResizeHandlesHtml());

            fixIE6Sizing($element);

            (function(wnd) {
                
                function start(e) {
                    var $element = $(wnd.element);

                    wnd.initialCursorPosition = $element.offset();

                    wnd.resizeDirection = /t-resize-([nesw]+)/gi.exec(e.$draggable[0].className)[1];

                    wnd.resizeElement = $element.find('> .t-window-content');

                    wnd.initialSize = {
                        width: wnd.resizeElement.width(),
                        height: wnd.resizeElement.height()
                    };

                    wnd.outlineSize = {
                        left: wnd.resizeElement.outerWidth() - wnd.resizeElement.width()
                            + $element.outerWidth() - $element.width(),
                        top: wnd.resizeElement.outerHeight() - wnd.resizeElement.height()
                            + $element.outerHeight() - $element.height()
                            + $element.find('> .t-window-titlebar').outerHeight()
                    };

                    $('<div class="t-overlay" />').appendTo(wnd.element);

                    $element.find('.t-resize-handle').not(e.$draggable).hide();

                    $(document.body).css('cursor', e.$draggable.css('cursor'));
                }

                function drag(e) {
                    var $element = $(wnd.element);

                    var resizeHandlers = {
                        'e': function () {
                            var location = $t.touchLocation(e),
                                width = location.x - wnd.initialCursorPosition.left - wnd.outlineSize.left;
                            wnd.resizeElement.width((width < wnd.minWidth
                                                        ? wnd.minWidth
                                                        : (wnd.maxWidth && width > wnd.maxWidth)
                                                        ? wnd.maxWidth
                                                        : width));
                        },
                        's': function () {
                            var location = $t.touchLocation(e),
                                height = location.y - wnd.initialCursorPosition.top - wnd.outlineSize.top;
                            wnd.resizeElement
                                    .height((height < wnd.minHeight ? wnd.minHeight
                                            : (wnd.maxHeight && height > wnd.maxHeight) ? wnd.maxHeight
                                            : height));
                        },
                        'w': function () {
                            var location = $t.touchLocation(e),
                                windowRight = wnd.initialCursorPosition.left + wnd.initialSize.width;

                            $element.css('left', location.x > (windowRight - wnd.minWidth) ? windowRight - wnd.minWidth
                                                : location.x < (windowRight - wnd.maxWidth) ? windowRight - wnd.maxWidth
                                                : location.x);

                            var width = windowRight - location.x;
                            wnd.resizeElement.width((width < wnd.minWidth ? wnd.minWidth
                                                    : (wnd.maxWidth && width > wnd.maxWidth) ? wnd.maxWidth
                                                    : width));

                        },
                        'n': function () {
                            var location = $t.touchLocation(e),
                                windowBottom = wnd.initialCursorPosition.top + wnd.initialSize.height;

                            $element.css('top', location.y > (windowBottom - wnd.minHeight) ? windowBottom - wnd.minHeight
                                                : location.y < (windowBottom - wnd.maxHeight) ? windowBottom - wnd.maxHeight
                                                : location.y);

                            var height = windowBottom - location.y;
                            wnd.resizeElement
                                    .height((height < wnd.minHeight ? wnd.minHeight
                                            : (wnd.maxHeight && height > wnd.maxHeight) ? wnd.maxHeight
                                            : height));
                        }
                    };

                    $.each(wnd.resizeDirection.split(""), function () {
                        resizeHandlers[this]();
                    });

                    fixIE6Sizing($element);

                    if ($.browser.msie && parseInt($.browser.version) >= 9) {
                        $element[0].style.cssText = $element[0].style.cssText;
                    }

                    $t.trigger(wnd.element, 'resize');
                }

                function stop(e) {
                    var $element = $(wnd.element);
                    $element
                        .find('.t-overlay').remove().end()
                        .find('.t-resize-handle').not(e.$draggable).show();
                    
                    $(document.body).css('cursor', '');

                    if (e.keyCode == 27) {
                        fixIE6Sizing($element);
                        $element.css(wnd.initialCursorPosition);
                        wnd.resizeElement.css(wnd.initialSize);
                    }
                    
                    return false;
                }

                new $t.draggable({
                    owner: wnd.element,
                    selector: '.t-resize-handle',
                    scope: wnd.element.id + '-resizing',
                    distance: 0,
                    start: start,
                    drag: drag,
                    stop: stop
                });
            })(this);
        }

        if (this.draggable) {
            (function(wnd){
                function start(e) {
                    var $element = $(wnd.element),
                        location = $t.touchLocation(e);

                    wnd.initialWindowPosition = $element.position();
    
                    $t.trigger(element, 'dragStart');

                    wnd.startPosition = {
                        left: location.x - wnd.initialWindowPosition.left,
                        top: location.y - wnd.initialWindowPosition.top
                    };

                    var actionsElement = $element.find(".t-window-actions");
                    if (actionsElement.length > 0) {
                        if (wnd.isRtl == undefined) {
                            wnd.isRtl = $(wnd.element).closest('.t-rtl').length > 0;
                        }
                        wnd.minLeftPosition = actionsElement.outerWidth() + parseInt(actionsElement.css(wnd.isRtl ? "left" : "right"), 10) - $element.outerWidth();
                    } else {
                        wnd.minLeftPosition =  20 - $element.outerWidth(); // at least 20px remain visible
                    }

                    $('.t-resize-handle', wnd.element).hide();

                    $('<div class="t-overlay" />').appendTo(wnd.element);

                    $(document.body).css('cursor', e.$draggable.css('cursor'));
                }
                
                function drag(e) {
                    var location = $t.touchLocation(e),
                        coordinates = {
                        left: Math.max(location.x - wnd.startPosition.left, wnd.minLeftPosition),
                        top: Math.max(location.y - wnd.startPosition.top, 0)
                    };
                    $(wnd.element).css(coordinates);
                }

                function stop(e) {
                    $(wnd.element).find('.t-resize-handle')
                                  .show()
                                  .end()
                                  .find('.t-overlay')
                                  .remove();

                    $(document.body).css('cursor', '');

                    if (e.keyCode == 27)
                        e.$draggable.closest('.t-window').css(wnd.initialWindowPosition);

                    $t.trigger(element, 'dragEnd');

                    return false;
                }

                new $t.draggable({
                    owner: wnd.element,
                    selector: '.t-window-titlebar',
                    scope: wnd.element.id + '-moving',
                    start: start,
                    drag: drag,
                    stop: stop
                })
            })(this);
        }

        $t.bind(this, {
            open: this.onOpen,
            activated: this.onActivate,
            close: this.onClose,
            refresh: this.onRefresh,
            resize: this.onResize,
            error: this.onError,
            load: this.onLoad,
            dragStart: this.onDragStart,
            dragEnd: this.onDragEnd
        });

        $(window).resize($.proxy(this.onDocumentResize, this));

        if (isLocalUrl(this.contentUrl)) {
            this.ajaxRequest();
        }
    };

    $t.window.prototype = {
        overlay: function (visible) {
            var overlay = $('body > .t-overlay'),
                element = this.element;

            if (overlay.length == 0) {
                overlay = $('<div class="t-overlay" />')
                    .toggle(visible)
                    .insertBefore(element);
            } else {
                overlay.insertBefore(element).toggle(visible);
            }

            this.positionOverlay(overlay);

            return overlay;
        },

        positionOverlay: function(overlay) {
            var $doc = $(document);
            if ($.browser.msie && $.browser.version < 7) {
                overlay.css({
                    width: $doc.width() - 21,
                    height: $doc.height(),
                    position: 'absolute'
                });
            } else if ((/ipad/gi).test(navigator.appVersion)) {
                overlay.css({
                    width: $doc.width(),
                    height: $doc.height(),
                    position: 'absolute'
                });
            }
        },

        overlayOnClose: function(isDestroying) {
            var currentWindow = this;
            var openedModalWindows = $('.t-window').filter(function() {
                    var window = $(this);
                    return this !== currentWindow.element && window.is(':visible') && window.data('tWindow').modal;
                });
                        
            var shouldHideOverlay = currentWindow.modal && openedModalWindows.length == 0;

            var overlay = currentWindow.modal ? currentWindow.overlay(true) : $(undefined);

            if (shouldHideOverlay) {
                if (currentWindow.effects.list.length > 0 && currentWindow.effects.list[0].name != 'toggle') {
                    overlay.fadeOut(currentWindow.effects.closeDuration, function() {
                        if (isDestroying) {
                           overlay.remove(); 
                        }
                    });
                } else if (isDestroying) {
                    overlay.remove(); 
                } else {
                    overlay.hide();
                }
            } else if (openedModalWindows.length > 0) {
                var overlayZIndex = parseInt($('.t-overlay').css('zIndex'), 10);
                var maxZIndex = 0;
                var otherWindowOnTop;
                openedModalWindows.each(function(index, element) {
                    var newZIndex = parseInt($(element).css('zIndex'), 10);
                    if (newZIndex >= maxZIndex) {
                        maxZIndex = newZIndex;
                        otherWindowOnTop = $(element);
                    }
                });
                var otherWindow = otherWindowOnTop.data("tWindow");
                otherWindow.overlay(true).css('zIndex', maxZIndex - 1);
            }
        },

        windowActionHandler: function (e) {
            var $target = $(e.target).closest('.t-link').find('.t-icon'),
                contextWindow = this;

            $.each({
                't-close': this.close,
                't-maximize': this.maximize,
                't-restore': this.restore,
                't-refresh': this.refresh
            }, function (commandName, handler) {
                if ($target.hasClass(commandName)) {
                    e.preventDefault();
                    handler.call(contextWindow);
                    return false;
                }
            });
        },

        center: function () {                       
            var $element = $(this.element),
                documentWindow = $(window);

            $element.css({
                left: documentWindow.scrollLeft() + Math.max(0, (documentWindow.width() - $element.width()) / 2),
                top: documentWindow.scrollTop() + Math.max(0, (documentWindow.height() - $element.height()) / 2)
            });

            return this;
        },

        title: function (text) {
            var $title = $('.t-window-titlebar > .t-window-title', this.element);

            if (!text)
                return $title.text();

            $title.text(text);
            return this;
        },

        content: function (html) {
            var $content = $('> .t-window-content', this.element);

            if (!html)
                return $content.html();

            $content.html(html);
            return this;
        },

        bringToTop: function () {
            var zIndex = 0,
                that = this,
                element = that.element,
                allWindows = $(".t-window");

            if (allWindows.filter(":visible").length == 1 && $(element).is(":visible")) {
                return;
            }

            allWindows.each(function() {
                var wnd = $(this);
                var zIndexNew = wnd.css('zIndex');
                if (!isNaN(zIndexNew)) {
                    zIndex = Math.max(parseInt(zIndexNew, 10), zIndex);
                }

                if (this != element && wnd.find(".t-window-content > iframe").length > 0) {
                    wnd.find(".t-window-content").append("<div class='t-overlay' />");
                }
            });

            $(element)
                .css("zIndex", zIndex + 2)
                .find(".t-window-content > .t-overlay").remove();

            return that;
        },

        open: function (e) {
            var $element = $(this.element);

            this.bringToTop();

            if (!$t.trigger(this.element, 'open')) {
                if (this.modal) {
                    var overlay = this.overlay(false).css("zIndex", parseInt($element.css('zIndex'), 10) - 1);

                    if (this.effects.list.length > 0 && this.effects.list[0].name != 'toggle') {
                        overlay.css('opacity', 0).show().animate({ opacity: 0.5 }, this.effects.openDuration);
                    } else {
                        overlay.css('opacity', 0.5).show();
                    }
                }
                
                if (!$element.is(':visible')) {
                    $t.fx.play(this.effects, $element, {}, function() {
                        $t.trigger($element[0], 'activated');
                    });
                }
            }

           if (this.isMaximized) {
               $('html, body').css('overflow', 'hidden');
            }

            return this;
        },

        close: function () {
            var $element = $(this.element);

            if ($element.is(':visible')) {
                if (!$t.trigger(this.element, 'close')) {
                    this.overlayOnClose();
                    $t.fx.rewind(this.effects, $element, null, function () {
                        $element.hide();
                    });
                }
            }

            if (this.isMaximized) {
                $('html, body').css('overflow', '');
            }

            return this;
        },

        toggleMaximization: function (e) {
            if (e && $(e.target).closest('.t-link').length > 0) {
                return;
            }

            this[this.isMaximized ? 'restore' : 'maximize']();
        },

        restore: function () {
            if (!this.isMaximized) {
                return;
            }

            $(this.element)
                .css({
                    position: 'absolute',
                    left: this.restorationSettings.left,
                    top: this.restorationSettings.top
                })
                .find('> .t-window-content')
                    .css({
                        width: this.restorationSettings.width,
                        height: this.restorationSettings.height
                    }).end()
                .find('.t-resize-handle').show().end()
                .find('.t-window-titlebar .t-restore').addClass('t-maximize').removeClass('t-restore');

            $('html, body').css('overflow', '');

            this.isMaximized = false;

            $t.trigger(this.element, 'resize');

            return this;
        },

        maximize: function (e) {
            if (this.isMaximized) {
                return;
            }

            var $element = $(this.element),
                resizeElement = $element.find('> .t-window-content');

            this.restorationSettings = {
                left: $element.position().left,
                top: $element.position().top,
                width: resizeElement.width(),
                height: resizeElement.height()
            };

            $element
                .css({ left: 0, top: 0, position: 'fixed' })
                .find('.t-resize-handle').hide().end()
                .find('.t-window-titlebar .t-maximize').addClass('t-restore').removeClass('t-maximize');

            $('html, body').css('overflow', 'hidden');

            this.isMaximized = true;

            this.onDocumentResize();

            return this;
        },

        onDocumentResize: function () {
            if (!this.isMaximized) {
                return;
            }

            var $element = $(this.element),
                resizeElement = $element.find('> .t-window-content');

            resizeElement
                .css({
                    width: $(window).width()
                        - (resizeElement.outerWidth() - resizeElement.width()
                        + $element.outerWidth() - $element.width()),
                    height: $(window).height()
                        - (resizeElement.outerHeight() - resizeElement.height()
                        + $element.outerHeight() - $element.height()
                        + $element.find('> .t-window-titlebar').outerHeight())
                });

            fixIE6Sizing($element);

            $t.trigger($element, 'resize');
        },

        refresh: function () {
            if (isLocalUrl(this.contentUrl)) {
                this.ajaxRequest();
            } else {
                var iframe = $(this.element).find('> .t-window-content > iframe')[0];
                if (iframe) {
                    iframe.src = iframe.src;
                }
            }

            return this;
        },

        ajaxRequest: function (url, data) {
            var loadingIconTimeout = setTimeout(function () {
                $('.t-refresh', this.element).addClass('t-loading');
            }, 100);

            $.ajax({
                type: 'GET',
                url: url || this.contentUrl,
                dataType: 'html',
                data: data || {},
                cache: false,
                error: $.proxy(function (xhr, status) {
                    if ($t.ajaxError(this.element, 'error', xhr, status))
                        return;
                }, this),

                complete: function () {
                    clearTimeout(loadingIconTimeout);
                    $('.t-refresh', this.element).removeClass('t-loading');
                },
                success: $.proxy(function (data, textStatus) {
                    $('.t-window-content', this.element).html(data);

                    $t.trigger(this.element, 'refresh');
                }, this)
            });
        },

        destroy: function () {
            $(this.element).remove();
            this.overlayOnClose(true);
        }
    };

    // client-side rendering
    $.extend($t.window, {
        create: function () {
            var element, options, contentUrl;

            if ($.isPlainObject(arguments[0])) {
                options = arguments[0];
            } else {
                element = arguments[0];
                options = $.extend({
                    html: element.innerHTML
                }, arguments[1]);
            }

            options = $.extend({
                title: '',
                html: '',
                actions: ['Close'],
                visible: true
            }, options);

            contentUrl = options.contentUrl;

            var windowHtml = new $t.stringBuilder()
                .catIf('<div class="t-widget t-window">', !element)
                    .cat('<div class="t-window-titlebar t-header">')
                        .cat('&nbsp;<span class="t-window-title">').cat(options.title).cat('</span>')
                        .cat('<div class="t-window-actions t-header">');

            $.map(options.actions, function (command) {
                windowHtml.cat('<a href="#" class="t-link">')
                        .cat('<span class="t-icon t-').cat(command.toLowerCase()).cat('">')
                            .cat(command)
                        .cat('</span></a>');
            });

            windowHtml.cat('</div></div>')
                .cat('<div class="t-window-content t-content" style="');

            if (options.width) {
                windowHtml.cat('width:').cat(options.width).cat('px;');
            }

            if (options.height) {
                windowHtml.cat('height:').cat(options.height).cat('px;');
            }

            if (typeof (options.scrollable) != typeof(undefined) && options.scrollable === false) {
                windowHtml.cat('overflow:hidden;');
            }

            windowHtml.cat('">')
                    .catIf(options.html, !contentUrl || (contentUrl && isLocalUrl(contentUrl)))
                    .catIf('<iframe src="', contentUrl,
                            '" title="', options.title,
                            '" frameborder="0" style="border:0;width:100%;height:100%;">This page requires frames in order to show content</iframe>',
                        contentUrl && !isLocalUrl(contentUrl))
                    .cat('</div>')
                .catIf('</div>', !element);

            if (element) {
                $(element).css("display", options.visible ? "" : "none").html(windowHtml.string());
            } else {
                delete options.title;
                return $(windowHtml.string()).css("display", options.visible ? "" : "none").appendTo(document.body).eq(0).tWindow(options);
            }
        },

        getResizeHandlesHtml: function () {
            var html = new $t.stringBuilder();

            $.each('n e s w se sw ne nw'.split(' '), function (i, item) {
                html.cat('<div class="t-resize-handle t-resize-').cat(item).catIf(" t-icon", item == "se").cat('"></div>');
            });

            return html.string();
        }
    });

    // jQuery extender
    $.fn.tWindow = function (options) {
        return $t.create(this, {
            name: 'tWindow',
            init: function (element, options) {
                return new $t.window(element, options);
            },
            success: function(component) {
                var element = component.element,
                    $element = $(element);

                if ($element.is(':visible')) {
                    $t.trigger(element, 'open');
                    $t.trigger(element, 'activated');
                }
            },
            options: options
        });
    };

    // default options
    $.fn.tWindow.defaults = {
        effects: { list: [{ name: 'zoom' }, { name: 'property', properties: ['opacity']}], openDuration: 'fast', closeDuration: 'fast' },
        modal: false,
        resizable: true,
        draggable: true,
        minWidth: 50,
        minHeight: 50
    };
})(jQuery);
(function($, undefined){
    
    var $t = $.telerik, q = $.telerik.query;

    $t.scripts.push("telerik.imagebrowser.js"); 

    $t.imageBrowser = function(element, options) {
        this.element = element;
        this.wrapper = $(element);

        var filter = options.filter || "*.png,*.gif,*.jpg,*.jpeg";
        var localization = options.localization;
        this.wrapper.append('<div class="t-floatwrap"><div class="t-widget t-combobox t-header t-breadcrumbs"><div class="t-dropdown-wrap t-state-default"><input type="text" class="t-input" /><div class="t-breadcrumbs-wrap"/><span class="t-select t-header"><span class="t-icon t-arrow-down">select</span></span></div></div><div class="t-widget t-combobox t-dropdown-wrap t-search-wrap" /></div>')
                    .append(toolBar(localization, options.uploadUrl, options.createDirectoryUrl, options.deleteFileUrl || options.deleteDirectoryUrl))
                    .append('<ul id="t-editor-image-list" class="t-reset t-floats t-tiles" />');
    
        var breadcrumbs = this.wrapper.find(".t-breadcrumbs");
        var listView = this.wrapper.find(".t-tiles");
        var searchBox = this.wrapper.find(".t-search-wrap");
        
        if (options.uploadUrl) {
            this.wrapper.find(".t-upload input").tUpload({
                    async: {
                        saveUrl: options.uploadUrl,
                        autoUpload: true
                    },
                    multiple: false,
                    onUpload: function(e) {
                        var rfilter = new RegExp(("(" + filter.split(",").join(")|(") + ")").replace( /\*\./g , ".*\."), "i");

                        var fileName = e.files[0].name;

                        if (rfilter.test(fileName)) {
                            e.data = { path: breadcrumbs.val() };

                            listView.trigger("t:upload", [{ name: fileName }, function() {
                                    e.preventDefault();
                                }]);
                        } else {
                            e.preventDefault();
                            alert($t.formatString(localization.invalidFileType, fileName, filter));
                        }
                    },
                    onError: function(e) {
                        e.preventDefault();
                        listView.trigger("t:error", [e.files[0]]);

                        var xhr = e.XMLHttpRequest;
                        if ($t.ajaxError(options.element, 'error', xhr, xhr.statusText))
                            return;
                    },
                    onSuccess: function(e) {
                        listView.trigger("t:completeFile", [$.extend(e.response, { path: breadcrumbs.val() })]);
                    }
                });
        }
        new $t.searchBox(searchBox[0]);
        
        new $t.fileListView(listView[0], { thumbnailUrl: options.thumbUrl, localization: localization });
            
        var dropDown = new $t.dropDown({ 
            effects: $t.fx.slide.defaults(),
            onClick: function (e) {
                $(element).find(".t-tiles-arrange a span:first").html($(e.item).text());
                dropDown.close();
                breadcrumbs.trigger("t:change");
            }
        });
            
        var arrangeBy = [{ Text: localization.orderByName, Value: "name" }, { Text:localization.orderBySize, Value: "size" }];
            
        dropDown.dataBind(arrangeBy);

        this.wrapper.find(".t-tiles-arrange a").click(function(e) {
            e.preventDefault();
            var a = $(this);
            dropDown.open({
                offset: a.offset(),
                outerHeight: a.outerHeight(),
                outerWidth: a.outerWidth(),
                zIndex: $t.getElementZIndex(this)
            });
        }).end().delegate(".t-button:not(.t-state-disabled):has(.t-delete)", "click", function() {
            var selected = listView.find(".t-state-selected");
            
            if (selected.length && confirm($t.formatString(localization.deleteFile, selected.find("strong").text()))) {
                $.ajax( {
                    type: "POST",
                    url: selected.data("kind") == "f" ? options.deleteFileUrl : options.deleteDirectoryUrl,
                    data: { path: selected.data("url") },
                    error: function (xhr, status) {
                        if ($t.ajaxError(options.element, 'error', xhr, status))
                            return;
                    },
                    success: function() {
                        listView.trigger("t:delete");
                        $(element).find(".t-delete").parent().addClass("t-state-disabled");
                    }
                });
            }
        }).delegate(".t-button:not(.t-state-disabled):has(.t-addfolder)", "click", function() {
            listView.trigger("t:createDirectory", [function(name) {
                $.ajax( {
                    type: "POST",
                    url: options.createDirectoryUrl,
                    data: { path: breadcrumbs.val(), name: name },
                    error: function (xhr, status) {
                        listView.trigger("t:errorDirectory", { name: name });
                        if ($t.ajaxError(options.element, 'error', xhr, status))
                            return;
                    },
                    success: function() {
                        listView.trigger("t:completeDirectory", { path: breadcrumbs.val(), name: name });
                    }
                });
            }]);
        });

        $(document.documentElement).bind('mousedown', function (e) {
            var element = dropDown.$element[0];

            if (!$.contains(element, e.target)) {
                dropDown.close();
            }
        });
            
        var dataSource = new $t.dataSource({
            error: function (xhr, status) {
                var prevented = $t.trigger(options.element, "error",
                {
                    XMLHttpRequest: xhr,
                    textStatus: status
                });
                if (!prevented) {
                    if (status == 'error') { 
                        if (xhr.status == '404') {
                            alert(options.localization.directoryNotFound);
                        } else if (xhr.status != '0') {
                            alert('Error! The requested URL returned ' + xhr.status + ' - ' + xhr.statusText);
                        }
                    } else if (status == 'timeout') {
                        alert('Error! Server timeout.');
                    }
                }
            },
            url: options.selectUrl,
            callback: function (data) {                
                $(element).find(".t-delete").parent().addClass("t-state-disabled");
                
                if (!breadcrumbs.val()) {
                    new $t.breadcrumbs(breadcrumbs[0], { path: data.Path, roots: data.ContentPaths });
                }

                breadcrumbs.val(data.Path).trigger("t:refresh");
                var arrangeByText = $(element).find(".t-tiles-arrange a span:first").text();
                var sortOrder = $.map(arrangeBy, function(item) { if (item.Text == arrangeByText) return item.Value; })[0];
                var filter = searchBox.val();
                listView.trigger("t:refresh",[data, sortOrder, filter]);
            }
        });

        searchBox.bind("t:change", function() {
            breadcrumbs.trigger("t:change");
        });

        dataSource.get({ path: "" });

        listView.bind("t:select", function (args) {
            if (args.kind == "d") {
                dataSource.get({ path: args.url });
            } else {                
                options.apply(args);
            }
        }).bind("t:change", function (args) {
            var deleteButton = $(element).find(".t-delete").parent().addClass("t-state-disabled");
                
            if (args.kind == "f") {
                var url = args.url;
                if(options.imageUrl) {
                    url = options.imageUrl + "?path=" + url;
                }
                $(element).parent().find('#t-editor-image-url').val(url);
            }
                
            if ((args.kind == "f" && options.deleteFileUrl) || (args.kind == "d" && options.deleteDirectoryUrl)) {
               deleteButton.removeClass("t-state-disabled");
            } 
        });

        breadcrumbs.bind("t:change", function() {
            var value = $(this).val();
            if(!value.match(/\/$/)) {
                value = value + "/";
            }
            dataSource.get({ path: value });
        });
    };

    function toolBar(localization, canUpload, canAddFolder, canRemove) {
        var upload = !canUpload ? "" : '<div class="t-widget t-upload"><div class="t-button t-button-icontext t-button-bare t-upload-button"><span class="t-icon t-add"></span>' + localization.uploadFile + '<input type="file" name="file" /></div></div>',
            addFolder = !canAddFolder ? "" : '<button type="button" class="t-button t-button-icon t-button-bare"><span class="t-icon t-addfolder"></span></button>',
            remove = !canRemove ? "" : '<button type="button" class="t-button t-button-icon t-button-bare t-state-disabled"><span class="t-icon t-delete"></span></button>&nbsp;';
        
        return '<div class="t-widget t-toolbar t-floatwrap">' +
                        '<div class="t-toolbar-wrap">' + upload + addFolder + remove +
                        '</div>' +
                        '<div class="t-tiles-arrange">' +
                                localization.orderBy + ' <a href="#" class="t-link"><span>' + localization.orderByName + '</span><span class="t-icon t-arrow-down"></span></a>' +
                        '</div>' +
                '</div>';
    }

    $t.fileInfoReader = function(options){
        this._thumbnailUrl = options.thumbnailUrl || "";
    }

    $t.fileInfoReader.prototype = {
        read: function (key, data) {
            return data[key] || data[(key.charAt(0).toUpperCase() + key.substring(1))];
        },

        directories: function (data) {
            return this.read("directories", data);
        },
        files: function (data) {
            return this.read("files", data);
        },
        thumbUrl: function(path, name) {
            return this._thumbnailUrl + "/?path=" + path + encodeURIComponent(name);
        },
        size: function(item) {
            var value = this.read("size", item);
            if(!value) {
                return "";
            }

            var suffix = " bytes";

            if (value >= 1073741824) {
                suffix = " GB";
                value /= 1073741824;
            } else if (value >= 1048576) {
                suffix = " MB";
                value /= 1048576;
            } else  if (value >= 1024) {
                suffix = " KB";
                value /= 1024;
            } 
            
            return Math.round(value * 100) / 100 + suffix;
        },        
        name: function(item) {
            return this.read("name", item);
        },        
        path: function(data) {
            return this.read("path", data);
        },
        concatPaths: function(path, name){
            if(path === undefined || !path.match(/\/$/)) {
                path = (path || "") + "/";
            }
            return path + encodeURIComponent(name);
        }
    };

    $t.fileListView = function (element, options) {
        this.element = element;
        this.wrapper = $(element);
        this._localization = options.localization;
        this._reader = options.reader || new $t.fileInfoReader({thumbnailUrl: options.thumbnailUrl});

        this._pageSize = options.pageSize || 20;
        
        this.wrapper.bind({
                        "t:refresh": $.proxy(this._refresh, this),
                        "t:upload": $.proxy(this._upload, this),
                        "t:completeDirectory": $.proxy(this._completeDirectory, this),
                        "t:delete": $.proxy(this._delete, this),
                        "t:errorFile": $.proxy(this._errorFile, this),
                        "t:errorDirectory": $.proxy(this._errorDirectory, this),
                        "t:createDirectory": $.proxy(this._createDirectory, this),
                        "scroll": $.proxy(this._scroll, this) 
                    })
                    .delegate("li[data-url]:not(.t-tile-empty)", "click", $.proxy(this._click, this))
                    .delegate("li[data-url]:not(.t-tile-empty)", "dblclick", $.proxy(this._dblclick, this));
    }
    
    function loadingHtml(item) {
         return '<li class="t-tile" data-filename="' + item.name + '">' +
                    '<div class="t-thumb">' +
                        '<span class="t-icon t-loading"></span>' +
                    '</div>' +
                    '<strong>' + item.name + '</strong>' +
                '</li>';
    }

    function emptyHtml(text) {
        return '<li class="t-tile-empty">' +
                  '<strong>' + text  + '</strong>' +
               '</li>';
    }

    function fileHtml(item) {
         return '<li class="t-tile" data-filename="' + item.name + '" data-thumburl="' + item.thumbUrl + '" data-url="' + item.url +'" data-kind="' + item.kind + '">' +
                    '<div class="t-thumb">' +
                        '<span class="t-icon t-loading"></span>' +
                    '</div>' +
                    '<strong>' + item.name + '</strong>' +                    
                    '<span class="t-filesize">' + item.size + '</span>'
                '</li>';
    }

    function directoryHtml(item) {
         return '<li class="t-tile" data-url="' + item.url +'" data-kind="' + item.kind + '">' +
                    '<div class="t-thumb">' +
                        '<span class="t-icon t-folder"></span>' +
                    '</div>' +
                    '<strong>' + item.name + '</strong>' +
                '</li>';
    }    

    function newDirectoryHtml(name) {
        return '<li class="t-tile" data-kind="d">' +
                    '<div class="t-thumb">' +
                        '<span class="t-icon t-folder"></span>' +
                    "</div>" +
                    '<input class="t-input" value="' + name + '" />' +
                '</li>';        
    }

    function load(li) {        
        var element = $(li);
        var img = $("<img />", {                           
                alt: element.data("filename") 
            })            
            .hide()
            .bind("load", function() {                       
                $(this).prev().remove().end().addClass("t-image").fadeIn();
            });
            
                    
        element.find(".t-loading").after(img);
               
        // IE8 will trigger the load event immediately when the src is assign 
        // if the image is loaded from the cache
        img.attr("src", element.data("thumburl"));

        li.loaded = true;        
    }

    if ($.browser.msie && parseFloat($.browser.version) < 8) {
        var offsetTop = function (element) {
            return element.offsetTop;
        }
    } else {
        var offsetTop = function (element) {
            return element.offsetTop - $(element).height();
        }
    }

    var rescape = /(\:|\^|\$|\/|\.|\+|\||\(|\)|\[|\]|\{|\}|\\)/g,
        rstar = /\*/g,
        rquestion = /\?/g;
    
    function wildcardToRegExp(value) {
        return new RegExp(value.replace(rescape, "\\$1").replace(rstar, ".*").replace(rquestion, ".?"), "ig");
    }

    $t.fileListView.prototype = {
        bindTo: function(data, orderBy, filter) {
            this._filter = filter;
            var reader = this._reader;
            this.wrapper.empty(); 
            
            var directories = q(this._reader.directories(data) || []);
            var files = q(this._reader.files(data) || []);
            
            if (filter) {
                var where = function(item){
                    return wildcardToRegExp(filter).test(reader.name(item));
                };

                directories = directories.where(where);
                files = files.where(where);
            }

            var selector = function(item) {
                return reader[orderBy](item);
            };           

            this._data = this._process(this._reader.path(data), 
                directories.orderBy(selector),
                files.orderBy(selector)
            );            
                       
            var html = this._data
                           .select(function(item) {
                               return item.kind == "f" ? fileHtml(item) : directoryHtml(item);
                           })
                           .toArray()
                           .join("");
            
            this.wrapper.append(html);

            this._tiles = this.wrapper.find("li[data-kind=f]");
            this._scroll();
            this._asEmpty();
        },
        
        _asEmpty: function() {
            if (!this._data.any() && !this._filter) {
                this.wrapper.append(emptyHtml(this._localization.emptyFolder));
            }
        },

        _completeFile: function(file, originalFileName) {
            var name = this._reader.name(file);
            var path = this._reader.path(file);
            
            var li = $(fileHtml({
                kind: "f",
                thumbUrl: this._reader.thumbUrl(path, name),
                url: this._reader.concatPaths(path, name),
                    name: name,
                size: this._reader.size(file)
            }));
                
            this.wrapper.find("li").eq(this.fileIndex(originalFileName)).replaceWith(li);
     
            load(li[0]);
                    
            li.click();
        },
        
        _completeDirectory: function(e, directory) {
            var name = this._reader.name(directory);
            var path = this._reader.path(directory);

            var li = $(directoryHtml({ 
                kind:"d", 
                url: this._reader.concatPaths(path, name),
                name: name
            }));
                
            this.wrapper.find("li").eq(this.directoryIndex(name)).replaceWith(li);
        },

        _delete: function() {
            var selected = this.wrapper.find(".t-state-selected");
            if (selected.length) {
                var data = this._data.toArray();
                data.splice(selected.index(), 1);
                this._data = q(data);
                selected.remove();
                
                this._scroll();

                this._asEmpty();
            }
        },

        _scroll: function(e) {            
            clearTimeout(this._timeout);
            
            this._timeout = setTimeout($.proxy(function() {
                var height = this.wrapper.outerHeight();
                var viewTop = this.wrapper.scrollTop();
            
                var viewBottom = viewTop + height;
            
                this._tiles.each(function() {
                    var top = offsetTop(this);
                    var bottom = top + this.offsetHeight;

                    if ((top >= viewTop && top < viewBottom) || (bottom >= viewTop && bottom < viewBottom)) {                        
                       load(this);
                    }
                
                    if (top > viewBottom) {
                        return false;
                    }
                });

                this._tiles = this._tiles.filter(function() { 
                    return !this.loaded; 
                });
                
            }, this), 250);
        },

        _upload: function(e, file, preventDefault) {
            var fileName = file.name;
            var existingFileIndex = this.fileIndex(fileName);
            
            if (existingFileIndex > -1 && !confirm($t.formatString(this._localization.overwriteFile, fileName))) {
                preventDefault();
            } else {
                this.wrapper.find(".t-tile-empty").remove();

                var li = $(loadingHtml(file));
            
                if(existingFileIndex > -1) {
                    li.data("existing", true);
                    this.wrapper.find("li").eq(existingFileIndex).replaceWith(li);
                } else {
                    
                    var firstFile = this.wrapper.find("li[data-kind=f]:first");
                
                    if (firstFile.length) {
                        firstFile.before(li);
                    } else {
                        this.wrapper.append(li);
                    }
                    
                    var data = this._data.toArray();

                    data.splice(li.index(), 0, {
                        name: fileName,
                        kind: "f"
                    });
                }

                this.wrapper.scrollTop(li.attr("offsetTop") - this.element.offsetHeight);

                this.wrapper.one("t:completeFile", $.proxy(function(e, file) {
                    this._completeFile(file, fileName);                                        
                }, this));
            }
        },
        _nameDirectory: function() {
            var name = "New folder";

            var directoryNames = this._data.where(function(item) {
                return item.kind == "d" && item.name.indexOf(name) > -1;
            }).select(function(directory) {
                return directory.name;
            }).toArray();

            if ($.inArray(name, directoryNames) > -1) {
                var index = 2;

                do {
                    var candidate = name + " (" + index + ")";
                    index ++;
                } while ($.inArray(candidate, directoryNames) > -1);

                name = candidate;
            }

            return name;
        },
        _createDirectory: function(e, callback) {
            var name = this._nameDirectory();

            var li = $(newDirectoryHtml(name));
            
            var firstFile = this.wrapper.find("li[data-kind=f]:first");
                
            if (firstFile.length) {
                firstFile.before(li);
            } else {
                this.wrapper.append(li);
            }
            var data = this._data.toArray();

            var input = li.addClass("t-state-selected")
              .siblings()
              .removeClass("t-state-selected")
              .end()
              .find("input").keydown(function(e) {
                if (e.keyCode == 13) {
                    this.blur();
                }
              }).blur($.proxy(function(e) {                    
                    var value = $.trim(e.target.value);
                    
                    if (!value || this._data.any(function (item) {
                        return item.kind == "d" && item.name.toLowerCase() == value.toLowerCase();
                    })) {
                        value = this._nameDirectory();
                    }
                    
                    data.splice(li.index(), 0, {
                        name: value,
                        kind: "d"
                    });
                
                    $(e.target).replaceWith("<strong>" + value + "</strong>");

                    callback(value);
              }, this));
            
            setTimeout(function() {
                input.select();
            })

            this.wrapper.find(".t-tile-empty").remove();
            this.wrapper.scrollTop(li.attr("offsetTop") - this.element.offsetHeight);
        },

        _errorFile: function(e, file) {
            var index = this.fileIndex(file.name);
            
            if (index > -1) {
                var li = this.wrapper.find("li").eq(index);
                if (li.data("existing")) {
                    var replacement = $(fileHtml(this._data.toArray()[index]));
                    li.replaceWith(replacement);
                    load(replacement[0]);
                } else {
                    li.remove();
                    this._data.toArray().splice(index, 1);
                }
                this._asEmpty();
            }
        },

        _errorDirectory: function(e, directory) {
            var index = this.directoryIndex(directory.name);
            if (index > -1) {
                this.wrapper.find("li").eq(index).remove();
                this._data.toArray().splice(index, 1);
                this._asEmpty();
            }
        },
        
        fileIndex: function(name) {
            return this._index("f", name);
        },

        directoryIndex: function(name) {
            return this._index("d", name);
        },

        _index: function(kind, name) {
            var result = -1,
                data = this._data ? this._data.toArray() : [];

            name = name.toLowerCase();

            $.each(data, function (index, item) {
                if (item.kind == kind && item.name.toLowerCase() == name) {
                    result = index;
                    return false;
                }
            });
            
            return result;
        },

        _raise: function(e, type) {
            var div = $(e.currentTarget);
            
            $t.trigger(this.wrapper, type, {
                kind: div.data("kind"),
                url: div.data("url")
            });
        },

        _click: function (e) {
            $(e.currentTarget).addClass("t-state-selected")
                              .siblings()
                              .removeClass("t-state-selected");
            
            this._raise(e, "t:change");
        },

        _dblclick: function (e) {
            // clear selection for IE
            if(document.selection && document.selection.empty) {
                document.selection.empty();
            } 
            
            this._raise(e, "t:select");
        },
        
        _refresh: function(e, data, orderBy, filter) {
            this.bindTo(data, orderBy, filter);
        },

        _process: function(path, directories, files) {
            var reader = this._reader;
            
            var directories = directories.select(function (dir) {
                return {                    
                    url: reader.concatPaths(path, reader.name(dir)),
                    name: reader.name(dir),
                    kind: "d"
                };
            });
            
            var files = files.select(function (file) {
                var name = reader.name(file);
                return {
                    url: reader.concatPaths(path, name),
                    name: name,
                    kind: "f",
                    thumbUrl: reader.thumbUrl(path, name),
                    size: reader.size(file)
                };
            });

            return directories.concat(files);
        }
    }

    $t.dataSource = function(options) {
        this._url = options.url;
        this._callback = options.callback;
        this._error = options.error;
    }

    $t.dataSource.prototype = {
        _complete: function (data) { 
            if(this._callback) {
                this._callback(data);
            }           
        },
        get: function(args){
            $.ajax({
                type: "POST",
                url: this._url,
                data: args,
                success: $.proxy(this._complete, this),
                error: this._error
            });
        }
    }

    $t.breadcrumbs = function (element, options) {
        this.element = element;
        this.wrapper = $(element);
        this._gap = options.gap || 50;        
        
        this._initPaths(options.path);
        
        var dropDown = new $t.dropDown({ 
            effects: $t.fx.slide.defaults(),
            onClick: $.proxy(function (e) {                
                var value = $(e.item).text();
                dropDown.close();
                this._initPaths(value);
                $(element).val(value).trigger("t:change");
            }, this)
        });            

        dropDown.dataBind(options.roots);
        
        this.wrapper.delegate("input", "focus", $.proxy(this._focus, this))
                    .delegate("input", "blur", $.proxy(this._blur, this))
                    .delegate("input", "keydown", $.proxy(function(e) {
                        if (e.keyCode == 13) {
                            this._blur();
                        }
                    }, this))
                    .delegate("a:not(.t-first)", "click", $t.stopAll(this._click, this))
                    .delegate(".t-select", "click", function() {
                        var a = $(element);
                        dropDown.open({
                            offset: a.offset(),
                            outerHeight: a.outerHeight(),
                            outerWidth: a.outerWidth(),
                            zIndex: $t.getElementZIndex(this)
                        });
                    })
                    .bind("t:refresh", $.proxy(this.refresh, this));
         
         $(document.documentElement).bind('mousedown', function (e) {
            var element = dropDown.$element[0];

            if (!$.contains(element, e.target)) {
                dropDown.close();
            }
        });
        
        this.value(options.path);
    }
    
    $t.breadcrumbs.prototype = {
        _initPaths: function(path) {
            this._basePath = (path || "").replace(/\/{2,}/g, "/").replace(/\/$/, "");
        
            path = this._basePath.split("/");
            path.pop();
        
            this._root = path.join("/");
        },
        _html: function () {
            var baseIndex = this._basePath.split("/").length - 1;

            var val = this.value();
            if(val === undefined || !val.match(/^\//)) {
                val = "/" + (val || "");
            }
            return '<div class="t-dropdown-wrap t-state-default">' +
                '<input type="text" class="t-input" />' +
                '<div class="t-breadcrumbs-wrap">' + 
                $.map(val.split("/"), function(segment, index) {
                    if (segment && index >= baseIndex) {
                        return '<a class="t-link" href="#">' + segment + '</a>';
                    }
                }).join('<span class="t-icon t-arrow-next">&gt;</span>') + 
                "</div>" + 
                '<span class="t-select t-header"><span class="t-icon t-arrow-down">select</span></span>' +
                "</div>";
        },

        _path: function (trail) {
            return this._root + "/" + $.map(trail, function(breadcrumb) {
                return $(breadcrumb).text();
            }).join("/");
        },
        
        _update: function(path) {
            path = path.charAt(0) === "/" ? path : "/" + path;

            var change = this.value() != path;

            this.value(path);
            
            if (change) {
                this.wrapper.trigger("t:change");
            }
        },

        value: function (path) {
            if (path !== undefined) {
                this.wrapper.val(path.replace(/\/{2,}/g, "/"));
                this.refresh();
            } else {
                return this.wrapper.val();
            }
        },

        _click: function(e) {
            this._update(this._path($(e.target).prevAll("a").andSelf()));
        },

        refresh: function() {
            this.wrapper.empty().append(this._html());

            var width = this.wrapper.width() - this._gap;
            
            var links = this.wrapper.find("a");

            links.each(function(index) {
                var a = $(this);
                
                if (a.parent().width() > width) {
                    if (index == links.length - 1) {
                        a.width(width);
                    } else {
                        a.prev().andSelf().hide();
                    }
                }
            });
        },
        
        _focus: function () {
            var input = this.wrapper.find(".t-breadcrumbs-wrap").hide()
                            .end().find("input").val(this.value());
            
            setTimeout(function() {
                input.select();
            });
        },
        
        _blur: function () {
            var value = this.wrapper.find("input").val().replace(/\/{2,}/g, "/");
            
            if (!value || value.toLowerCase().indexOf(this._basePath.toLowerCase()) < 0 ) {
                value = this._basePath;
            }
            
            this._update(value);
        }
    }

    $t.searchBox = function(element) {
        this.element = element;
        this.wrapper = $(element);

        this.wrapper.delegate("input", "focus", $.proxy(this._focus, this))
                    .delegate("input", "blur", $.proxy(this._blur, this))
                    .delegate("input", "keydown", $.proxy(function(e){
                        if (e.keyCode == 13) {
                            this._blur();
                        }
                    }, this))
                    .delegate("a", "click", $t.stopAll(this._click, this));

        this._render();
    }

    $t.searchBox.prototype = {
        _render: function() {
            var html = '<label for="t-imagebrowser-search">Search</label>' +
                       '<input type="text" id="t-imagebrowser-search" class="t-input" />' +
                       '<a href="#" class="t-icon t-search">search</a>';

            this.wrapper.empty().append($(html));
        },
        _focus: function() {    
            this.wrapper.find("label").hide();
        },
        _blur: function() {
            this._update(this.wrapper.find("input").val());

            if(this.value() == "") {
                this.wrapper.find("label").show();
            }
        },
        _update: function(val) {
            var change = this.value() != val;

            this.value(val);
            
            if (change) {
                this.wrapper.trigger("t:change");
            }
        },
        value: function (val) {
            if (val !== undefined) {
                this.wrapper.val(val);
            } else {
                return this.wrapper.val();
            }
        },
        _click: function() {
            this._blur();
        }
    };
    
})(jQuery);
(function ($) {
    var undefined,
        $t = $.telerik,
        rFileExtension = /\.([^\.]+)$/;

    $t.scripts.push("telerik.upload.js");

    $t.upload = function (element, options) {
        $.extend(this, options);

        this.element = element;
        this.name = element.name;

        var activeInput = $(element);
        this.wrapper = activeInput.closest(".t-upload");
        if (this.wrapper.length == 0) {
            this.wrapper = this._wrapInput(activeInput);
        }

        this._setActiveInput(activeInput);
        this.toggle(this.enabled);

        activeInput.closest("form").bind({
            "submit": $.proxy(this._onParentFormSubmit, this),
            "reset": $.proxy(this._onParentFormReset, this)
        });

        if (this.async.saveUrl != undefined) {
            this._module = this._getSupportsFormData() ?
                new formDataUploadModule(this) :
                new iframeUploadModule(this);
        } else {
            this._module = new syncUploadModule(this);
        }

        if (this._getSupportsDrop()) {
            this._setupDropZone();
        }

        this.wrapper
            .delegate(".t-upload-action", "click", $.proxy(this._onFileAction, this))
            .delegate(".t-upload-selected", "click", $.proxy(this._onUploadSelected, this))
            .delegate(".t-file", "t:progress", $.proxy(this._onFileProgress, this))
            .delegate(".t-file", "t:upload-success", $.proxy(this._onUploadSuccess, this))
            .delegate(".t-file", "t:upload-error", $.proxy(this._onUploadError, this));

        $t.bind(this.wrapper, {
            load: this.onLoad,
            select: this.onSelect,
            upload: this.onUpload,
            success: this.onSuccess,
            error: this.onError,
            complete: this.onComplete,
            cancel: this.onCancel,
            remove: this.onRemove
        });

        // Add a reference to the Upload in the wrapper data
        var wrapper = $(this.wrapper).data("tUpload", this);
        $(element).bind("load", function() {
            // Load is triggered for the input by $t.bind,
            // but we need it to trigger for the wrapper
            $t.trigger(wrapper, "load");
        });
    };

    $t.upload.prototype = {
        enable: function() {
            this.toggle(true);
        },

        disable: function() {
            this.toggle(false);
        },

        toggle: function(enable) {
            enable = typeof enable === "undefined" ? enable : !enable;
            this.wrapper.toggleClass("t-state-disabled", enable);
        },

        _addInput: function(input) {
            input
                .insertAfter(this.element)
                .data("tUpload", this);

            $(this.element)
                .hide()
                .removeAttr("id");

            this._setActiveInput(input);
        },

        _setActiveInput: function(input) {
            var wrapper = this.wrapper;
            this.element = input;

            input
                .attr("multiple", this._getSupportsMultiple() ? this.multiple : false)
                .attr("autocomplete", "off")
                .click(function(e) {
                    if (wrapper.hasClass("t-state-disabled")) {
                        e.preventDefault();
                    }
                })
                .change($.proxy(this._onInputChange, this));
        },

        _onInputChange: function(e)
        {
            var upload = this,
                input = $(e.target),
                prevented = $t.trigger(upload.wrapper, "select", { files: getInputFiles(input) });

            if (prevented) {
                upload._addInput(input.clone().val(""));
                input.remove();
            } else {
                input.trigger("t:select");
            }
        },

        _onDrop: function (e) {
			var dt = e.originalEvent.dataTransfer,
				droppedFiles = dt.files;
				
			stopEvent(e);

            if (droppedFiles.length > 0) {
                var prevented = $t.trigger(this.wrapper, "select", { files: getAllFileInfo(droppedFiles) });
                if (!prevented) {
                    $(".t-dropzone", this.wrapper).trigger("t:select", [ droppedFiles ]);
                }
            }
        },

        _enqueueFile: function(name, data) {
            var fileList =  $(".t-upload-files", this.wrapper);
            if (fileList.length == 0) {
                fileList = $("<ul class='t-upload-files t-reset'></ul>").appendTo(this.wrapper);
                if (!this.showFileList) {
                    fileList.hide();
                }
            }

            var existingFileEntries = $(".t-file", fileList);
            var fileEntry =
                $("<li class='t-file'><span class='t-icon'></span><span class='t-filename' title='" + name + "'>" + name + "</span></li>")
                .appendTo(fileList)
                .data(data);

            if (!this.multiple) {
                existingFileEntries.trigger("t:remove");
            }

            return fileEntry;
        },

        _removeFileEntry: function(fileEntry) {
            var fileList = fileEntry.closest(".t-upload-files"),
                allFiles;

            fileEntry.remove();
            allFiles = $(".t-file", fileList);

            if (allFiles.find("> .t-fail").length === allFiles.length) {
                this._hideUploadButton();
            }

            if (allFiles.length == 0) {
                fileList.remove();
            }
        },

        _setFileAction: function(fileElement, actionKey) {
            var classDictionary = { remove: "t-delete", cancel: "t-cancel", retry: "t-retry" };
            if (!classDictionary.hasOwnProperty(actionKey)) {
                return;
            }

            this._clearFileAction(fileElement);

            fileElement.append(
                this._renderAction(classDictionary[actionKey], this.localization[actionKey])
                .addClass("t-upload-action")
            );
        },

        _setFileState: function(fileEntry, stateKey) {
            var states = {
                uploading: {
                    cssClass: "t-loading",
                    text : this.localization.statusUploading
                },
                uploaded: {
                    cssClass: "t-success",
                    text : this.localization.statusUploaded
                },
                failed: {
                    cssClass: "t-fail",
                    text : this.localization.statusFailed
                }
            };

            var currentState = states[stateKey];
            if (currentState) {
                var icon = fileEntry.children(".t-icon").text(currentState.text);
                icon[0].className = "t-icon " + currentState.cssClass;
            }
        },

        _renderAction: function (actionClass, actionText) {
            if (actionClass != "") {
                return $(
                "<button type='button' class='t-button t-button-icontext'>" +
                    "<span class='t-icon " + actionClass + "'></span>" +
                    actionText +
                "</button>"
                )
            }
            else {
                return $(
                "<button type='button' class='t-button'>" +
                    actionText +
                "</button>"
                )
            }
        },

        _clearFileAction: function(fileElement) {
            fileElement
                .find(".t-upload-action").remove();
        },

        _onFileAction: function(e) {
            if (!this.wrapper.hasClass("t-state-disabled")) {
                var button = $(e.target).closest(".t-upload-action"),
                    icon = button.find(".t-icon"),
                    fileEntry = button.closest(".t-file"),
                    eventArgs = { files: fileEntry.data("fileNames") };

                if (icon.hasClass("t-delete")) {
                    if (!$t.trigger(this.wrapper, "remove", eventArgs)) {
                        fileEntry.trigger("t:remove", eventArgs.data);
                    }
                } else if (icon.hasClass("t-cancel")) {
                    $t.trigger(this.wrapper, "cancel", eventArgs);
                    fileEntry.trigger("t:cancel");
                    this._checkAllComplete();
                } else if (icon.hasClass("t-retry")) {
                    fileEntry.trigger("t:retry");                    
                }
            }

            return false;
        },

        _onUploadSelected: function() {
            this.wrapper.trigger("t:saveSelected");
            return false;
        },

        _onFileProgress: function(e, percentComplete) {
            var progressBar = $(".t-progress-status", e.target);
            if (progressBar.length == 0) {
                progressBar =
                    $("<span class='t-progress'><span class='t-progress-status' style='width: 0;'></span></span>")
                        .appendTo($(".t-filename", e.target))
                        .find(".t-progress-status");
            }

            progressBar.width(percentComplete + "%");
        },

        _onUploadSuccess: function(e, response, xhr) {
            var fileEntry = getFileEntry(e);

            this._setFileState(fileEntry, "uploaded");

            $t.trigger(this.wrapper, "success", {
                files: fileEntry.data("fileNames"),
                response: response,
                operation: "upload",
                XMLHttpRequest: xhr
            });

            if (this._supportsRemove()) {
                this._setFileAction(fileEntry, "remove");
            } else {
                this._clearFileAction(fileEntry);
            }

            this._checkAllComplete();
        },

        _onUploadError: function(e, xhr) {
            var fileEntry = getFileEntry(e);

            this._setFileState(fileEntry, "failed");
            this._setFileAction(fileEntry, "retry");

            var prevented = $t.trigger(this.wrapper, "error", {
                operation: "upload",
                files: fileEntry.data("fileNames"),
                XMLHttpRequest: xhr
            });

            logToConsole("Server response: " + xhr.responseText);

            if (!prevented) {
                this._alert("Error! Upload failed. Unexpected server response - see console.");
            }

            this._checkAllComplete();
        },

        _showUploadButton: function() {
            var uploadButton = $(".t-upload-selected", this.wrapper);
            if (uploadButton.length == 0) {
                uploadButton =
                    this._renderAction("", this.localization["uploadSelectedFiles"])
                    .addClass("t-upload-selected");
            }

            this.wrapper.append(uploadButton);
        },

        _hideUploadButton: function() {
            $(".t-upload-selected", this.wrapper).remove();
        },

        _onParentFormSubmit: function() {
            var upload = this,
                element = upload.element;
            element.trigger("t:abort");

            if (!element.value) {
                var input = $(element);
                
                // Prevent submitting an empty input
                input.attr("disabled", "disabled");

                window.setTimeout(function() {
                    // Restore the input so the Upload remains functional
                    // in case the user cancels the form submit
                    input.removeAttr("disabled");
                }, 0);
            }
        },

        _onParentFormReset: function() {
            $(".t-upload-files", this.wrapper).remove();
        },

        _getSupportsFormData: function() {
            return typeof(FormData) != "undefined";
        },

        _getSupportsMultiple: function() {
            return !$.browser.opera;
        },

        _getSupportsDrop: function() {
            var userAgent = this._getUserAgent().toLowerCase(),
                isChrome = /chrome/.test(userAgent),
                isSafari = !isChrome && /safari/.test(userAgent),
                isWindowsSafari = isSafari && /windows/.test(userAgent);

            return !isWindowsSafari && this._getSupportsFormData() && (this.async.saveUrl != undefined);
        },

        _getUserAgent: function() {
            return navigator.userAgent;
        },

        _setupDropZone: function() {
            $(".t-upload-button", this.wrapper)
                .wrap("<div class='t-dropzone'></div>");

            var dropZone = $(".t-dropzone", this.wrapper)
                .append($("<em>" + this.localization["dropFilesHere"] + "</em>"))
                .bind({
                    "dragenter": stopEvent,
                    "dragover": function(e) { e.preventDefault(); },
                    "drop" : $.proxy(this._onDrop, this)
                });

            bindDragEventWrappers(dropZone,
                function() { dropZone.addClass("t-dropzone-hovered"); },
                function() { dropZone.removeClass("t-dropzone-hovered"); });

            bindDragEventWrappers($(document),
                function() { dropZone.addClass("t-dropzone-active"); },
                function() { dropZone.removeClass("t-dropzone-active"); });
        },

        _supportsRemove: function() {
            return this.async.removeUrl != undefined;
        },

        _submitRemove: function(fileNames, data, onSuccess, onError) {
            var params = $.extend(data, getAntiForgeryTokens());
            params["fileNames"] = fileNames;

            $.ajax({
                  type: "POST",
                  dataType: "json",
                  url: this.async.removeUrl,
                  traditional: true,
                  data: params,
                  success: onSuccess,
                  error: onError
            });
        },

        _alert: function(message) {
            alert(message);
        },

        _wrapInput: function(input) {
            input.wrap("<div class='t-widget t-upload'><div class='t-button t-upload-button'></div></div>");
            input.closest(".t-button")
                .append("<span>" + this.localization.select + "</span>");

            return input.closest(".t-upload");
        },

        _checkAllComplete: function() {
            if ($(".t-file .t-icon.t-loading", this.wrapper).length == 0) {
                $t.trigger(this.wrapper, "complete");
            }
        }
    };

    $.fn.tUpload = function(options) {
        return $t.create(this, {
            name: "tUpload",
            init: function(element, options) {
                return new $t.upload(element, options);
            },
            options: options
        });
    };

    $.fn.tUpload.defaults = {
        enabled: true,
        multiple: true,
        showFileList: true,
        async: { }, // The async section defaults are always serialized.
        localization: {
            "select": "Select...",
            "cancel": "Cancel",
            "retry": "Retry",
            "remove": "Remove",
            "uploadSelectedFiles": "Upload files",
            "dropFilesHere": "drop files here to upload",
            "statusUploading": "uploading",
            "statusUploaded": "uploaded",
            "statusFailed": "failed" }
    };

    // Synchronous upload module
    var syncUploadModule = function(upload) {
        this.name = "syncUploadModule";
        this.element = upload.wrapper;
        this.upload = upload;
        this.element
            .bind("t:select", $.proxy(this.onSelect, this))
            .bind("t:remove", $.proxy(this.onRemove, this))
            .closest("form")
                .attr("enctype", "multipart/form-data")
                .attr("encoding", "multipart/form-data");
    };

    syncUploadModule.prototype = {
        onSelect: function(e) {
            var upload = this.upload;
            var sourceInput = $(e.target);
            upload._addInput(sourceInput.clone().val(""));
            var file = upload._enqueueFile(getFileName(sourceInput), {
                "relatedInput" : sourceInput, "fileNames": getInputFiles(sourceInput)
            });
            upload._setFileAction(file, "remove");
        },

        onRemove: function(e) {
            var fileEntry = getFileEntry(e);
            fileEntry.data("relatedInput").remove();

            this.upload._removeFileEntry(fileEntry);
        }
    };

    // Iframe upload module
    var iframeUploadModule = function(upload) {
        this.name = "iframeUploadModule";
        this.element = upload.wrapper;
        this.upload = upload;
        this.iframes = [];
        this.element
            .bind("t:select", $.proxy(this.onSelect, this))
            .bind("t:cancel", $.proxy(this.onCancel, this))
            .bind("t:retry", $.proxy(this.onRetry, this))
            .bind("t:remove", $.proxy(this.onRemove, this))
            .bind("t:saveSelected", $.proxy(this.onSaveSelected, this))
            .bind("t:abort", $.proxy(this.onAbort, this));
    };

    $t.upload._frameId = 0;

    iframeUploadModule.prototype = {
        onSelect: function(e) {
            var upload = this.upload,
                sourceInput = $(e.target);

            var fileEntry = this.prepareUpload(sourceInput);

            if (upload.async.autoUpload) {
                this.performUpload(fileEntry);
            } else {
                if (upload._supportsRemove()) {
                    this.upload._setFileAction(fileEntry, "remove");
                }

                upload._showUploadButton();
            }
        },

        prepareUpload: function(sourceInput) {
            var upload = this.upload;
            var activeInput = $(upload.element);
            var name = upload.async.saveField || sourceInput.attr("name");
            upload._addInput(sourceInput.clone().val(""));

            sourceInput.attr("name", name);

            var iframe = this.createFrame(upload.name + "_" + $t.upload._frameId++);
            this.registerFrame(iframe);

            var form = this.createForm(upload.async.saveUrl, iframe.attr("name"))
                .append(activeInput);

            var fileEntry = upload._enqueueFile(
                getFileName(sourceInput),
                { "frame": iframe, "relatedInput": activeInput, "fileNames": getInputFiles(sourceInput) });

            iframe
                .data({ "form": form, "file": fileEntry });

            return fileEntry;
        },

        performUpload: function(fileEntry) {
            var e = { files: fileEntry.data("fileNames") },
                iframe = fileEntry.data("frame"),
                upload = this.upload;

            if (!$t.trigger(upload.wrapper, "upload", e)) {
                upload._hideUploadButton();

                iframe.appendTo(document.body);

                var form = iframe.data("form")
                    .appendTo(document.body);

                e.data = $.extend({ }, e.data, getAntiForgeryTokens());
                for (var key in e.data) {
                    var dataInput = form.find("input[name='" + key + "']");
                    if (dataInput.length == 0) {
                        dataInput = $("<input>", { type: "hidden", name: key })
                            .prependTo(form);
                    }
                    dataInput.val(e.data[key]);
                }

                upload._setFileAction(fileEntry, "cancel");
                upload._setFileState(fileEntry, "uploading");

                iframe
                    .one("load", $.proxy(this.onIframeLoad, this));

                form[0].submit();
            } else {
                upload._removeFileEntry(iframe.data("file"));
                this.cleanupFrame(iframe);
                this.unregisterFrame(iframe);
            }
        },

        onSaveSelected: function(e) {
            var module = this;

            $(".t-file", this.element).each(function() {
                var fileEntry = $(this),
                    started = isFileUploadStarted(fileEntry);

                if (!started) {
                    module.performUpload(fileEntry);
                }
            });
        },

        onIframeLoad: function(e) {
            var iframe = $(e.target);

            try {
                var responseText = iframe.contents().text();
            } catch (e) {
                responseText = "Error trying to get server response: " + e;
            }

            this.processResponse(iframe, responseText);
        },

        processResponse: function(iframe, responseText) {
            var fileEntry = iframe.data("file"),
                module = this,
                fakeXHR = {
                    responseText: responseText
                };

            tryParseJSON(responseText,
                function(jsonResult) {
                    $.extend(fakeXHR, { statusText: "OK", status: "200" });
                    fileEntry.trigger("t:upload-success", [ jsonResult, fakeXHR ]);
                    module.cleanupFrame(iframe);
                    module.unregisterFrame(iframe);
                },
                function() {
                    $.extend(fakeXHR, { statusText: "error", status: "500" });
                    fileEntry.trigger("t:upload-error", [ fakeXHR ]);
                }
            );
        },

        onCancel: function(e) {
            var iframe = $(e.target).data("frame");

            this.stopFrameSubmit(iframe);
            this.cleanupFrame(iframe);
            this.unregisterFrame(iframe);
            this.upload._removeFileEntry(iframe.data("file"));
        },

        onRetry: function(e) {
            var fileEntry = getFileEntry(e);
            this.performUpload(fileEntry); 
        },

        onRemove: function(e, data) {
            var fileEntry = getFileEntry(e);

            var iframe = fileEntry.data("frame");
            if (iframe)
            {
                this.unregisterFrame(iframe);
                this.upload._removeFileEntry(fileEntry);
                this.cleanupFrame(iframe);
            } else {
                removeUploadedFile(fileEntry, this.upload, data);
            }
        },

        onAbort: function() {
            var element = this.element,
                module = this;

            $.each(this.iframes, function() {
                $("input", this.data("form")).appendTo(element);
                module.stopFrameSubmit(this[0]);
                this.data("form").remove();
                this.remove();
            });

            this.iframes = [];
        },

        createFrame: function(id) {
            return $(
                "<iframe" +
                " name='" + id + "'" +
                " id='" + id + "'" +
                " style='display:none;' />"
            );
        },

        createForm: function(action, target) {
            return $(
                "<form enctype='multipart/form-data' method='POST'" +
                " action='" + action + "'" +
                " target='" + target + "'" +
                "/>");
        },

        stopFrameSubmit: function(frame) {
            if (typeof(frame.stop) != "undefined") {
                frame.stop();
            } else if (frame.document) {
                frame.document.execCommand("Stop");
                frame.contentWindow.location.href = frame.contentWindow.location.href;
            }
        },

        registerFrame: function(frame) {
            this.iframes.push(frame);
        },

        unregisterFrame: function(frame) {
            this.iframes = $.grep(this.iframes, function(value) {
                return value.attr("name") != frame.attr("name");
            });
        },

        cleanupFrame: function(frame) {
            var form = frame.data("form");

            frame.data("file").data("frame", null);

            setTimeout(function () {
                form.remove();
                frame.remove();
            }, 1);
        }
    };

    // FormData upload module
    var formDataUploadModule = function(upload) {
        this.name = "formDataUploadModule";
        this.element = upload.wrapper;
        this.upload = upload;
        this.element
            .bind("t:select", $.proxy(this.onSelect, this))
            .bind("t:cancel", $.proxy(this.onCancel, this))
            .bind("t:remove", $.proxy(this.onRemove, this))
            .bind("t:retry", $.proxy(this.onRetry, this))
            .bind("t:saveSelected", $.proxy(this.onSaveSelected, this))
            .bind("t:abort", $.proxy(this.onAbort, this));
    };

    formDataUploadModule.prototype = {
        onSelect: function(e, rawFiles) {
            var upload = this.upload,
                module = this,
                sourceElement = $(e.target),
                files = rawFiles ? getAllFileInfo(rawFiles) : this.getInputFiles(sourceElement),
                fileEntries = this.prepareUpload(sourceElement, files);

            $.each(fileEntries, function() {
                if (upload.async.autoUpload) {
                    module.performUpload(this);
                } else {
                    if (upload._supportsRemove()) {
                        upload._setFileAction(this, "remove");
                    }
                    upload._showUploadButton();
                }
            });
        },

        prepareUpload: function(sourceElement, files) {
            var fileEntries = this.enqueueFiles(files);

            if (sourceElement.is("input")) {
                $.each(fileEntries, function() {
                    $(this).data("relatedInput", sourceElement);
                });
                sourceElement.data("relatedFileEntries", fileEntries);
                this.upload._addInput(sourceElement.clone().val(""));                
            }

            return fileEntries;
        },

        enqueueFiles: function(arrFileInfo) {
            var upload = this.upload
                fileEntries = [];

            for (var i = 0; i < arrFileInfo.length; i++) {
                var currentFile = arrFileInfo[i],
                    name = currentFile.name;

                var fileEntry = upload._enqueueFile(name, { "fileNames": [ currentFile ] });
                fileEntry.data("formData", this.createFormData(arrFileInfo[i]));

                fileEntries.push(fileEntry);
            }

            return fileEntries;
        },

        getInputFiles: function(sourceInput) {
            return getInputFiles(sourceInput);
        },

        performUpload: function(fileEntry) {
            var upload = this.upload,
                formData = fileEntry.data("formData"),
                e = { files: fileEntry.data("fileNames") };

            if (!$t.trigger(this.element, "upload", e)) {
                upload._setFileAction(fileEntry, "cancel");
                upload._hideUploadButton();

                if (!fileEntry.data("dataAppended")) {
                    e.data = $.extend({ }, e.data, getAntiForgeryTokens());
                    for (var key in e.data) {
                        formData.append(key, e.data[key]);
                    }

                    fileEntry.data("dataAppended", true);
                }

                upload._setFileState(fileEntry, "uploading");

                this.postFormData(this.upload.async.saveUrl, formData, fileEntry);
            } else {
                this.removeFileEntry(fileEntry);
            }
        },

        onSaveSelected: function(e) {
            var module = this;

            $(".t-file", this.element).each(function() {
                var fileEntry = $(this),
                    started = isFileUploadStarted(fileEntry);

                if (!started) {
                    module.performUpload(fileEntry);
                }
            });
        },

        onCancel: function(e) {
            var fileEntry = getFileEntry(e);
            this.stopUploadRequest(fileEntry);
            this.removeFileEntry(fileEntry);
        },

        onRetry: function(e) {
            var fileEntry = getFileEntry(e);
            this.performUpload(fileEntry); 
        },

        onRemove: function(e, data) {
            var fileEntry = getFileEntry(e);

            if (fileEntry.children(".t-icon").is(".t-success")) {
                removeUploadedFile(fileEntry, this.upload, data);
            } else {
                this.removeFileEntry(fileEntry);
            }
        },

        postFormData: function(url, data, fileEntry) {
            var xhr = new XMLHttpRequest(),
                module = this;

            fileEntry.data("request", xhr);

            xhr.addEventListener("load", function(e) {
                module.onRequestSuccess.call(module, e, fileEntry);
            }, false);

            xhr.addEventListener("error", function(e) {
                module.onRequestError.call(module, e, fileEntry);
            }, false);

            xhr.upload.addEventListener("progress", function(e) {
                module.onRequestProgress.call(module, e, fileEntry);
            }, false);

            xhr.open("POST", url);
            xhr.send(data);
        },

        createFormData: function(fileInfo) {
            var formData = new FormData(),
                upload = this.upload;

            formData.append(upload.async.saveField || upload.name, fileInfo.rawFile);

            return formData;
        },

        onRequestSuccess: function(e, fileEntry) {
            var xhr = e.target,
                module = this;
            tryParseJSON(xhr.responseText,
                function(jsonResult) {
                    fileEntry.trigger("t:upload-success", [ jsonResult, xhr ]);
                    fileEntry.trigger("t:progress", [ 100 ]);
                    module.cleanupFileEntry(fileEntry);
                },
                function() {
                    fileEntry.trigger("t:upload-error", [ xhr ]);
                }
            );
        },

        onRequestError: function(e, fileEntry) {
            var xhr = e.target;
            fileEntry.trigger("t:upload-error", [ xhr ]);
        },

        cleanupFileEntry: function(fileEntry) {
            var relatedInput = fileEntry.data("relatedInput"),
                uploadComplete = true;

            if (relatedInput) {
                $.each(relatedInput.data("relatedFileEntries"), function() {
                    // Exclude removed file entries and self
                    if (this.parent().length > 0 && this[0] != fileEntry[0]) {
                        uploadComplete = uploadComplete && this.children(".t-icon").is(".t-success");
                    }
                });

                if (uploadComplete) {
                    relatedInput.remove();
                }
            }

            fileEntry.data("formData", null);
        },

        removeFileEntry: function(fileEntry) {
            this.cleanupFileEntry(fileEntry);
            this.upload._removeFileEntry(fileEntry);
        },

        onRequestProgress: function(e, fileEntry) {
            var percentComplete = Math.round(e.loaded * 100 / e.total);
            fileEntry.trigger("t:progress", [ percentComplete ]);
        },

        stopUploadRequest: function(fileEntry) {
            fileEntry.data("request").abort();
        }
    };

    // Helper functions
    function getFileName(input) {
        return $.map(getInputFiles(input), function (file) {
            return file.name;
        }).join(", ");
    }

    function getInputFiles($input) {
        var input = $input[0];
        if (input.files) {
            return getAllFileInfo(input.files);
        } else {
            return [{
                name: stripPath(input.value),
                extension: getFileExtension(input.value),
                size: null
            }];
        }
    }

    function getAllFileInfo(rawFiles) {
        return $.map(rawFiles, function (file) {
            return getFileInfo(file);
        });
    }

    function getFileInfo(rawFile) {
        // Older Firefox versions (before 3.6) use fileName and fileSize
        var fileName = rawFile.name || rawFile.fileName;
        return {
            name: fileName,
            extension: getFileExtension(fileName),
            size: rawFile.size || rawFile.fileSize,
            rawFile: rawFile
        };
    }

    function getFileExtension(fileName) {
        var matches = fileName.match(rFileExtension);
        return matches ? matches[0] : "";
    }

    function stripPath(name) {
        var slashIndex = name.lastIndexOf("\\");
        return (slashIndex != -1) ? name.substr(slashIndex + 1) : name;
    }

    function removeUploadedFile(fileEntry, upload, data) {
        if (!upload._supportsRemove()) {
            return;
        }

        var files = fileEntry.data("fileNames");
        var fileNames = $.map(files, function(file) { return file.name });

        upload._submitRemove(fileNames, data,
            function onSuccess(data, textStatus, xhr) {
                upload._removeFileEntry(fileEntry);

                $t.trigger(upload.wrapper, "success", {
                    operation: "remove",
                    files: files,
                    response: data,
                    XMLHttpRequest: xhr });
            },

            function onError(xhr, textStatus, textStatus) {
                var prevented = $t.trigger(upload.wrapper, "error", {
                    operation: "remove",
                    files: files,
                    XMLHttpRequest: xhr });

                logToConsole("Server response: " + xhr.responseText);

                if (!prevented) {
                    upload._alert("Error! Remove operation failed. Unexpected response - see console.");
                }
            }
        );
    }

    function tryParseJSON(input, onSuccess, onError) {
        try {
            var json = $.parseJSON(input);
        } catch (e) {
            onError();
            return;
        }

        onSuccess(json);
    }

    function stopEvent(e) {
        e.stopPropagation(); e.preventDefault();
    }

    function bindDragEventWrappers(element, onDragEnter, onDragLeave) {
        var hideInterval, lastDrag;

        element
            .bind("dragenter", function(e) {
                onDragEnter();
                lastDrag = new Date();

                if (!hideInterval) {
                    hideInterval = setInterval(function() {
                        var sinceLastDrag = new Date() - lastDrag;
                        if (sinceLastDrag > 100) {
                            onDragLeave();

                            clearInterval(hideInterval);
                            hideInterval = null;
                        }
                    }, 100);
                }
            })
            .bind("dragover", function(e) {
                lastDrag = new Date();
            });        
    }

    function isFileUploadStarted(fileEntry) {
        return fileEntry.children(".t-icon").is(".t-loading, .t-success, .t-fail");
    }

    function logToConsole(message) {
        if (typeof(console) != "undefined" && console.log) {
            console.log(message);
        }
    }

    function getFileEntry(e) {
        return $(e.target).closest(".t-file");
    }

    function getAntiForgeryTokens() {
        var tokens = { };
        $("input[name^='__RequestVerificationToken']").each(function() {
            tokens[this.name] = this.value;
        });

        return tokens;
    }

})(jQuery);(function($) {

var $t = $.telerik;

$t.scripts.push("telerik.editor.js");

function makeMap(items) {
    var obj = {};
        
    for (var i = 0; i < items.length; i++)
        obj[items[i]] = true;
        
    return obj;
}

var empty = makeMap('area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed'.split(',')),
    blockElements = 'div,p,h1,h2,h3,h4,h5,h6,address,applet,blockquote,button,center,dd,dir,dl,dt,fieldset,form,frameset,hr,iframe,isindex,li,map,menu,noframes,noscript,object,ol,pre,script,table,tbody,td,tfoot,th,thead,tr,ul'.split(','),
    block = makeMap(blockElements),
    inlineElements = 'span,em,a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,script,select,small,strike,strong,sub,sup,textarea,tt,u,var'.split(','),
    inline = makeMap(inlineElements),
    fillAttrs = makeMap('checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected'.split(','));


var normalize = function (node) {
    if (node.nodeType == 1)
        node.normalize();
};

if ($.browser.msie && parseInt($.browser.version) >= 8) {
    normalize = function(parent) {
        if (parent.nodeType == 1 && parent.firstChild) {
            var prev = parent.firstChild,
                node = prev;
            
            while (node = node.nextSibling) {
                if (node.nodeType == 3 && prev.nodeType == 3) {
                    node.nodeValue = prev.nodeValue + node.nodeValue;
                    dom.remove(prev);
                }
                prev = node;
            }
        }
    }
}

function findNodeIndex(node) {
    var i = 0;
    while (node = node.previousSibling) i++;
    return i;
}

function isDataNode(node) {
    return node && node.nodeValue !== null && node.data !== null;
}

function isAncestorOf(parent, node) {
    try {
        return !isDataNode(parent) && ($.contains(parent, isDataNode(node) ? node.parentNode : node) || node.parentNode == parent);
    } catch (e) {
        return false;
    }
}

function isAncestorOrSelf(root, node) {
    return isAncestorOf(root, node) || root == node;
}

function findClosestAncestor(root, node) {
    if (isAncestorOf(root, node))
        while (node && node.parentNode != root)
            node = node.parentNode;

    return node;
}

function getNodeLength(node) {
    return isDataNode(node) ? node.length : node.childNodes.length;
}

function splitDataNode(node, offset) {
    var newNode = node.cloneNode(false);
    node.deleteData(offset, node.length);
    newNode.deleteData(0, offset);
    dom.insertAfter(newNode, node);
}

function attrEquals(node, attributes) {
    for (var key in attributes) {
        var value = node[key];

        if (key == 'float')
            value = node[$.support.cssFloat ? "cssFloat" : "styleFloat"];

        if (typeof value == 'object') {
            if (!attrEquals(value, attributes[key]))
                return false;
        } else if (value != attributes[key])
            return false;
    }

    return true;
}

var whitespace = /^\s+$/;
var rgb = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i;
var cssAttributes = ('color,padding-left,padding-right,padding-top,padding-bottom,\
background-color,background-attachment,background-image,background-position,background-repeat,\
border-top-style,border-top-width,border-top-color,\
border-bottom-style,border-bottom-width,border-bottom-color,\
border-left-style,border-left-width,border-left-color,\
border-right-style,border-right-width,border-right-color,\
font-family,font-size,font-style,font-variant,font-weight,line-height'
).split(',');

var dom = {
    blockParentOrBody: function(node) {
        return dom.parentOfType(node, blockElements) || node.ownerDocument.body;
    },
    normalize: normalize,
    toHex: function (color) {
        var matches = rgb.exec(color);

        if (!matches) return color;

        return '#' + $.map(matches.slice(1), function (x) {
            return x = parseInt(x).toString(16), x.length > 1 ? x : '0' + x;
        }).join('');
    },

    encode: function (value) {
        return value.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\u00a0/g, '&nbsp;');
    },

    name: function (node) {
        return node.nodeName.toLowerCase();
    },
        
    significantChildNodes: function(node) {
        return $.grep(node.childNodes, function(child) {
            return child.nodeType != 3 || !dom.isWhitespace(child);
        });
    },
        
    lastTextNode: function(node) {
        if (node.nodeType == 3)
            return node;
            
        var result = null;
            
        for (var child = node.lastChild; child; child = child.previousSibling)
            if (result = dom.lastTextNode(child))
                return result;
                
        return result;
    },

    is: function (node, nodeName) {
        return dom.name(node) == nodeName;
    },
        
    isMarker: function(node) {
        return node.className == 't-marker';
    },
        
    isWhitespace: function(node) {
        return whitespace.test(node.nodeValue);
    },
        
    isBlock: function(node) {
        return block[dom.name(node)];
    },

    isEmpty: function(node) {
        return empty[dom.name(node)];
    },
        
    isInline: function(node) {
        return inline[dom.name(node)];
    },
        
    scrollTo: function (node) {
        node.ownerDocument.body.scrollTop = $(isDataNode(node) ? node.parentNode : node).offset().top;
    },

    insertAt: function (parent, newElement, position) {
        parent.insertBefore(newElement, parent.childNodes[position] || null);
    },

    insertBefore: function (newElement, referenceElement) {
        if (referenceElement.parentNode)
            return referenceElement.parentNode.insertBefore(newElement, referenceElement);
        else
            return referenceElement;
    },

    insertAfter: function (newElement, referenceElement) {
        return referenceElement.parentNode.insertBefore(newElement, referenceElement.nextSibling);
    },

    remove: function (node) {
        node.parentNode.removeChild(node);
    },

    trim: function (parent) {
        for (var i = parent.childNodes.length - 1; i >= 0; i--) {
            var node = parent.childNodes[i];
            if (isDataNode(node)) {
                if (node.nodeValue.replace(/\ufeff/g, '').length == 0)
                    dom.remove(node);
                if (dom.isWhitespace(node))
                    dom.insertBefore(node, parent);
            } else if (node.className != 't-marker') {
                dom.trim(node);
                if (node.childNodes.length == 0 && !dom.isEmpty(node))
                    dom.remove(node);
            }
        }

        return parent;
    },

    parentOfType: function (node, tags) {
        do {
            node = node.parentNode;
        } while (node && !(dom.ofType(node, tags)));

        return node;
    },

    ofType: function (node, tags) {
        return $.inArray(dom.name(node), tags) >= 0;
    },

    changeTag: function (referenceElement, tagName) {
        var newElement = dom.create(referenceElement.ownerDocument, tagName);
        var attributes = referenceElement.attributes;

        for (var i = 0; i < attributes.length; i++) {
            var attribute = attributes[i];
            if (attribute.specified) {
                // IE < 8 cannot set class or style via setAttribute
                var name = attribute.nodeName;
                var value = attribute.nodeValue;
                if (name == 'class')
                    newElement.className = value;
                else if (name == 'style')
                    newElement.style.cssText = referenceElement.style.cssText;
                else
                    newElement.setAttribute(name, value);
            }
        }

        while (referenceElement.firstChild)
            newElement.appendChild(referenceElement.firstChild);

        dom.insertBefore(newElement, referenceElement);
        dom.remove(referenceElement);
        return newElement;
    },

    wrap: function (node, wrapper) {
        dom.insertBefore(wrapper, node);
        wrapper.appendChild(node);
        return wrapper;
    },

    unwrap: function (node) {
        var parent = node.parentNode;
        while (node.firstChild)
            parent.insertBefore(node.firstChild, node);

        parent.removeChild(node);
    },

    create: function (document, tagName, attributes) {
        return dom.attr(document.createElement(tagName), attributes);
    },

    attr: function (element, attributes) {
        attributes = $.extend({}, attributes);

        if (attributes && 'style' in attributes) {
            dom.style(element, attributes.style);
            delete attributes.style;
        }
        return $.extend(element, attributes);
    },

    style: function (node, value) {
        $(node).css(value || {});
    },

    unstyle: function (node, value) {
        for (var key in value) {
            if (key == 'float')
                key = $.support.cssFloat ? "cssFloat" : "styleFloat";

            node.style[key] = '';
        }

        if (node.style.cssText == '')
            node.removeAttribute('style');
    },

    inlineStyle: function(document, name, attributes) {
        var span = dom.create(document, name, attributes);
        
        document.body.appendChild(span);
                
        var $span = $(span);
                
        var style = $.map(cssAttributes, function(value) {
            if ($.browser.msie && value == 'line-height' && $span.css(value) == "1px")
                return 'line-height:1.5';
            else
                return value + ':' + $span.css(value);
        }).join(';');
                
        $span.remove();
        
        return style;
    },

    removeClass: function(node, classNames) {
        var className = " " + node.className + " ",
            classes = classNames.split(" ");

        for (var i = 0; i < classes.length; i++) {
            className = className.replace(" " + classes[i] + " ", " ");
        }

        className = $.trim(className);

        if (className.length) {
            node.className = className;
        } else {
            node.removeAttribute("class");
        }
    },

    commonAncestor: function () {
        var count = arguments.length;

        if (!count)
            return null;

        if (count == 1)
            return arguments[0];

        var paths = [];
        var minPathLength = Infinity;

        for (var i = 0; i < count; i++) {
            var ancestors = [];
            var node = arguments[i];
            while (node) {
                ancestors.push(node);
                node = node.parentNode;
            }
            paths.push(ancestors.reverse());
            minPathLength = Math.min(minPathLength, ancestors.length);
        }

        if (count == 1)
            return paths[0][0];

        var output = null;
        for (i = 0; i < minPathLength; i++) {
            var first = paths[0][i];

            for (var j = 1; j < count; j++)
                if (first != paths[j][i])
                    return output;

            output = first;
        }
        return output;
    }
}
var fontSizeMappings = 'xx-small,x-small,small,medium,large,x-large,xx-large'.split(','),
    quoteRe = /"/g,
    brRe = /<br[^>]*>/i,
    emptyPRe = /<p><\/p>/i;

function domToXhtml(root) {
    var result = [];
    var tagMap = {
        'telerik:script': { start: function (node) { result.push('<script'); attr(node); result.push('>'); }, end: function () { result.push('</script>') } },
        b: { start: function () { result.push('<strong>') }, end: function () { result.push('</strong>') } },
        i: { start: function () { result.push('<em>') }, end: function () { result.push('</em>') } },
        u: { start: function () { result.push('<span style="text-decoration:underline;">') }, end: function () { result.push('</span>') } },
        font: {
            start: function (node) {
                result.push('<span style="');

                var color = node.getAttribute('color');
                var size = fontSizeMappings[node.getAttribute('size')];
                var face = node.getAttribute('face');

                if (color) {
                    result.push('color:')
                    result.push(dom.toHex(color));
                    result.push(';');
                }

                if (face) {
                    result.push('font-face:');
                    result.push(face);
                    result.push(';');
                }

                if (size) {
                    result.push('font-size:');
                    result.push(size);
                    result.push(';');
                }

                result.push('">');
            },
            end: function (node) {
                result.push('</span>');
            }
        }
    };

    function attr(node) {
        var specifiedAttributes = [],
            attributes = node.attributes,
            trim = $.trim;

        if (dom.is(node, 'img')) {
            var width = node.style.width,
                height = node.style.height,
                $node = $(node);

            if (width) {
                $node.attr('width', parseInt(width));
                dom.unstyle(node, { width: undefined });
            }

            if (height) {
                $node.attr('height', parseInt(height));
                dom.unstyle(node, { height: undefined });
            }
        }

        for (var i = 0, l = attributes.length; i < l; i++) {
            var attribute = attributes[i];
            var name = attribute.nodeName;
            // In IE < 8 the 'value' attribute is not returned as 'specified'. The same goes for type="text"
            if (attribute.specified || (name == 'value' && node.value != '') || (name == 'type' && attribute.nodeValue == 'text'))
                if (name.indexOf('_moz') < 0 && name != 'complete')
                    specifiedAttributes.push(attribute);
        }

        if (!specifiedAttributes.length)
            return;

        specifiedAttributes.sort(function (a, b) {
            return a.nodeName > b.nodeName ? 1 : a.nodeName < b.nodeName ? -1 : 0;
        });

        for (var i = 0, l = specifiedAttributes.length; i < l; i++) {
            var attribute = specifiedAttributes[i];
            var attributeName = attribute.nodeName;
            var attributeValue = attribute.nodeValue;

            result.push(' ');
            result.push(attributeName);
            result.push('="');
            if (attributeName == 'style') {
                // In IE < 8 the style attribute does not return proper nodeValue
                var css = trim(attributeValue || node.style.cssText).split(';');

                for (var cssIndex = 0, len = css.length; cssIndex < len; cssIndex++) {
                    var pair = css[cssIndex];
                    if (pair.length) {
                        var propertyAndValue = pair.split(':');
                        var property = trim(propertyAndValue[0].toLowerCase()),
                            value = trim(propertyAndValue[1]);

                        if (property == "font-size-adjust" || property == "font-stretch") {
                            continue;
                        }

                        if (property.indexOf('color') >= 0)
                            value = dom.toHex(value);
                        
                        if (property.indexOf('font') >= 0) {
                            value = value.replace(quoteRe, "'");
                        }

                        result.push(property);
                        result.push(':');
                        result.push(value);
                        result.push(';');
                    }
                };
            } else if (attributeName == 'src' || attributeName == 'href') {
                result.push(node.getAttribute(attributeName, 2));
            } else {
                result.push(fillAttrs[attributeName] ? attributeName : attributeValue);
            }

            result.push('"');
        }
    }

    function children(node, skip) {
        for (var childNode = node.firstChild; childNode; childNode = childNode.nextSibling)
            child(childNode, skip);
    }

    function child(node, skip) {
        var nodeType = node.nodeType;
        if (nodeType == 1) {
            var tagName = dom.name(node);

            if (tagName == "" || (node.attributes['_moz_dirty'] && dom.is(node, 'br')))
                return;

            var mapper = tagMap[tagName];

            if (mapper) {
                mapper.start(node);
                children(node);
                mapper.end(node);
                return;
            }

            result.push('<');
            result.push(tagName);

            attr(node);

            if (empty[tagName]) {
                result.push(' />');
            } else {
                result.push('>');
                children(node, skip || dom.is(node, 'pre'));
                result.push('</');
                result.push(tagName);
                result.push('>');
            }
        } else if (nodeType == 3) {
            var value = node.nodeValue;
                
            if (!skip && $.support.leadingWhitespace) {
                var parent = node.parentNode;
                var previous = node.previousSibling;

                if (!previous) {
                     previous = (dom.isInline(parent) ? parent : node).previousSibling;
                }

                if (!previous || previous.innerHTML == '' || dom.isBlock(previous))
                    value = value.replace(/^[\r\n\v\f\t ]+/, '');
                    
                value = value.replace(/ +/, ' ');
            }
                
            result.push(dom.encode(value));
            
        } else if (nodeType == 4) {
            result.push('<![CDATA[');
            result.push(node.data);
            result.push(']]>');
        } else if (nodeType == 8) {
            if (node.data.indexOf('[CDATA[') < 0) {
                result.push('<!--');
                result.push(node.data);
                result.push('-->');
            } else {
                result.push('<!');
                result.push(node.data);
                result.push('>');
            }
        }
    }

    children(root);

    result = result.join('');

    // if serialized dom contains only whitespace elements, consider it empty (required field validation)
    if (result.replace(brRe, "").replace(emptyPRe, "") == "") {
        return "";
    }

    return result;
}
var START_TO_START = 0,
    START_TO_END = 1,
    END_TO_END = 2,
    END_TO_START = 3;


function documentFromRange(range) {
    var startContainer = range.startContainer;
    return startContainer.nodeType == 9 ? startContainer : startContainer.ownerDocument;
}

function selectionFromWindow(window) {
    if ($.browser.msie && $.browser.version < 9) {
        return new W3CSelection(window.document);
    }
    
    return window.getSelection(); 
}

function selectionFromRange(range) {
    var document = documentFromRange(range);
    return selectionFromDocument(document);
}

function selectionFromDocument(document) {
    return selectionFromWindow(windowFromDocument(document));
}

function windowFromDocument(document) {
    return document.defaultView || document.parentWindow;
}

function split(range, node, trim) {
    function partition(start) {
        var partitionRange = range.cloneRange();
        partitionRange.collapse(start);
        partitionRange[start ? 'setStartBefore' : 'setEndAfter'](node);
        var contents = partitionRange.extractContents();
        if (trim)
            contents = dom.trim(contents);
        dom[start ? 'insertBefore' : 'insertAfter'](contents, node);
    }
    partition(true);
    partition(false);
}

function selectRange(range) {
    var image = RangeUtils.image(range);
    if (image) {
        range.setStartAfter(image);
        range.setEndAfter(image);
    }
    var selection = selectionFromRange(range);
    selection.removeAllRanges();
    selection.addRange(range);
}

function W3CRange(doc) {
    $.extend(this, {
        ownerDocument: doc, /* not part of the spec; used when cloning ranges, traversing the dom and creating fragments */
        startContainer: doc,
        endContainer: doc,
        commonAncestorContainer: doc,
        startOffset: 0,
        endOffset: 0,
        collapsed: true
    });
};

W3CRange.prototype = {
    // Positioning Methods

    setStart: function (node, offset) {
        this.startContainer = node;
        this.startOffset = offset;
        updateRangeProperties(this);
        fixIvalidRange(this, true);
    },

    setEnd: function (node, offset) {
        this.endContainer = node;
        this.endOffset = offset;
        updateRangeProperties(this);
        fixIvalidRange(this, false);
    },

    setStartBefore: function (node) {
        this.setStart(node.parentNode, findNodeIndex(node));
    },

    setStartAfter: function (node) {
        this.setStart(node.parentNode, findNodeIndex(node) + 1);
    },

    setEndBefore: function (node) {
        this.setEnd(node.parentNode, findNodeIndex(node));
    },

    setEndAfter: function (node) {
        this.setEnd(node.parentNode, findNodeIndex(node) + 1);
    },

    selectNode: function (node) {
        this.setStartBefore(node);
        this.setEndAfter(node);
    },

    selectNodeContents: function (node) {
        this.setStart(node, 0);
        this.setEnd(node, node[node.nodeType === 1 ? 'childNodes' : 'nodeValue'].length);
    },

    collapse: function (toStart) {
        if (toStart)
            this.setEnd(this.startContainer, this.startOffset);
        else
            this.setStart(this.endContainer, this.endOffset);
    },

    // Editing Methods

    deleteContents: function () {
        var range = this.cloneRange();

        if (this.startContainer != this.commonAncestorContainer)
            this.setStartAfter(findClosestAncestor(this.commonAncestorContainer, this.startContainer));

        this.collapse(true);

        (function deleteSubtree(iterator) {
            while (iterator.next())
                iterator.hasPartialSubtree() ? deleteSubtree(iterator.getSubtreeIterator())
                                            : iterator.remove();
        })(new RangeIterator(range));
    },
    
    cloneContents: function () {
        // clone subtree
        var document = documentFromRange(this);
        return (function cloneSubtree(iterator) {
                for (var node, frag = document.createDocumentFragment(); node = iterator.next(); ) {
                        node = node.cloneNode(!iterator.hasPartialSubtree());
                        if (iterator.hasPartialSubtree())
                                node.appendChild(cloneSubtree(iterator.getSubtreeIterator()));
                        frag.appendChild(node);
                }
                return frag;
        })(new RangeIterator(this));
    },

    extractContents: function () {
        var range = this.cloneRange();

        if (this.startContainer != this.commonAncestorContainer)
            this.setStartAfter(findClosestAncestor(this.commonAncestorContainer, this.startContainer));

        this.collapse(true);

        var self = this;

        var document = documentFromRange(this);

        return (function extractSubtree(iterator) {
            for (var node, frag = document.createDocumentFragment(); node = iterator.next(); ) {
                iterator.hasPartialSubtree() ? node = node.cloneNode(false) : iterator.remove(self.originalRange);

                if (iterator.hasPartialSubtree())
                    node.appendChild(extractSubtree(iterator.getSubtreeIterator()));

                frag.appendChild(node);
            }

            return frag;
        })(new RangeIterator(range));
    },

    insertNode: function (node) {
        if (isDataNode(this.startContainer)) {
            if (this.startOffset != this.startContainer.nodeValue.length)
                splitDataNode(this.startContainer, this.startOffset);

            dom.insertAfter(node, this.startContainer);
        } else {
            dom.insertAt(this.startContainer, node, this.startOffset);
        }

        this.setStart(this.startContainer, this.startOffset);
    },

    cloneRange: function () {
        // fast copy
        return $.extend(new W3CRange(this.ownerDocument), {
            startContainer: this.startContainer,
            endContainer: this.endContainer,
            commonAncestorContainer: this.commonAncestorContainer,
            startOffset: this.startOffset,
            endOffset: this.endOffset,
            collapsed: this.collapsed,

            originalRange: this /* not part of the spec; used to update the original range when calling extractContents() on clones */
        });
    },

    // used for debug purposes
    toString: function () {
        var startNodeName = this.startContainer.nodeName,
            endNodeName = this.endContainer.nodeName;

        return [startNodeName == "#text" ? this.startContainer.nodeValue : startNodeName, '(', this.startOffset, ') : ',
                endNodeName == "#text" ? this.endContainer.nodeValue : endNodeName, '(', this.endOffset, ')'].join('');
    }
}
/* can be used in Range.compareBoundaryPoints if we need it one day */
function compareBoundaries(start, end, startOffset, endOffset) {
    if (start == end)
        return endOffset - startOffset;

    // end is child of start
    var container = end;
    while (container && container.parentNode != start)
        container = container.parentNode;

    if (container)
        return findNodeIndex(container) - startOffset;

    // start is child of end
    container = start;
    while (container && container.parentNode != end)
        container = container.parentNode;

    if (container)
        return endOffset - findNodeIndex(container) - 1;

    // deep traversal
    var root = dom.commonAncestor(start, end);
    var startAncestor = start;

    while (startAncestor && startAncestor.parentNode != root)
        startAncestor = startAncestor.parentNode;

    if (!startAncestor)
        startAncestor = root;

    var endAncestor = end;
    while (endAncestor && endAncestor.parentNode != root)
        endAncestor = endAncestor.parentNode;

    if (!endAncestor)
        endAncestor = root;

    if (startAncestor == endAncestor)
        return 0;

    return findNodeIndex(endAncestor) - findNodeIndex(startAncestor);
}

function fixIvalidRange(range, toStart) {
    function isInvalidRange(range) {
        try {
            return compareBoundaries(range.startContainer, range.endContainer, range.startOffset, range.endOffset) < 0;
        } catch (ex) {
            // range was initially invalid (e.g. when cloned from invalid range) - it must be fixed
            return true;
        }
    }

    if (isInvalidRange(range)) {
        if (toStart) {
            range.commonAncestorContainer = range.endContainer = range.startContainer;
            range.endOffset = range.startOffset;
        } else {
            range.commonAncestorContainer = range.startContainer = range.endContainer;
            range.startOffset = range.endOffset;
        }

        range.collapsed = true;
    }
}

function updateRangeProperties(range) {
    range.collapsed = range.startContainer == range.endContainer && range.startOffset == range.endOffset;

    var node = range.startContainer;
    while (node && node != range.endContainer && !isAncestorOf(node, range.endContainer))
        node = node.parentNode;

    range.commonAncestorContainer = node;
}

function createRange(document) {
    if ($.browser.msie && $.browser.version < 9) {
        return new W3CRange(document);
    }
    
    return document.createRange();
}


function RangeIterator(range) {
    $.extend(this, {
        range: range,
        _current: null,
        _next: null,
        _end: null
    });

    if (range.collapsed)
        return;

    var root = range.commonAncestorContainer;

    this._next = range.startContainer == root && !isDataNode(range.startContainer) ?
    range.startContainer.childNodes[range.startOffset] :
    findClosestAncestor(root, range.startContainer);

    this._end = range.endContainer == root && !isDataNode(range.endContainer) ?
    range.endContainer.childNodes[range.endOffset] :
    findClosestAncestor(root, range.endContainer).nextSibling;
}

RangeIterator.prototype = {
    hasNext: function () {
        return !!this._next;
    },

    next: function () {
        var current = this._current = this._next;
        this._next = this._current && this._current.nextSibling != this._end ?
        this._current.nextSibling : null;

        if (isDataNode(this._current)) {
            if (this.range.endContainer == this._current)
                (current = current.cloneNode(true)).deleteData(this.range.endOffset, current.length - this.range.endOffset);

            if (this.range.startContainer == this._current)
                (current = current.cloneNode(true)).deleteData(0, this.range.startOffset);
        }

        return current;
    },

    traverse: function (callback) {
        function next() {
            this._current = this._next;
            this._next = this._current && this._current.nextSibling != this._end ? this._current.nextSibling : null;
            return this._current;
        }

        var current;

        while (current = next.call(this)) {
            if (this.hasPartialSubtree())
                this.getSubtreeIterator().traverse(callback);
            else
                callback(current)
        }

        return current;
    },

    remove: function (originalRange) {
        var inStartContainer = this.range.startContainer == this._current;
        var inEndContainer = this.range.endContainer == this._current;

        if (isDataNode(this._current) && (inStartContainer || inEndContainer)) {
            var start = inStartContainer ? this.range.startOffset : 0;
            var end = inEndContainer ? this.range.endOffset : this._current.length;
            var delta = end - start;

            if (originalRange && (inStartContainer || inEndContainer)) {
                if (this._current == originalRange.startContainer && start <= originalRange.startOffset)
                    originalRange.startOffset -= delta;

                if (this._current == originalRange.endContainer && end <= originalRange.endOffset)
                    originalRange.endOffset -= delta;
            }

            this._current.deleteData(start, delta);
        } else {
            var parent = this._current.parentNode;

            if (originalRange && (this.range.startContainer == parent || this.range.endContainer == parent)) {
                var nodeIndex = findNodeIndex(this._current);

                if (parent == originalRange.startContainer && nodeIndex <= originalRange.startOffset)
                    originalRange.startOffset -= 1;

                if (parent == originalRange.endContainer && nodeIndex < originalRange.endOffset)
                    originalRange.endOffset -= 1;
            }

            dom.remove(this._current);
        }
    },

    hasPartialSubtree: function () {
        return !isDataNode(this._current) &&
        (isAncestorOrSelf(this._current, this.range.startContainer) ||
            isAncestorOrSelf(this._current, this.range.endContainer));
    },

    getSubtreeIterator: function () {
        var subRange = this.range.cloneRange();
        subRange.selectNodeContents(this._current);

        if (isAncestorOrSelf(this._current, this.range.startContainer))
            subRange.setStart(this.range.startContainer, this.range.startOffset);
        if (isAncestorOrSelf(this._current, this.range.endContainer))
            subRange.setEnd(this.range.endContainer, this.range.endOffset);

        return new RangeIterator(subRange);
    }
};

function W3CSelection(doc) {
    this.ownerDocument = doc;
    this.rangeCount = 1;
};

W3CSelection.prototype = {
    addRange: function (range) {
        var textRange = this.ownerDocument.body.createTextRange();

        // end container should be adopted first in order to prevent selection with negative length
        adoptContainer(textRange, range, false);
        adoptContainer(textRange, range, true);

        textRange.select();
    },

    removeAllRanges: function () {
        this.ownerDocument.selection.empty();
    },

    getRangeAt: function () {
        var textRange, range = new W3CRange(this.ownerDocument), selection = this.ownerDocument.selection, element;
        
        try {
            textRange = selection.createRange();
            element = textRange.item ? textRange.item(0) : textRange.parentElement();
			if (element.ownerDocument != this.ownerDocument) {
				return range;
            }
        } catch (ex) {
            return range;
        }

        if (selection.type == 'Control') {
            range.selectNode(textRange.item(0));
        } else {
            adoptEndPoint(textRange, range, true);
            adoptEndPoint(textRange, range, false);

            if (range.startContainer.nodeType == 9)
                range.setStart(range.endContainer, range.startOffset);
                
            if (range.endContainer.nodeType == 9)
                range.setEnd(range.startContainer, range.endOffset);

            if (textRange.compareEndPoints('StartToEnd', textRange) == 0)
                range.collapse(false);
                
            var startContainer = range.startContainer,
                endContainer = range.endContainer,
                body = this.ownerDocument.body;
                
            if (!range.collapsed && range.startOffset == 0 && range.endOffset == getNodeLength(range.endContainer) // check for full body selection
            && !(startContainer == endContainer && isDataNode(startContainer) && startContainer.parentNode == body)) { // but not when single textnode is selected
                var movedStart = false,
                    movedEnd = false;

                while (findNodeIndex(startContainer) == 0 && startContainer == startContainer.parentNode.firstChild && startContainer != body) {
                    startContainer = startContainer.parentNode;
                    movedStart = true;
                }

                while (findNodeIndex(endContainer) == getNodeLength(endContainer.parentNode) - 1 && endContainer == endContainer.parentNode.lastChild && endContainer != body) {
                    endContainer = endContainer.parentNode;
                    movedEnd = true;
                }

                if (startContainer == body && endContainer == body && movedStart && movedEnd) {
                    range.setStart(startContainer, 0);
                    range.setEnd(endContainer, getNodeLength(body));
                }
            }
        }
        return range;
    }
}

function adoptContainer(textRange, range, start) {
    // find anchor node and offset
    var container = range[start ? 'startContainer' : 'endContainer'];
    var offset = range[start ? 'startOffset' : 'endOffset'], textOffset = 0;
    var anchorNode = isDataNode(container) ? container : container.childNodes[offset] || null;
    var anchorParent = isDataNode(container) ? container.parentNode : container;
    // visible data nodes need a text offset
    if (container.nodeType == 3 || container.nodeType == 4)
        textOffset = offset;

    // create a cursor element node to position range (since we can't select text nodes)
    var cursorNode = anchorParent.insertBefore(dom.create(range.ownerDocument, 'a'), anchorNode);

    var cursor = range.ownerDocument.body.createTextRange();
    cursor.moveToElementText(cursorNode);
    dom.remove(cursorNode);
    cursor[start ? 'moveStart' : 'moveEnd']('character', textOffset);
    cursor.collapse(false);
    textRange.setEndPoint(start ? 'StartToStart' : 'EndToStart', cursor);
}

function adoptEndPoint(textRange, range, start) {
    var cursorNode = dom.create(range.ownerDocument, 'a'), cursor = textRange.duplicate();
    cursor.collapse(start);
    var parent = cursor.parentElement();
    do {
        parent.insertBefore(cursorNode, cursorNode.previousSibling);
        cursor.moveToElementText(cursorNode);
    } while (cursor.compareEndPoints(start ? 'StartToStart' : 'StartToEnd', textRange) > 0 && cursorNode.previousSibling);

    cursor.setEndPoint(start ? 'EndToStart' : 'EndToEnd', textRange);

    var target = cursorNode.nextSibling;

    if (!target) {
        // at end of text node
        target = cursorNode.previousSibling;

        if (target && isDataNode(target)) { // in case of collapsed range in empty tag
            range.setEnd(target, target.nodeValue.length);
            dom.remove(cursorNode);
        } else {
            range.selectNodeContents(parent);
            dom.remove(cursorNode);
            range.endOffset -= 1; // cursorNode was in parent
        }

        return;
    }

    dom.remove(cursorNode);

    if (isDataNode(target))
        range[start ? 'setStart' : 'setEnd'](target, cursor.text.length);
    else
        range[start ? 'setStartBefore' : 'setEndBefore'](target);
}

 function RangeEnumerator(range) {
    this.enumerate = function () {
        var nodes = [];

        function visit(node) {
            if (dom.is(node, 'img') || (node.nodeType == 3 && !dom.isWhitespace(node))) {
                nodes.push(node);
            } else {
                node = node.firstChild;
                while (node) {
                    visit(node);
                    node = node.nextSibling;
                }
            }
        }

        new RangeIterator(range).traverse(visit);

        return nodes;
    }
}

function textNodes(range) {
    return new RangeEnumerator(range).enumerate();
}

function blockParents(nodes) {
    var blocks = [];

    for (var i = 0, len = nodes.length; i < len; i++) {
        var block = dom.parentOfType(nodes[i], blockElements);
        if (block && $.inArray(block, blocks) < 0)
            blocks.push(block);
    }

    return blocks;
}

function getMarkers(range) {
    var markers = [];

    new RangeIterator(range).traverse(function (node) {
        if (node.className == 't-marker')
            markers.push(node);
    });

    return markers;
}

function RestorePoint(range) {
    var rootNode = documentFromRange(range);

    this.body = rootNode.body;

    this.html = this.body.innerHTML;
        
    function index(node) {
        var result = 0, lastType = node.nodeType;

        while (node = node.previousSibling) {
            var nodeType = node.nodeType;
                
            if (nodeType != 3 || lastType != nodeType)
                result ++;
                
            lastType = nodeType;
        }
            
        return result;
    }

    function offset(node, value) {
        if (node.nodeType == 3) {
            while ((node = node.previousSibling) && node.nodeType == 3)
                value += node.nodeValue.length;
        }
        return value;
    }

    function nodeToPath(node) {
        var path = [];
            
        while (node != rootNode) {
            path.push(index(node));
            node = node.parentNode;
        }

        return path;
    }

    function toRangePoint(range, start, path, denormalizedOffset) {
        var node = rootNode, length = path.length, offset = denormalizedOffset;

        while (length--)
            node = node.childNodes[path[length]];

        while (node.nodeType == 3 && node.nodeValue.length < offset) {
            offset -= node.nodeValue.length;
            node = node.nextSibling;
        }

        range[start ? 'setStart' : 'setEnd'](node, offset);
    }

    this.startContainer = nodeToPath(range.startContainer);
    this.endContainer = nodeToPath(range.endContainer);
    this.startOffset = offset(range.startContainer, range.startOffset);
    this.endOffset = offset(range.endContainer, range.endOffset);

    this.toRange = function () {
        var result = range.cloneRange();

        toRangePoint(result, true, this.startContainer, this.startOffset);
        toRangePoint(result, false, this.endContainer, this.endOffset);

        return result;
    }
}

function Marker() {
    var caret;

    this.addCaret = function (range) {
        caret = dom.create(documentFromRange(range), 'span', { className: 't-marker' });
        range.insertNode(caret);
        range.selectNode(caret);
        return caret;
    }

    this.removeCaret = function (range) {
        var previous = caret.previousSibling;
        var startOffset = 0;
            
        if (previous)
            startOffset = isDataNode(previous) ? previous.nodeValue.length : findNodeIndex(previous);

        var container = caret.parentNode;
        var containerIndex = previous ? findNodeIndex(previous) : 0;

        dom.remove(caret);
        normalize(container);

        var node = container.childNodes[containerIndex];
            
        if (isDataNode(node))
            range.setStart(node, startOffset);
        else if (node) {
            var textNode = dom.lastTextNode(node);
            if (textNode)
                range.setStart(textNode, textNode.nodeValue.length);
            else
                range[previous ? 'setStartAfter' : 'setStartBefore'](node);
        } else {
            if (!$.browser.msie && container.innerHTML == '')
                container.innerHTML = '<br _moz_dirty="" />';
                
            range.selectNodeContents(container);
        }
        range.collapse(true);
    }

    this.add = function (range, expand) {
        if (expand && range.collapsed) {
            this.addCaret(range);
            range = RangeUtils.expand(range);
        }

        var rangeBoundary = range.cloneRange();

        rangeBoundary.collapse(false);
        this.end = dom.create(documentFromRange(range), 'span', { className: 't-marker' });
        rangeBoundary.insertNode(this.end);

        rangeBoundary = range.cloneRange();
        rangeBoundary.collapse(true);
        this.start = this.end.cloneNode(true);
        rangeBoundary.insertNode(this.start);

        range.setStartBefore(this.start);
        range.setEndAfter(this.end);

        normalize(range.commonAncestorContainer);

        return range;
    }

    this.remove = function (range) {
        var start = this.start, end = this.end;

        normalize(range.commonAncestorContainer);

        while (!start.nextSibling && start.parentNode) start = start.parentNode;
        while (!end.previousSibling && end.parentNode) end = end.parentNode;

        var shouldNormalizeStart = (start.previousSibling && start.previousSibling.nodeType == 3)
                                && (start.nextSibling && start.nextSibling.nodeType == 3);

        var shouldNormalizeEnd = (end.previousSibling && end.previousSibling.nodeType == 3)
                                && (end.nextSibling && end.nextSibling.nodeType == 3);

        start = start.nextSibling;
        end = end.previousSibling;

        var collapsed = false;
        var collapsedToStart = false;
        // collapsed range
        if (start == this.end) {
            collapsedToStart = !!this.start.previousSibling;
            start = end = this.start.previousSibling || this.end.nextSibling;
            collapsed = true;
        }

        dom.remove(this.start);
        dom.remove(this.end);

        if (start == null || end == null) {
            range.selectNodeContents(range.commonAncestorContainer);
            range.collapse(true);
            return;
        }

        var startOffset = collapsed ? isDataNode(start) ? start.nodeValue.length : start.childNodes.length : 0;
        var endOffset = isDataNode(end) ? end.nodeValue.length : end.childNodes.length;

        if (start.nodeType == 3)
            while (start.previousSibling && start.previousSibling.nodeType == 3) {
                start = start.previousSibling;
                startOffset += start.nodeValue.length;
            }

        if (end.nodeType == 3)
            while (end.previousSibling && end.previousSibling.nodeType == 3) {
                end = end.previousSibling;
                endOffset += end.nodeValue.length;
            }
        var startIndex = findNodeIndex(start), startParent = start.parentNode;
        var endIndex = findNodeIndex(end), endParent = end.parentNode;

        for (var startPointer = start; startPointer.previousSibling; startPointer = startPointer.previousSibling)
            if (startPointer.nodeType == 3 && startPointer.previousSibling.nodeType == 3) startIndex--;

        for (var endPointer = end; endPointer.previousSibling; endPointer = endPointer.previousSibling)
            if (endPointer.nodeType == 3 && endPointer.previousSibling.nodeType == 3) endIndex--;

        normalize(startParent);

        if (start.nodeType == 3)
            start = startParent.childNodes[startIndex];

        normalize(endParent);
        if (end.nodeType == 3)
            end = endParent.childNodes[endIndex];

        if (collapsed) {
            if (start.nodeType == 3)
                range.setStart(start, startOffset);
            else
                range[collapsedToStart ? 'setStartAfter' : 'setStartBefore'](start);
                
            range.collapse(true);

        } else {
            if (start.nodeType == 3)
                range.setStart(start, startOffset);
            else
                range.setStartBefore(start);

            if (end.nodeType == 3)
                range.setEnd(end, endOffset);
            else
                range.setEndAfter(end);
        }
        if (caret)
            this.removeCaret(range);
    }
}

var boundary = /[\u0009-\u000d]|\u0020|\u00a0|\ufeff|\.|,|;|:|!|\(|\)|\?/;

var RangeUtils = {
    nodes: function(range) {
        var nodes = textNodes(range);
        if (!nodes.length) {
            range.selectNodeContents(range.commonAncestorContainer);
            nodes = textNodes(range);
            if (!nodes.length)
                nodes = dom.significantChildNodes(range.commonAncestorContainer);
        }
        return nodes;
    },

    image: function (range) {
        var nodes = [];

        new RangeIterator(range).traverse(function (node) {
            if (dom.is(node, 'img'))
                nodes.push(node);
        });

        if (nodes.length == 1)
            return nodes[0];
    },

    expand: function (range) {
        var result = range.cloneRange();

        var startContainer = result.startContainer.childNodes[result.startOffset == 0 ? 0 : result.startOffset - 1];
        var endContainer = result.endContainer.childNodes[result.endOffset];

        if (!isDataNode(startContainer) || !isDataNode(endContainer))
            return result;

        var beforeCaret = startContainer.nodeValue;
        var afterCaret = endContainer.nodeValue;

        if (beforeCaret == '' || afterCaret == '')
            return result;

        var startOffset = beforeCaret.split('').reverse().join('').search(boundary);
        var endOffset = afterCaret.search(boundary);

        if (startOffset == 0 || endOffset == 0)
            return result;

        endOffset = endOffset == -1 ? afterCaret.length : endOffset;
        startOffset = startOffset == -1 ? 0 : beforeCaret.length - startOffset;

        result.setStart(startContainer, startOffset);
        result.setEnd(endContainer, endOffset);

        return result;
    },

    isExpandable: function (range) {
        var node = range.startContainer;
        var document = documentFromRange(range);

        if (node == document || node == document.body)
            return false;

        var result = range.cloneRange();

        var value = node.nodeValue;
        if (!value)
            return false;

        var beforeCaret = value.substring(0, result.startOffset);
        var afterCaret = value.substring(result.startOffset);

        var startOffset = 0, endOffset = 0;

        if (beforeCaret != '')
            startOffset = beforeCaret.split('').reverse().join('').search(boundary);

        if (afterCaret != '')
            endOffset = afterCaret.search(boundary);

        return startOffset != 0 && endOffset != 0;
    }
};function Command(options) {
    var restorePoint = new RestorePoint(options.range);
    var marker = new Marker();

    this.formatter = options.formatter;

    this.getRange = function () {
        return restorePoint.toRange();
    }

    this.lockRange = function (expand) {
        return marker.add(this.getRange(), expand);
    }

    this.releaseRange = function (range) {
        marker.remove(range);
        selectRange(range);
    }

    this.undo = function () {
        restorePoint.body.innerHTML = restorePoint.html;
        selectRange(restorePoint.toRange());
    }

    this.redo = function () {
        this.exec();
    }

    this.exec = function () {
        var range = this.lockRange(true);
        this.formatter.editor = this.editor;
        this.formatter.toggle(range);
        this.releaseRange(range);
    }
}

function GenericCommand(startRestorePoint, endRestorePoint) {
    var body = startRestorePoint.body;

    this.redo = function () {
        body.innerHTML = endRestorePoint.html;
        selectRange(endRestorePoint.toRange());
    }

    this.undo = function () {
        body.innerHTML = startRestorePoint.html;
        selectRange(startRestorePoint.toRange());
    }
}

function InsertHtmlCommand(options) {
    Command.call(this, options);

    this.managesUndoRedo = true;

    this.exec = function () {
        var editor = this.editor;
        var range = editor.getRange();
        var startRestorePoint = new RestorePoint(range);

        editor.clipboard.paste(options.value || '');
        editor.undoRedoStack.push(new GenericCommand(startRestorePoint, new RestorePoint(editor.getRange())));

        editor.focus();
    }
}

function InsertHtmlTool() {
    Tool.call(this);

    var editor,
        title = "";

    this.command = function (commandArguments) {
        return new InsertHtmlCommand(commandArguments);
    }
    
    this.update = function($ui, nodes) {
        var list = $ui.data('tSelectBox');
        list.close();
        list.value(title);
    }

    this.init = function($ui, initOptions) {
        editor = initOptions.editor;
        title = editor.localization.insertHtml;
        
        $ui.tSelectBox({
            data: editor.insertHtml || [],
            title: title,
            onItemCreate: function (e) {
                e.html = '<span unselectable="on">' + e.dataItem.Text + '</span>';
            },
            onChange: function (e) {
                Tool.exec(editor, 'insertHtml', e.value);
            },
            highlightFirst: false
        }).find('.t-input').html(editor.localization.insertHtml);
    }
}

function UndoRedoStack() {
    var stack = [], currentCommandIndex = -1;

    this.push = function (command) {
        stack = stack.slice(0, currentCommandIndex + 1);
        currentCommandIndex = stack.push(command) - 1;
    }

    this.undo = function () {
        if (this.canUndo())
            stack[currentCommandIndex--].undo();
    }

    this.redo = function () {
        if (this.canRedo())
            stack[++currentCommandIndex].redo();
    }

    this.canUndo = function () {
        return currentCommandIndex >= 0;
    }

    this.canRedo = function () {
        return currentCommandIndex != stack.length - 1;
    }
}

function TypingHandler(editor) {
    this.keydown = function (e) {
        var keyboard = editor.keyboard;
        var isTypingKey = keyboard.isTypingKey(e);

        if (isTypingKey && !keyboard.typingInProgress()) {
            var range = editor.getRange();
            this.startRestorePoint = new RestorePoint(range);

            keyboard.startTyping($.proxy(function () {
                editor.selectionRestorePoint = this.endRestorePoint = new RestorePoint(editor.getRange());
                editor.undoRedoStack.push(new GenericCommand(this.startRestorePoint, this.endRestorePoint));
            }, this));

            return true;
        }

        return false;
    }

    this.keyup = function (e) {
        var keyboard = editor.keyboard;

        if (keyboard.typingInProgress()) {
            keyboard.endTyping();
            return true;
        }

        return false;
    }
}

function SystemHandler(editor) {
    var systemCommandIsInProgress = false;

    this.createUndoCommand = function () {
        this.endRestorePoint = new RestorePoint(editor.getRange());
        editor.undoRedoStack.push(new GenericCommand(this.startRestorePoint, this.endRestorePoint));
        this.startRestorePoint = this.endRestorePoint;
    }

    this.changed = function () {
        if (this.startRestorePoint)
            return this.startRestorePoint.html != editor.body.innerHTML;

        return false;
    }

    this.keydown = function (e) {
        var keyboard = editor.keyboard;

        if (keyboard.isModifierKey(e)) {

            if (keyboard.typingInProgress())
                keyboard.endTyping(true);

            this.startRestorePoint = new RestorePoint(editor.getRange());
            return true;
        }

        if (keyboard.isSystem(e)) {
            systemCommandIsInProgress = true;

            if (this.changed()) {
                systemCommandIsInProgress = false;
                this.createUndoCommand();
            }

            return true;
        }

        return false;
    }

    this.keyup = function (e) {
        if (systemCommandIsInProgress && this.changed()) {
            systemCommandIsInProgress = false;
            this.createUndoCommand(e);
            return true;
        }

        return false;
    }
}

function Keyboard(handlers) {
    var typingInProgress = false;
    var timeout;
    var onEndTyping;

    function isCharacter(keyCode) {
        return (keyCode >= 48 && keyCode <= 90) || (keyCode >= 96 && keyCode <= 111) ||
            (keyCode >= 186 && keyCode <= 192) || (keyCode >= 219 && keyCode <= 222);
    }

    this.toolFromShortcut = function (tools, e) {
        var key = String.fromCharCode(e.keyCode);

        for (var toolName in tools) {
            var tool = tools[toolName];

            if ((tool.key == key || tool.key == e.keyCode) && !!tool.ctrl == e.ctrlKey && !!tool.alt == e.altKey && !!tool.shift == e.shiftKey)
                return toolName;
        }
    }

    this.isTypingKey = function (e) {
        var keyCode = e.keyCode;
        return (isCharacter(keyCode) && !e.ctrlKey && !e.altKey) || keyCode == 32 || keyCode == 13
        || keyCode == 8 || (keyCode == 46 && !e.shiftKey && !e.ctrlKey && !e.altKey);
    }

    this.isModifierKey = function (e) {
        var keyCode = e.keyCode;
        return (keyCode == 17 && !e.shiftKey && !e.altKey)
                || (keyCode == 16 && !e.ctrlKey && !e.altKey)
                || (keyCode == 18 && !e.ctrlKey && !e.shiftKey);
    }

    this.isSystem = function (e) {
        return e.keyCode == 46 && e.ctrlKey && !e.altKey && !e.shiftKey;
    }

    this.startTyping = function (callback) {
        onEndTyping = callback;
        typingInProgress = true;
    }

    function stopTyping() {
        typingInProgress = false;
        if (onEndTyping)
            onEndTyping();
    }

    this.endTyping = function (force) {
        this.clearTimeout();
        if (force)
            stopTyping();
        else
            timeout = window.setTimeout(stopTyping, 1000);
    }

    this.typingInProgress = function () {
        return typingInProgress;
    }

    this.clearTimeout = function () {
        window.clearTimeout(timeout);
    }

    function notify(e, what) {
        for (var i = 0; i < handlers.length; i++)
            if (handlers[i][what](e))
                break;
    }

    this.keydown = function (e) {
        notify(e, 'keydown');
    }

    this.keyup = function (e) {
        notify(e, 'keyup');
    }
}

function Clipboard (editor) {
    var cleaners = [
        new MSWordFormatCleaner(),
        new DeprecatedTagsCleaner(),
        new SpanConsolidator()
    ];

    function htmlToFragment (html) {
        var container = dom.create(editor.document, 'div');
        container.innerHTML = html;
            
        var fragment = editor.document.createDocumentFragment();
            
        while (container.firstChild)
            fragment.appendChild(container.firstChild);
            
        return fragment;
    }

    function isBlock(html) {
        return /<(div|p|ul|ol|table|h[1-6])/i.test(html);
    }
        
    this.oncut = function(e) {
        var startRestorePoint = new RestorePoint(editor.getRange());
        setTimeout(function() {
            editor.undoRedoStack.push(new GenericCommand(startRestorePoint, new RestorePoint(editor.getRange())));
        });
    }

    this.onpaste = function(e) {
        var range = editor.getRange();
        var startRestorePoint = new RestorePoint(range);
            
        var clipboardNode = dom.create(editor.document, 'div', {className:'t-paste-container', innerHTML: '\ufeff'});

        editor.body.appendChild(clipboardNode);
            
        if (editor.body.createTextRange) {
            e.preventDefault();
            var r = editor.createRange();
            r.selectNodeContents(clipboardNode);
            editor.selectRange(r);
            var textRange = editor.body.createTextRange();
            textRange.moveToElementText(clipboardNode);
            $(editor.body).unbind('paste');
            textRange.execCommand('Paste');
            $(editor.body).bind('paste', arguments.callee);
        } else {
            var clipboardRange = editor.createRange();
            clipboardRange.selectNodeContents(clipboardNode);
            selectRange(clipboardRange);
        }
            
        setTimeout(function() {
            selectRange(range);
            dom.remove(clipboardNode);
                
            if (clipboardNode.lastChild && dom.is(clipboardNode.lastChild, 'br'))
                dom.remove(clipboardNode.lastChild);
                
            var args = { html: clipboardNode.innerHTML };
            $t.trigger(editor.element, "paste", args);
            editor.clipboard.paste(args.html, true);
            editor.undoRedoStack.push(new GenericCommand(startRestorePoint, new RestorePoint(editor.getRange())));
            selectionChanged(editor);
        });
    }

    function splittableParent(block, node) {
        if (block)
            return dom.parentOfType(node, ['p', 'ul', 'ol']) || node.parentNode;
            
        var parent = node.parentNode;
        var body = node.ownerDocument.body;
            
        if (dom.isInline(parent)) {
            while (parent.parentNode != body && !dom.isBlock(parent.parentNode))
                parent = parent.parentNode;
        }
            
        return parent;
    }

    this.paste = function (html, clean) {
        var i, l;

        for (i = 0, l = cleaners.length; i < l; i++)
            if (cleaners[i].applicable(html))
                html = cleaners[i].clean(html);
            
        if (clean) {
            // remove br elements which immediately precede block elements
            html = html.replace(/(<br>(\s|&nbsp;)*)+(<\/?(div|p|li|col|t))/ig, "$3");
            // remove empty inline elements
            html = html.replace(/<(a|span)[^>]*><\/\1>/ig, "");
        }

        // It is possible in IE to copy just <li> tags
        html = html.replace(/^<li/i, '<ul><li').replace(/li>$/g, 'li></ul>');

        var block = isBlock(html);

        var range = editor.getRange();
        range.deleteContents();

        if (range.startContainer == editor.document)
            range.selectNodeContents(editor.body);
            
        var marker = new Marker();
        var caret = marker.addCaret(range)
            
        var parent = splittableParent(block, caret);
        var unwrap = false;
            
        if (!/body|td/.test(dom.name(parent)) && (block || dom.isInline(parent))) {
            range.selectNode(caret);
            split(range, parent, true);
            unwrap = true;
        }
            
        var fragment = htmlToFragment(html);
        
        if (fragment.firstChild && fragment.firstChild.className === "t-paste-container") {
            var fragmentsHtml = [];
            for (i = 0, l = fragment.childNodes.length; i < l; i++) {
                fragmentsHtml.push(fragment.childNodes[i].innerHTML);
            }

            fragment = htmlToFragment(fragmentsHtml.join('<br />'));
        }

        range.insertNode(fragment);
                
        parent = splittableParent(block, caret);
        if (unwrap) {
            while (caret.parentNode != parent)
                dom.unwrap(caret.parentNode);
                
            dom.unwrap(caret.parentNode);
        }
            
        normalize(range.commonAncestorContainer);
        caret.style.display = 'inline';
        dom.scrollTo(caret);
        marker.removeCaret(range);
        selectRange(range);
    }
}

function DeprecatedTagsCleaner() {
    this.applicable = function(html) {
        return /<(b|i|u|)>/i.test(html);
    }

    this.clean = function(html) {
        return html.replace(/<(\/?)b>/gi, '<$1strong>')
                   .replace(/<(\/?)>/gi, '<$1em>')
                   .replace(/<u>/gi, '<span style="text-decoration: underline">')
                   .replace(/<\/u>/gi, '</span>');
    }
}

function SpanConsolidator() {
    this.applicable = function(html) {
        return /<span/i.test(html);
    };

    this.clean = function(html) {
        var placeholder = dom.create(document, 'div', {innerHTML: html}),
            spans = $("span", placeholder),
            currentSpan, parent;

        for (var i = spans.length - 1; i >= 0; i--) {
            currentSpan = spans[i];
            parent = currentSpan.parentNode;

            if (dom.is(parent, "span") && parent.childNodes.length == 1) {
                parent.style.cssText = $.trim(parent.style.cssText + currentSpan.style.cssText);
                while (currentSpan.firstChild) {
                    parent.appendChild(currentSpan.firstChild);
                }

                parent.removeChild(currentSpan);
            }
        }

        return placeholder.innerHTML;
    };
}

function MSWordFormatCleaner() {
    var replacements = [
        /<\?xml[^>]*>/gi, '',
        /<!--(.|\n)*?-->/g, '', /* comments */
        /&quot;/g, "'", /* encoded quotes (in attributes) */
        /(?:<br>&nbsp;[\s\r\n]+|<br>)*(<\/?(h[1-6]|hr|p|div|table|tbody|thead|tfoot|th|tr|td|li|ol|ul|caption|address|pre|form|blockquote|dl|dt|dd|dir|fieldset)[^>]*>)(?:<br>&nbsp;[\s\r\n]+|<br>)*/g, '$1',
        /<br><br>/g, '<BR><BR>', 
        /<br>(&nbsp;)+\s+/ig, ' ', 
        /<table([^>]*)>(\s|&nbsp;)+<t/gi, '<table$1><t',
        /<tr[^>]*>(\s|&nbsp;)*<\/tr>/gi, '',
        /<tbody[^>]*>(\s|&nbsp;)*<\/tbody>/gi, '',
        /<table[^>]*>(\s|&nbsp;)*<\/table>/gi, '',
        /<BR><BR>/g, '<br>',
        /^\s*(&nbsp;)+/gi, '',
        /(&nbsp;|<br[^>]*>)+\s*$/gi, '',
        /mso-[^;"]*;?/ig, '', /* office-related CSS attributes */
        /<(\/?)b(\s[^>]*)?>/ig, '<$1strong$2>',
        /<(\/?)i(\s[^>]*)?>/ig, '<$1em$2>',
        /<\/?(meta|link|style|o:|v:|x:)[^>]*>((?:.|\n)*?<\/(meta|link|style|o:|v:|x:)[^>]*>)?/ig, '', /* external references and namespaced tags */
        /style=(["|'])\s*\1/g, '' /* empty style attributes */
    ];
        
    this.applicable = function(html) {
        return /class="?Mso|style="[^"]*mso-/i.test(html);
    }
        
    function listType(html) {
        if (/^[\u2022\u00b7\u00a7\u00d8o]\u00a0+/.test(html))
            return 'ul';
            
        if (/^\s*\w+[\.\)]\u00a0{2,}/.test(html))
            return 'ol';
    }

    function lists(html) {
        var placeholder = dom.create(document, 'div', {innerHTML: html});
        var blockChildren = $(blockElements.join(','), placeholder);
            
        var lastMargin = -1, lastType, levels = {'ul':{}, 'ol':{}}, li = placeholder;
            
        for (var i = 0; i < blockChildren.length; i++) {
            var p = blockChildren[i];
            var html = p.innerHTML.replace(/<\/?\w+[^>]*>/g, '').replace(/&nbsp;/g, '\u00a0');      
            var type = listType(html);
                
            if (!type || dom.name(p) != 'p') { 
                if (p.innerHTML == '') {
                    dom.remove(p);
                } else {
                    levels = {'ul':{}, 'ol':{}};
                    li = placeholder;
                    lastMargin = -1;
                }
                continue;
            }
                
            var margin = parseFloat(p.style.marginLeft || 0);
            var list = levels[type][margin];

            if (margin > lastMargin || !list) {
                list = dom.create(document, type);
                    
                if (li == placeholder)
                    dom.insertBefore(list, p);
                else 
                    li.appendChild(list);
                    
                levels[type][margin] = list;
            }
                
            if (lastType != type) {
                for (var key in levels)
                    for (var child in levels[key])
                        if ($.contains(list, levels[key][child]))
                            delete levels[key][child];
            }

            dom.remove(p.firstChild);
            li = dom.create(document, 'li', {innerHTML:p.innerHTML});
            list.appendChild(li);
            dom.remove(p);
            lastMargin = margin;
            lastType = type;
        }
        return placeholder.innerHTML;
    }

    function stripEmptyAnchors(html) {
        return html.replace(/<a([^>]*)>\s*<\/a>/ig, function(a, attributes) {
            if (!attributes || attributes.indexOf("href") < 0) {
                return "";
            }

            return a;
        });
    }

    this.clean = function(html) {
        for (var i = 0, l = replacements.length; i < l; i+= 2)
            html = html.replace(replacements[i], replacements[i+1]);

        html = stripEmptyAnchors(html);
        html = lists(html);
        html = html.replace(/\s+class="?[^"\s>]*"?/ig, '');

        return html;
    }
};function InlineFormatFinder(format) {
    function numberOfSiblings(referenceNode) {
        var textNodesCount = 0, elementNodesCount = 0, markerCount = 0,
            parentNode = referenceNode.parentNode;

        for (var node = parentNode.firstChild; node; node = node.nextSibling) {
            if (node != referenceNode) {
                if (node.className == 't-marker') {
                    markerCount++;
                } else if (node.nodeType == 3) {
                    textNodesCount++;
                } else {
                    elementNodesCount++;
                }
            }
        }

        if (markerCount > 1 && parentNode.firstChild.className == 't-marker' && parentNode.lastChild.className == 't-marker') {
            // full node selection
            return 0;
        } else {
            return elementNodesCount + textNodesCount;
        }
    }

    this.findSuitable = function (sourceNode, skip) {
        if (!skip && numberOfSiblings(sourceNode) > 0)
            return null;

        return dom.parentOfType(sourceNode, format[0].tags);
    }

    this.findFormat = function (sourceNode) {
        for (var i = 0; i < format.length; i++) {
            var node = sourceNode;
            var tags = format[i].tags;
            var attributes = format[i].attr;

            if (node && dom.ofType(node, tags) && attrEquals(node, attributes))
                return node;

            while (node) {
                node = dom.parentOfType(node, tags);
                if (node && attrEquals(node, attributes))
                    return node;
            }
        }

        return null;
    }

    this.isFormatted = function (nodes) {
        for (var i = 0; i < nodes.length; i++)
            if (this.findFormat(nodes[i]))
                return true;

        return false;
    }
}

function InlineFormatter(format, values) {
    this.finder = new InlineFormatFinder(format);

    var attributes = $.extend({}, format[0].attr, values);

    var tag = format[0].tags[0];

    function wrap(node) {
        return dom.wrap(node, dom.create(node.ownerDocument, tag, attributes));
    }

    this.activate = function(range, nodes) {
        if (this.finder.isFormatted(nodes)) {
            this.split(range);
            this.remove(nodes);
        } else
            this.apply(nodes);
    }

    this.toggle = function (range) {
        var nodes = textNodes(range);

        if (nodes.length > 0)
            this.activate(range, nodes);
    }

    this.apply = function (nodes) {
        var formatNodes = [];
        for (var i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];

            var formatNode = this.finder.findSuitable(node);
            if (formatNode)
                dom.attr(formatNode, attributes);
            else
                formatNode = wrap(node);

            formatNodes.push(formatNode);
        }

        this.consolidate(formatNodes);
    }

    this.remove = function (nodes) {
        for (var i = 0, l = nodes.length; i < l; i++) {
            var formatNode = this.finder.findFormat(nodes[i]);
            if (formatNode) {
                if (attributes && attributes.style) {
                    dom.unstyle(formatNode, attributes.style);
                    if (!formatNode.style.cssText) {
                        dom.unwrap(formatNode);
                    }
                } else {
                    dom.unwrap(formatNode);
                }
            }
        }
    }

    this.split = function (range) {
        var nodes = textNodes(range);

        if (nodes.length > 0) {
            for (var i = 0, l = nodes.length; i < l; i++) {
                var formatNode = this.finder.findFormat(nodes[i]);
                if (formatNode)
                    split(range, formatNode, true);
            }
        }
    }

    this.consolidate = function (nodes) {
        while (nodes.length > 1) {
            var node = nodes.pop();
            var last = nodes[nodes.length - 1];

            if (node.previousSibling && node.previousSibling.className == 't-marker') {
                last.appendChild(node.previousSibling);
            }

            if (node.tagName == last.tagName && node.previousSibling == last && node.style.cssText == last.style.cssText) {
                while (node.firstChild)
                    last.appendChild(node.firstChild);
                dom.remove(node);
            }
        }
    }
}

function GreedyInlineFormatFinder(format, greedyProperty) {
    InlineFormatFinder.call(this, format);

    function getInlineCssValue(node) {
        var attributes = node.attributes,
            trim = $.trim;

        if (!attributes) return;

        for (var i = 0, l = attributes.length; i < l; i++) {
            var attribute = attributes[i],
                name = attribute.nodeName,
                attributeValue = attribute.nodeValue;

            if (attribute.specified && name == 'style') {
                
                var css = trim(attributeValue || node.style.cssText).split(';');

                for (var cssIndex = 0, len = css.length; cssIndex < len; cssIndex++) {
                    var pair = css[cssIndex];
                    if (pair.length) {
                        var propertyAndValue = pair.split(':');
                        var property = trim(propertyAndValue[0].toLowerCase()),
                            value = trim(propertyAndValue[1]);

                        if (property != greedyProperty)
                            continue;

                        return property.indexOf('color') >= 0 ? dom.toHex(value) : value;
                    }
                }
            }
        }

        return;
    }

    function getFormat (node) {
        var $node = $(isDataNode(node) ? node.parentNode : node);
        var parents = $node.parents().andSelf();

        for (var i = 0, len = parents.length; i < len; i++) {
            var value = greedyProperty == 'className' ? parents[i].className : getInlineCssValue(parents[i]);
            if (value)
                return value;
        }

        return 'inherit';
    }

    this.getFormat = function (nodes) {
        var result = getFormat(nodes[0]);

        for (var i = 1, len = nodes.length; i < len; i++)
            if (result != getFormat(nodes[i]))
                return '';

        return result;
    }

    this.isFormatted = function (nodes) {
        return this.getFormat(nodes) !== '';
    }
}

function GreedyInlineFormatter(format, values, greedyProperty) {
    InlineFormatter.call(this, format, values);

    this.finder = new GreedyInlineFormatFinder(format, greedyProperty)

    this.activate = function(range, nodes) {
        this.split(range);

        if (greedyProperty) {
            var camelCase = greedyProperty.replace(/-([a-z])/, function(all, letter){return letter.toUpperCase()});
            this[values.style[camelCase] == 'inherit' ? 'remove' : 'apply'](nodes);
        } else {
            this.apply(nodes);
        }
    }
}

function inlineFormatWillDelayExecution (range) {
    return range.collapsed && !RangeUtils.isExpandable(range);
}

function InlineFormatTool(options) {
    FormatTool.call(this, $.extend(options, {
        finder: new InlineFormatFinder(options.format),
        formatter: function () { return new InlineFormatter(options.format) }
    }));

    this.willDelayExecution = inlineFormatWillDelayExecution;
}

function FontTool(options){
    Tool.call(this, options);
    
    // IE has single selection hence we are using select box instead of combobox
    var type = $.browser.msie ? 'tSelectBox' : 'tComboBox',
        format = [{ tags: ['span'] }],
        finder = new GreedyInlineFormatFinder(format, options.cssAttr);

    this.command = function (commandArguments) {
        return new FormatCommand($.extend(commandArguments, {
            formatter: function () { 
                var style = {};
                style[options.domAttr] = commandArguments.value;

                return new GreedyInlineFormatter(format, { style: style }, options.cssAttr); 
            }
        }))        
    }

    this.willDelayExecution = inlineFormatWillDelayExecution;
    
    this.update = function($ui, nodes, pendingFormats) {
        var list = $ui.data(type);
        list.close();

        var pendingFormat = pendingFormats.getPending(this.name);

        var format = (pendingFormat && pendingFormat.params) ? pendingFormat.params.value : finder.getFormat(nodes)

        list.value(format);
    }

    this.init = function ($ui, initOptions) {
        var editor = initOptions.editor;

        $ui[type]({
            data: editor[options.name],
            onChange: function (e) {
                Tool.exec(editor, options.name, e.value);
            },
            onItemCreate: function (e) {
                e.html = '<span unselectable="on" style="display:block;">' + e.dataItem.Text + '</span>';
            },
            highlightFirst: false
        });

        $ui.data(type).value('inherit');
    }
};

function ColorTool (options) {
    Tool.call(this, options);

    var format = [{ tags: inlineElements }];
    
    this.update = function($ui) {
        $ui.data('tColorPicker').close();
    }
    
    this.command = function (commandArguments) {

        return new FormatCommand($.extend(commandArguments, {
            formatter: function () { 
                var style = {};
                style[options.domAttr] = commandArguments.value;

                return new GreedyInlineFormatter(format, { style: style }, options.cssAttr); 
            }
        }))        
    }

    this.willDelayExecution = inlineFormatWillDelayExecution;

    this.init = function($ui, initOptions) {
        var editor = initOptions.editor;
        
        $ui.tColorPicker({
            selectedColor: '#000000',
            onChange: function (e) {
                Tool.exec(editor, options.name, e.value);
            }
        });
    }
}

function StyleTool() {
    Tool.call(this);
    var format = [{ tags: ['span'] }],
        finder = new GreedyInlineFormatFinder(format, 'className');
    
    this.command = function (commandArguments) {
        return new FormatCommand($.extend(commandArguments, {
            formatter: function () { 
                return new GreedyInlineFormatter(format, { className: commandArguments.value }); 
            }
        }));
    }
    
    this.update = function($ui, nodes) {
        var list = $ui.data('tSelectBox');
        list.close();
        list.value(finder.getFormat(nodes));
    }

    this.init = function($ui, initOptions) {
        var editor = initOptions.editor;
        
        $ui.tSelectBox({
            data: editor['style'],
            title: editor.localization.style,
            onItemCreate: function (e) {
                var style = dom.inlineStyle(editor.document, 'span', {className : e.dataItem.Value});
                
                e.html = '<span unselectable="on" style="display:block;' + style +'">' + e.html + '</span>';
            },
            onChange: function (e) {
                Tool.exec(editor, 'style', e.value);
            }
        });
    } 
};function BlockFormatFinder(format) {
    function contains(node, children) {
        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            if (child == null || !isAncestorOrSelf(node, child))
                return false;
        }

        return true;
    }

    this.findSuitable = function (nodes) {
        var suitable = [];

        for (var i = 0; i < nodes.length; i++) {
            var candidate = dom.ofType(nodes[i], format[0].tags) ? nodes[i] : dom.parentOfType(nodes[i], format[0].tags);
            if (!candidate)
                return [];
            if ($.inArray(candidate, suitable) < 0)
                suitable.push(candidate);
        }

        for (var i = 0; i < suitable.length; i++)
            if (contains(suitable[i], suitable))
                return [suitable[i]];

        return suitable;
    }

    this.findFormat = function (sourceNode) {
        for (var i = 0; i < format.length; i++) {
            var node = sourceNode;
            var tags = format[i].tags;
            var attributes = format[i].attr;

            while (node) {
                if (dom.ofType(node, tags) && attrEquals(node, attributes))
                    return node;
                node = node.parentNode;
            }
        }
        return null;
    }

    this.getFormat = function (nodes) {
        var findFormat = $.proxy(function(node) { return this.findFormat(isDataNode(node) ? node.parentNode : node); }, this),
            result = findFormat(nodes[0]);

        if (!result)
            return '';

        for (var i = 1, len = nodes.length; i < len; i++)
            if (result != findFormat(nodes[i]))
                return '';

        return result.nodeName.toLowerCase();
    }

    this.isFormatted = function (nodes) {
        for (var i = 0; i < nodes.length; i++)
            if (!this.findFormat(nodes[i]))
                return false;

        return true;
    }
}

function BlockFormatter(format, values) {
    var finder = new BlockFormatFinder(format);

    function wrap(tag, attributes, nodes) {
        var commonAncestor = nodes.length == 1 ? dom.blockParentOrBody(nodes[0]) : dom.commonAncestor.apply(null, nodes);

        if (dom.isInline(commonAncestor))
            commonAncestor = dom.blockParentOrBody(commonAncestor);

        var ancestors = dom.significantChildNodes(commonAncestor);

        var position = findNodeIndex(ancestors[0]);

        var wrapper = dom.create(commonAncestor.ownerDocument, tag, attributes);

        for (var i = 0; i < ancestors.length; i++) {
            var ancestor = ancestors[i];
            if (dom.isBlock(ancestor)) {
                dom.attr(ancestor, attributes);

                if (wrapper.childNodes.length) {
                    dom.insertBefore(wrapper, ancestor);
                    wrapper = wrapper.cloneNode(false);
                }

                position = findNodeIndex(ancestor) + 1;

                continue;
            }

            wrapper.appendChild(ancestor);
        }

        if (wrapper.firstChild)
            dom.insertAt(commonAncestor, wrapper, position);
    }

    this.apply = function (nodes) {
        var formatNodes = dom.is(nodes[0], 'img') && nodes.length == 1 ? [nodes[0]] : finder.findSuitable(nodes);

        var formatToApply = formatNodes.length ? formatByName(dom.name(formatNodes[0]), format) : format[0];

        if (!formatToApply) {
            formatToApply = format[0];
        }

        var tag = formatToApply.tags[0];
        var attributes = $.extend({}, formatToApply.attr, values);

        if (formatNodes.length)
            for (var i = 0; i < formatNodes.length; i++)
                dom.attr(formatNodes[i], attributes);
        else
            wrap(tag, attributes, nodes);
    }

    this.remove = function (nodes) {
        for (var i = 0, l = nodes.length; i < l; i++) {
            var formatNode = finder.findFormat(nodes[i]);
            if (formatNode)
                if (dom.ofType(formatNode, ['p', 'img', 'li'])) {
                    var namedFormat = formatByName(dom.name(formatNode), format);
                    if (namedFormat.attr.style) {
                        dom.unstyle(formatNode, namedFormat.attr.style);
                    }

                    if (namedFormat.attr.className) {
                        dom.removeClass(formatNode, namedFormat.attr.className);
                    }
                    
                } else
                    dom.unwrap(formatNode);
        }
    }

    this.toggle = function (range) {
        var nodes = RangeUtils.nodes(range);
        if (finder.isFormatted(nodes))
            this.remove(nodes);
        else
            this.apply(nodes);
    }
}

function GreedyBlockFormatter(format, values) {
    var finder = new BlockFormatFinder(format);

    this.apply = function (nodes) {
        var blocks = blockParents(nodes);
        var formatTag = format[0].tags[0];
        if (blocks.length) {
            for (var i = 0, len = blocks.length; i < len; i++) {
                if (dom.is(blocks[i], 'li')) {
                    var list = blocks[i].parentNode;
                    var formatter = new ListFormatter(list.nodeName.toLowerCase(), formatTag);
                    var range = this.editor.createRange();
                    range.selectNode(blocks[i]);
                    formatter.toggle(range);
                } else {
                    dom.changeTag(blocks[i], formatTag);
                }
            }
        } else {
            new BlockFormatter(format, values).apply(nodes);
        }
    }

    this.toggle = function (range) {
        var nodes = textNodes(range);
        if (!nodes.length) {
            range.selectNodeContents(range.commonAncestorContainer);
            nodes = textNodes(range);
            if (!nodes.length)
                nodes = dom.significantChildNodes(range.commonAncestorContainer);
        }

        this.apply(nodes);
    }
}

function FormatCommand(options) {
    options.formatter = options.formatter();
    Command.call(this, options);
}

function BlockFormatTool (options) {
    FormatTool.call(this, $.extend(options, {
        finder: new BlockFormatFinder(options.format),
        formatter: function () { return new BlockFormatter(options.format) }
    }));
}

function FormatBlockTool() {
    Tool.call(this);
    var finder = new BlockFormatFinder([{ tags: blockElements }])

    this.command = function (commandArguments) {
        return new FormatCommand($.extend(commandArguments, {
            formatter: function () { return new GreedyBlockFormatter([{ tags: [commandArguments.value] }], {}); }
        }))
    }
    
    this.update = function($ui, nodes) {
        var list = $ui.data('tSelectBox');
        list.close();
        list.value(finder.getFormat(nodes));
    }

    this.init = function($ui, initOptions) {
        var editor = initOptions.editor;
        
        $ui.tSelectBox({
            data: editor.formatBlock,
            title: editor.localization.formatBlock,
            onItemCreate: function (e) {
                var tagName = e.dataItem.Value;
                e.html = '<' + tagName + ' unselectable="on" style="margin: .3em 0;' + dom.inlineStyle(editor.document, tagName) + '">' + e.dataItem.Text + '</' + tagName + '>';
            },
            onChange: function (e) {
                Tool.exec(editor, 'formatBlock', e.value);
            },
            highlightFirst: false
        });
    }
};function ParagraphCommand(options) {
    Command.call(this, options);

    this.exec = function () {
        var range = this.getRange(),
            document = documentFromRange(range),
            parent, previous, next,
            emptyParagraphContent = $.browser.msie ? '' : '<br _moz_dirty="" />',
            paragraph, marker, li, heading, rng,
            // necessary while the emptyParagraphContent is empty under IE
            blocks = 'p,h1,h2,h3,h4,h5,h6'.split(','),
            startInBlock = dom.parentOfType(range.startContainer, blocks),
            endInBlock = dom.parentOfType(range.endContainer, blocks),
            shouldTrim = (startInBlock && !endInBlock) || (!startInBlock && endInBlock);

        range.deleteContents();

        marker = dom.create(document, 'a');
        range.insertNode(marker);

        normalize(marker.parentNode);

        li = dom.parentOfType(marker, ['li']);
        heading = dom.parentOfType(marker, 'h1,h2,h3,h4,h5,h6'.split(','));

        if (li) {
            rng = range.cloneRange();
            rng.selectNode(li);
            
            // hitting 'enter' in empty li
            if (textNodes(rng).length == 0) {
                paragraph = dom.create(document, 'p');

                if (li.nextSibling) {
                    split(rng, li.parentNode);
                }

                dom.insertAfter(paragraph, li.parentNode);
                dom.remove(li.parentNode.childNodes.length == 1 ? li.parentNode : li);
                paragraph.innerHTML = emptyParagraphContent;
                next = paragraph;
            }
        } else if (heading && !marker.nextSibling) {
            paragraph = dom.create(document, 'p');

            dom.insertAfter(paragraph, heading);
            paragraph.innerHTML = emptyParagraphContent;
            dom.remove(marker);
            next = paragraph;
        }

        if (!next) {
            if (!(li || heading)) {
                new BlockFormatter([{ tags: ['p']}]).apply([marker]);
            }

            range.selectNode(marker);

            parent = dom.parentOfType(marker, [li ? 'li' : heading ? dom.name(heading) : 'p']);

            split(range, parent, shouldTrim);

            previous = parent.previousSibling;

            if (dom.is(previous, 'li') && previous.firstChild && !dom.is(previous.firstChild, 'br')) {
                previous = previous.firstChild;
            }

            next = parent.nextSibling;

            if (dom.is(next, 'li') && next.firstChild && !dom.is(next.firstChild, 'br')) {
                next = next.firstChild;
            }

            dom.remove(parent);

            function clean(node) {
                if (node.firstChild && dom.is(node.firstChild, 'br')) {
                    dom.remove(node.firstChild);
                }

                if (isDataNode(node) && node.nodeValue == '') {
                    node = node.parentNode;
                }

                if (node && !dom.is(node, 'img')) {
                    while (node.firstChild && node.firstChild.nodeType == 1) {
                        node = node.firstChild;
                    }

                    if (node.innerHTML == '') {
                        node.innerHTML = emptyParagraphContent;
                    }
                }
            }

            clean(previous);
            clean(next);

            // normalize updates the caret display in Gecko
            normalize(previous);
        }

        normalize(next);

        if (dom.is(next, 'img')) {
            range.setStartBefore(next);
        } else {
            range.selectNodeContents(next);
        }

        range.collapse(true);

        dom.scrollTo(next);

        selectRange(range);
    }
}

function NewLineCommand(options) {
    Command.call(this, options);

    this.exec = function () {
        var range = this.getRange();
        range.deleteContents();
        var br = dom.create(documentFromRange(range), 'br');
        range.insertNode(br);
        normalize(br.parentNode);
        
        if (!$.browser.msie && (!br.nextSibling || dom.isWhitespace(br.nextSibling))) { 
            //Gecko and WebKit cannot put the caret after only one br.
            var filler = br.cloneNode(true);
            filler.setAttribute('_moz_dirty', '');
            dom.insertAfter(filler, br);
        }
        range.setStartAfter(br);
        range.collapse(true);
        selectRange(range);
    }
};function ListFormatFinder(tag) {
    var tags = [tag == 'ul' ? 'ol' : 'ul', tag];
        
    BlockFormatFinder.call(this, [{ tags: tags}]);

    this.isFormatted = function (nodes) {
        var formatNodes = [], formatNode;
            
        for (var i = 0; i < nodes.length; i++)
            if ((formatNode = this.findFormat(nodes[i])) && dom.name(formatNode) == tag)
                formatNodes.push(formatNode);

        if (formatNodes.length < 1) {
            return false;
        }

        if (formatNodes.length != nodes.length) {
            return false;
        }

        // check if sequential lists are selected
        for (i = 0; i < formatNodes.length; i++) {
            if (formatNodes[i].parentNode != formatNode.parentNode) {
                break;
            }

            if (formatNodes[i] != formatNode) {
                return false;
            }
        }

        return true;
    }

    this.findSuitable = function (nodes) {
        var candidate = dom.parentOfType(nodes[0], tags)
        if (candidate && dom.name(candidate) == tag)
            return candidate;
        return null;
    }
}

function ListFormatter(tag, unwrapTag) {
    var finder = new ListFormatFinder(tag);

    function wrap(list, nodes) {
        var li = dom.create(list.ownerDocument, 'li');

        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];

            if (dom.is(node, 'li')) {
                list.appendChild(node);
                continue;
            }

            if (dom.is(node, 'ul') || dom.is(node, 'ol')) {
                while (node.firstChild) {
                    list.appendChild(node.firstChild);
                }
                continue;
            }
            
            if (dom.is(node, "td")) {
                while (node.firstChild) {
                    li.appendChild(node.firstChild);
                }
                list.appendChild(li);
                node.appendChild(list);
                list = list.cloneNode(false);
                li = li.cloneNode(false);
                continue;
            }

            li.appendChild(node);

            if (dom.isBlock(node)) {
                list.appendChild(li);
                dom.unwrap(node);
                li = li.cloneNode(false);
            }
        }

        if (li.firstChild)
            list.appendChild(li);
    }

    function containsAny(parent, nodes) {
        for (var i = 0; i < nodes.length; i++)
            if (isAncestorOrSelf(parent, nodes[i]))
                return true;

        return false;
    }

    function suitable(candidate, nodes) {
        if (candidate.className == "t-marker") {
            var sibling = candidate.nextSibling;

            if (sibling && dom.isBlock(sibling)) {
                return false;
            }

            sibling = candidate.previousSibling;

            if (sibling && dom.isBlock(sibling)) {
                return false;
            }
        }

        return containsAny(candidate, nodes) || dom.isInline(candidate) || candidate.nodeType == 3;
    }

    this.split = function (range) {
        var nodes = textNodes(range);
        if (nodes.length) {
            var start = dom.parentOfType(nodes[0], ['li']);
            var end = dom.parentOfType(nodes[nodes.length - 1], ['li'])
            range.setStartBefore(start);
            range.setEndAfter(end);

            for (var i = 0, l = nodes.length; i < l; i++) {
                var formatNode = finder.findFormat(nodes[i]);
                if (formatNode) {
                    var parents = $(formatNode).parents("ul,ol");
                    if (parents[0]) {
                        split(range, parents.last()[0], true);
                    } else {
                        split(range, formatNode, true);
                    }
                }
            }
        }
    }

    this.apply = function (nodes) {
        var commonAncestor = nodes.length == 1 ? dom.parentOfType(nodes[0], ['ul','ol']) : dom.commonAncestor.apply(null, nodes);
           
        if (!commonAncestor)
            commonAncestor = dom.parentOfType(nodes[0], ["td"]) || nodes[0].ownerDocument.body;

        if (dom.isInline(commonAncestor))
            commonAncestor = dom.blockParentOrBody(commonAncestor);

        var ancestors = [];

        var formatNode = finder.findSuitable(nodes);

        if (!formatNode)
            formatNode = new ListFormatFinder(tag == 'ul' ? 'ol' : 'ul').findSuitable(nodes);
        
        var childNodes = dom.significantChildNodes(commonAncestor);

        if (!childNodes.length) {
            childNodes = nodes;
        }
        
        if (/table|tbody/.test(dom.name(commonAncestor))) {
            childNodes = $.map(nodes, function(node) { return dom.parentOfType(node, ["td"]) });
        }

        for (var i = 0; i < childNodes.length; i++) {
            var child = childNodes[i];
            var nodeName = dom.name(child);
            if (suitable(child, nodes) && (!formatNode || !isAncestorOrSelf(formatNode, child))) {

                if (formatNode && (nodeName == 'ul' || nodeName == 'ol')) {
                    // merging lists
                    $.each(child.childNodes, function () { ancestors.push(this) });
                    dom.remove(child);
                } else {
                    ancestors.push(child);
                }
            }
        }

        if (ancestors.length == childNodes.length && commonAncestor != nodes[0].ownerDocument.body && !/table|tbody|tr|td/.test(dom.name(commonAncestor)))
            ancestors = [commonAncestor];

        if (!formatNode) {
            formatNode = dom.create(commonAncestor.ownerDocument, tag);
            dom.insertBefore(formatNode, ancestors[0]);
        }

        wrap(formatNode, ancestors);

        if (!dom.is(formatNode, tag))
            dom.changeTag(formatNode, tag);

        var prev = formatNode.previousSibling;
        while (prev && (prev.className == "t-marker" || (prev.nodeType == 3 && dom.isWhitespace(prev)))) prev = prev.previousSibling;

        // merge with previous list
        if (prev && dom.name(prev) == tag) {
            while(formatNode.firstChild) {
                prev.appendChild(formatNode.firstChild);
            }
            dom.remove(formatNode);
            formatNode = prev;
        }

        var next = formatNode.nextSibling;
        while (next && (next.className == "t-marker" || (next.nodeType == 3 && dom.isWhitespace(next)))) next = next.nextSibling;

        // merge with next list
        if (next && dom.name(next) == tag) {
            while(formatNode.lastChild) {
                next.insertBefore(formatNode.lastChild, next.firstChild);
            }
            dom.remove(formatNode);
        }
    }

    function unwrap(ul) {
        var parents = $(ul).parents('ul,ol'),
            li,
            p,
            child,
            insert;
            
        if (parents[0]) {
            insert = function(element) {
                dom.insertBefore(element, parents.last()[0]);
            }
        } else {
            insert = function(element) {
                dom.insertBefore(element, ul);
            }
        }

        for (li = ul.firstChild; li; li = li.nextSibling) {
            p = dom.create(ul.ownerDocument, unwrapTag || 'p');
                
            while(li.firstChild) {
                child = li.firstChild;

                if (dom.isBlock(child)) {

                    if (p.firstChild) {
                        insert(p);
                        p = dom.create(ul.ownerDocument, unwrapTag || 'p');
                    }

                    insert(child);
                } else {
                    p.appendChild(child);
                }
            }

            if (p.firstChild) {
                insert(p);
            }
        }

        if (parents[0]) {
            parents.last().remove();
        }

        dom.remove(ul);
    }

    this.remove = function (nodes) {
        var formatNode;
        for (var i = 0, l = nodes.length; i < l; i++)
            if (formatNode = finder.findFormat(nodes[i]))
                unwrap(formatNode);
    }

    this.toggle = function (range) {
        var nodes = textNodes(range),
            ancestor = range.commonAncestorContainer;

        if (!nodes.length) {
            range.selectNodeContents(ancestor);
            nodes = textNodes(range);
            if (!nodes.length){
                var text = ancestor.ownerDocument.createTextNode("");
                range.startContainer.appendChild(text);
                nodes = [text];
                range.selectNode(text.parentNode);
            }

        }
            
        if (finder.isFormatted(nodes)) {
            this.split(range);
            this.remove(nodes);
        } else {
            this.apply(nodes);
        }
    }
}

function ListCommand(options) {
    options.formatter = new ListFormatter(options.tag);
    Command.call(this, options);
}

function ListTool(options) {
    FormatTool.call(this, $.extend(options, {
        finder: new ListFormatFinder(options.tag)
    }));

    this.command = function (commandArguments) { 
        return new ListCommand($.extend(commandArguments, { tag: options.tag }));
    }
};function LinkFormatFinder() {
    this.findSuitable = function (sourceNode) {
        return dom.parentOfType(sourceNode, ['a']);
    }
}

function LinkFormatter() {
    this.finder = new LinkFormatFinder();

    this.apply = function (range, attributes) {
        var nodes = textNodes(range);
        if (attributes.innerHTML != undefined) {
            var markers = getMarkers(range);
            var document = documentFromRange(range);
            range.deleteContents();
            var a = dom.create(document, 'a', attributes);
            range.insertNode(a);

            if (markers.length > 1) {
                dom.insertAfter(markers[markers.length - 1], a);
                dom.insertAfter(markers[1], a);
                dom[nodes.length > 0 ? 'insertBefore' : 'insertAfter'](markers[0], a);
            }
        } else {
            var formatter = new InlineFormatter([{ tags: ['a']}], attributes);
            formatter.finder = this.finder;
            formatter.apply(nodes);
        }
    }
}

function UnlinkCommand(options) {
    options.formatter = {
        toggle : function(range) {
            new InlineFormatter([{ tags: ['a']}]).remove(textNodes(range));
        }
    };
    
    Command.call(this, options);
}

function LinkCommand(options) {
    Command.call(this, options);

    var attributes;

    this.async = true;

    var formatter = new LinkFormatter();

    this.exec = function () {
        var range = this.getRange();

        var collapsed = range.collapsed;

        range = this.lockRange(true);

        var nodes = textNodes(range);

        var initialText = null;

        var self = this;

        function apply(e) {
            var href = $('#t-editor-link-url', dialog.element).val();

            if (href && href != 'http://') {
                attributes = { href: href };

                var title = $('#t-editor-link-title', dialog.element).val();
                if (title)
                    attributes.title = title;

                var text = $('#t-editor-link-text', dialog.element).val();
                if (text !== initialText)
                    attributes.innerHTML = text || href;

                var target = $('#t-editor-link-target', dialog.element).is(':checked');
                if (target)
                    attributes.target = '_blank';

                formatter.apply(range, attributes);
            }
            close(e);
            if (self.change)
                self.change();
        }

        function close(e) {
            e.preventDefault();
            dialog.destroy();

            windowFromDocument(documentFromRange(range)).focus();

            self.releaseRange(range);
        }

        var a = nodes.length ? formatter.finder.findSuitable(nodes[0]) : null;

        var shouldShowText = nodes.length <= 1 || (nodes.length == 2 && collapsed);

        var dialog = $t.window.create($.extend({}, this.editor.dialogOptions, {
            title: "Insert link",
            html: new $.telerik.stringBuilder()
                .cat('<div class="t-editor-dialog">')
                    .cat('<ol>')
                        .cat('<li class="t-form-text-row"><label for="t-editor-link-url">Web address</label><input type="text" class="t-input" id="t-editor-link-url"/></li>')
                        .catIf('<li class="t-form-text-row"><label for="t-editor-link-text">Text</label><input type="text" class="t-input" id="t-editor-link-text"/></li>', shouldShowText)
                        .cat('<li class="t-form-text-row"><label for="t-editor-link-title">Tooltip</label><input type="text" class="t-input" id="t-editor-link-title"/></li>')
                        .cat('<li class="t-form-checkbox-row"><input type="checkbox" id="t-editor-link-target"/><label for="t-editor-link-target">Open link in new window</label></li>')
                    .cat('</ol>')
                    .cat('<div class="t-button-wrapper">')
                        .cat('<button class="t-dialog-insert t-button">Insert</button>')
                        .cat('&nbsp;or&nbsp;')
                        .cat('<a href="#" class="t-dialog-close t-link">Close</a>')
                    .cat('</div>')
                .cat('</div>')
                .string(),
            onClose: close
        }))
            .hide()
            .find('.t-dialog-insert').click(apply).end()
            .find('.t-dialog-close').click(close).end()
            .find('.t-form-text-row input').keydown(function (e) {
                if (e.keyCode == 13)
                    apply(e);
                else if (e.keyCode == 27)
                    close(e);
            }).end()
            // IE < 8 returns absolute url if getAttribute is not used
            .find('#t-editor-link-url').val(a ? a.getAttribute('href', 2) : 'http://').end()
            .find('#t-editor-link-text').val(nodes.length > 0 ? (nodes.length == 1 ? nodes[0].nodeValue : nodes[0].nodeValue + nodes[1].nodeValue) : '').end()
            .find('#t-editor-link-title').val(a ? a.title : '').end()
            .find('#t-editor-link-target').attr('checked', a ? a.target == '_blank' : false).end()
            .show()
            .data('tWindow')
            .center();

        if (shouldShowText && nodes.length > 0)
            initialText = $('#t-editor-link-text', dialog.element).val();

        $('#t-editor-link-url', dialog.element).focus().select();
    },

    this.redo = function () {
        var range = this.lockRange(true);
        formatter.apply(range, attributes);
        this.releaseRange(range);
    }
}

function UnlinkTool(options){
    Tool.call(this, $.extend(options, {command:UnlinkCommand}));
    
    var finder = new InlineFormatFinder([{tags:['a']}]),
        baseInit = this.init;

    this.init = function($ui, options) {
        baseInit.call(this, $ui, options);
        $ui.addClass('t-state-disabled');
    }
    
    this.update = function ($ui, nodes) {
        $ui.toggleClass('t-state-disabled', !finder.isFormatted(nodes))
            .removeClass('t-state-hover');
    }
}
function ImageCommand(options) {
    Command.call(this, options);
    this.async = true;
    var attributes;

    function insertImage(img, range) {
        if (attributes.src && attributes.src != 'http://') {
            if (!img) {
                img = dom.create(documentFromRange(range), 'img', attributes);
                img.onload = img.onerror = function () {
                    img.removeAttribute('complete');
                    img.removeAttribute('width');
                    img.removeAttribute('height');
                }
                range.deleteContents();
                range.insertNode(img);
                range.setStartAfter(img);
                range.setEndAfter(img);
                selectRange(range);
                return true;
            } else
                dom.attr(img, attributes);
        }

        return false;
    }

    this.redo = function () {
        var range = this.lockRange();
        if (!insertImage(RangeUtils.image(range), range))
            this.releaseRange(range);
    }

    this.exec = function () {
        var range = this.lockRange();

        var applied = false;

        var img = RangeUtils.image(range);

        var self = this;

        function apply(e) {
            attributes = {
                src: $('#t-editor-image-url', dialog.element).val(),
                alt: $('#t-editor-image-title', dialog.element).val()
            };

            applied = insertImage(img, range);

            close(e);

            if (self.change)
                self.change();
        }

        function close(e) {
            e.preventDefault();
            dialog.destroy();

            windowFromDocument(documentFromRange(range)).focus();
            if (!applied)
                self.releaseRange(range);
        }

        var fileBrowser = this.editor.fileBrowser;
        var showBrowser = fileBrowser && fileBrowser.selectUrl !== undefined;
        
        function activate() {  
            if (showBrowser) {
                new $t.imageBrowser($(this).find(".t-image-browser"), $.extend(fileBrowser, { apply: apply, element: self.editor.element, localization: self.editor.localization }));
            }
        }        
        
        var dialog = $t.window.create($.extend({ width: 750 }, this.editor.dialogOptions, {
            title: "Insert image",
            html: new $.telerik.stringBuilder()
                        .cat('<div class="t-editor-dialog">')                        
                            .catIf('<div class="t-image-browser"></div>', showBrowser)
                            .cat('<ol>')
                                .cat('<li class="t-form-text-row"><label for="t-editor-image-url">Web address</label><input type="text" class="t-input" id="t-editor-image-url"/></li>')
                                .cat('<li class="t-form-text-row"><label for="t-editor-image-title">Tooltip</label><input type="text" class="t-input" id="t-editor-image-title"/></li>')
                            .cat('</ol>')
                            .cat('<div class="t-button-wrapper">')
                                .cat('<button class="t-dialog-insert t-button">Insert</button>')
                                .cat('&nbsp;or&nbsp;')
                                .cat('<a href="#" class="t-dialog-close t-link">Close</a>')
                            .cat('</div>')
                        .cat('</div>')
                    .string(),
            onClose: close,
            onActivate: activate
        }))
        .hide()
        .find('.t-dialog-insert').click(apply).end()
        .find('.t-dialog-close').click(close).end()
        .find('.t-form-text-row input').keydown(function (e) {
            if (e.keyCode == 13)
                apply(e);
            else if (e.keyCode == 27)
                close(e);
        }).end()                
        .toggleClass("t-imagebrowser", showBrowser)
        // IE < 8 returns absolute url if getAttribute is not used
        .find('#t-editor-image-url').val(img ? img.getAttribute('src', 2) : 'http://').end()
        .find('#t-editor-image-title').val(img ? img.alt : '').end()
        .show()
        .data('tWindow').center();

        $('#t-editor-image-url', dialog.element).focus().select();
    }
};/* select box */

$t.selectbox = function (element, options) {
    var selectedValue;
    var $element = $(element).attr("tabIndex", 0);
    var $text = $element.find('.t-input');

    var dropDown = this.dropDown = new $t.dropDown({
        effects: $t.fx.slide.defaults(),
        onItemCreate: options.onItemCreate,
        onClick: function (e) {
            select(options.data[$(e.item).index()].Value);
            options.onChange({ value: selectedValue })
        }
    });

    function fill() {
        if (!dropDown.$items)
            dropDown.dataBind(options.data);
    }

    function text(value) {
        $text.html(value ? value : '&nbsp;');
    }

    function select(item) {
        fill();
        var index = -1;

        for (var i = 0, len = options.data.length; i < len; i++) {
            if (options.data[i].Value == item) {
                index = i;
                break;
            }
        }

        if (index != -1) {

            dropDown.$items
                    .removeClass('t-state-selected')
                    .eq(index).addClass('t-state-selected');

            text($(dropDown.$items[index]).text());
            selectedValue = options.data[index].Value;
        }
    }

    this.value = function (value) {
        if (value == undefined)
            return selectedValue;

        select(value);

        if (selectedValue != value)
            text(options.title || value);       
    }

    this.close = function () {
        dropDown.close();
    }

    text(options.title || $text.text());

    $element.click(function (e) {
        fill();
        if (dropDown.isOpened())
            dropDown.close();
        else
            dropDown.open({
                offset: $element.offset(),
                outerHeight: $element.outerHeight(),
                outerWidth: $element.outerWidth(),
                zIndex: $t.getElementZIndex($element[0])
            });
    })
    .find('*')
    .attr('unselectable', 'on')
    .end()
    .keydown(function(e) {
        var key = e.keyCode, selected, prev, next;

        if (key === 40) {
            if (!dropDown.isOpened()) {
                $element.click();
            } else {
                selected = dropDown.$items.filter(".t-state-selected");
                if (!selected[0]) {
                    next = dropDown.$items.first();
                } else {
                    next = selected.next();
                }
                if (next[0]) {
                    selected.removeClass("t-state-selected");
                    next.addClass("t-state-selected");
                }
            }
            e.preventDefault();
        } else if (key === 38) {
            if (dropDown.isOpened()) {
                selected = dropDown.$items.filter(".t-state-selected");
                prev = selected.prev();
                if (prev[0]) {
                    selected.removeClass("t-state-selected");
                    prev.addClass("t-state-selected");
                }
            }
            e.preventDefault();
        } else if (key == 13) {
            selected = dropDown.$items.filter(".t-state-selected");
            if (selected[0]) {
                selected.click();
            }
            e.preventDefault();
        } else if (e.keyCode == 9 || e.keyCode == 39 || e.keyCode == 37) {
            dropDown.close();
        }
    });

    if ($.browser.msie) {
        $element.focus(function() {
            $element.css("outline", "1px dotted #000");
        })
        .blur(function() {
            $element.css("outline", "");
        });
    }

    dropDown.$element.css('direction', $element.closest('.t-rtl').length > 0 ? 'rtl' : '');

    $(document.documentElement).bind('mousedown', $.proxy(function (e) {
        var $dropDown = dropDown.$element;
        var isDropDown = $dropDown && $dropDown.parent().length > 0;

        if (isDropDown && !$.contains(element, e.target) && !$.contains($dropDown.parent()[0], e.target)) {
            dropDown.close();
        }

    }, this));
}

$.fn.tSelectBox = function (options) {
    return $t.create(this, {
        name: 'tSelectBox',
        init: function (element, options) {
            return new $t.selectbox(element, options)
        },
        options: options
    });
};

$.fn.tSelectBox.defaults = {
    effects: $t.fx.slide.defaults()
};

/* color picker */

$t.colorpicker = function (element, options) {
    var that = this;

    that.element = element;
    var $element = $(element);

    $.extend(that, options);

    $element.attr("tabIndex", 0)
            .click($.proxy(that.click, that))
            .keydown(function(e) {
                var popup = that.popup(), selected, next, prev;
                if (e.keyCode == 40) {
                    if (!popup.is(":visible")) {
                        that.open();
                    } else {
                       selected = popup.find(".t-state-selected");
                       if (selected[0]) {
                           next = selected.next();
                       } else {
                           next = popup.find("li:first");
                       }
                       if (next[0]) {
                            selected.removeClass("t-state-selected");
                            next.addClass("t-state-selected");
                       } 
                    }
                    e.preventDefault();
                } else if (e.keyCode == 38) {
                    if (popup.is(":visible")) {
                       selected = popup.find(".t-state-selected");
                       prev = selected.prev();
                       if (prev[0]) {
                            selected.removeClass("t-state-selected");
                            prev.addClass("t-state-selected");
                       } 
                    }
                    e.preventDefault();
                } else if (e.keyCode == 9 || e.keyCode == 39 || e.keyCode == 37) {
                    that.close();
                } else if (e.keyCode == 13) {
                   popup.find(".t-state-selected").click();
                   e.preventDefault();
                }
            })
            .find('*')
            .attr('unselectable', 'on');

    if ($.browser.msie) {
        $element.focus(function () {
            $element.css("outline", "1px dotted #000");
        })
        .blur(function() {
            $element.css("outline", "");
        });
    }    

    if (that.selectedColor)
        $element.find('.t-selected-color').css('background-color', this.selectedColor);

    $(element.ownerDocument.documentElement)
        .bind('mousedown', $.proxy(function (e) {
            if (!$(e.target).closest('.t-colorpicker-popup').length) {
                this.close();
            }
        }, that));

    $t.bind(that, {
        change: that.onChange,
        load: that.onLoad
    });
}

$t.colorpicker.prototype = {
    select: function(color) {
        if (color) {
            color = dom.toHex(color);
            if (!$t.trigger(this.element, 'change', { value: color })) {
                this.value(color);
                this.close();
            }
        } else
            $t.trigger(this.element, 'change', { value: this.selectedColor })
    },

    open: function() {
        var $popup = this.popup();
        var $element = $(this.element);

        var elementPosition = $element.offset();
        elementPosition.top += $element.outerHeight();

        if ($element.closest('.t-rtl').length)
            elementPosition.left -= $popup.outerWidth() - $element.outerWidth();

        var zIndex = 'auto';

        $element.parents().andSelf().each(function () {
            zIndex = $(this).css('zIndex');
            if (Number(zIndex)) {
                zIndex = Number(zIndex) + 1;
                return false;
            }
        });

        $t.fx._wrap($popup).css($.extend({
            position: 'absolute',
            zIndex: zIndex
        }, elementPosition));
        
        $popup
            .find('.t-item').bind('click', $.proxy(function(e) {
                var color = $(e.currentTarget, e.target.ownerDocument).find("div").css('background-color');
                this.select(color);
            }, this));

        // animate
        $t.fx.play(this.effects, $popup, { direction: 'bottom' });
    },

    close: function() {
        if (!this.$popup) return;

        $t.fx.rewind(this.effects, this.$popup, { direction: 'bottom' }, $.proxy(function() {
            if (this.$popup) {
                dom.remove(this.$popup[0].parentNode);
                this.$popup = null;
            }
        }, this));
    },

    toggle: function() {
        if (!this.$popup || !this.$popup.is(':visible'))
            this.open();
        else {
            this.close();
        }
    },

    click: function(e) {
        if ($(e.target).closest('.t-tool-icon').length > 0)
            this.select();
        else
            this.toggle();
    },

    value: function(color) {
        if (!color)
            return this.selectedColor;

        color = dom.toHex(color);

        this.selectedColor = color;

        $('.t-selected-color', this.element)
            .css('background-color', color);
    },

    popup: function() {
        if (!this.$popup)
            this.$popup = $($t.colorpicker.buildPopup(this))
                    .hide()
                    .appendTo(document.body)
                    .find('*')
                    .attr('unselectable', 'on')
                    .end();

        return this.$popup;
    }
}

$.extend($t.colorpicker, {
    buildPopup: function(component) {
        var html = new $t.stringBuilder();

        html.cat('<div class="t-popup t-group t-colorpicker-popup">')
            .cat('<ul class="t-reset">');

        var data = component.data;
        var currentColor = (component.value() || '').substring(1);

        for (var i = 0, len = data.length; i < len; i++) {
            html.cat('<li class="t-item')
                .catIf(' t-state-selected', data[i] == currentColor)
                .cat('"><div style="background-color:#')
                .cat(data[i])
                .cat('"></div></li>');
        }

        html.cat('</ul></div>');

        return html.string();
    }
});

$.fn.tColorPicker = function (options) {
    return $t.create(this, {
        name: 'tColorPicker',
        init: function (element, options) {
            return new $t.colorpicker(element, options)
        },
        options: options
    });
};

$.fn.tColorPicker.defaults = {
    data: '000000,7f7f7f,880015,ed1c24,ff7f27,fff200,22b14c,00a2e8,3f48cc,a349a4,ffffff,c3c3c3,b97a57,ffaec9,ffc90e,efe4b0,b5e61d,99d9ea,7092be,c8bfe7'.split(','),
    selectedColor: null,
    effects: $t.fx.slide.defaults()
};
function indent(node, value) {
    var property = dom.name(node) != 'td' ? 'marginLeft' : 'paddingLeft';
    if (value === undefined) {
        return node.style[property] || 0;
    } else {
        if (value > 0) {
            node.style[property] = value + "px";
        } else {
            node.style[property] = "";
            if (node.style.cssText == "") {
                node.removeAttribute("style");
            }
        }
    }
}

function IndentFormatter() {
    var finder = new BlockFormatFinder([{tags:blockElements}]);
    

    this.apply = function (nodes) {
        var formatNodes = finder.findSuitable(nodes);
        if (formatNodes.length) {
            var targets = [];
            for (var i = 0; i < formatNodes.length;i++)
                if (dom.is(formatNodes[i], 'li')) {
                    if ($(formatNodes[i]).index() == 0)
                        targets.push(formatNodes[i].parentNode);
                    else if ($.inArray(formatNodes[i].parentNode, targets) < 0)
                        targets.push(formatNodes[i]);
                }
                else
                    targets.push(formatNodes[i]);
            
            while (targets.length) {
                var formatNode = targets.shift();
                if (dom.is(formatNode, 'li')) {
                    var parentList = formatNode.parentNode;
                    var $sibling = $(formatNode).prev('li');
                    var $siblingList = $sibling.find('ul,ol').last();

                    var nestedList = $(formatNode).children('ul,ol')[0];
                    
                    if (nestedList && $sibling[0]) {
                        if ($siblingList[0]) {
                           $siblingList.append(formatNode);
                           $siblingList.append($(nestedList).children()); 
                           dom.remove(nestedList);
                        } else {
                            $sibling.append(nestedList);
                            nestedList.insertBefore(formatNode, nestedList.firstChild);                        
                        }
                    } else {
                        nestedList = $sibling.children('ul,ol')[0];
                        if (!nestedList) {
                            nestedList = dom.create(formatNode.ownerDocument, dom.name(parentList));
                            $sibling.append(nestedList);
                        }
                        
                        while (formatNode && formatNode.parentNode == parentList) {
                            nestedList.appendChild(formatNode);
                            formatNode = targets.shift();
                        }
                    }
                } else {
                    var marginLeft = parseInt(indent(formatNode)) + 30;
                    indent(formatNode, marginLeft);

                    for (var targetIndex = 0; targetIndex < targets.length; targetIndex++) {
                        if ($.contains(formatNode, targets[targetIndex])) {
                            targets.splice(targetIndex, 1);
                        }
                    }
                }
            }
        } else {
            var formatter = new BlockFormatter([{tags:blockElements}], {style:{marginLeft:30}});

            formatter.apply(nodes);
        }
    }
    
    this.remove = function(nodes) {
        var formatNodes = finder.findSuitable(nodes), targetNode;
        for (var i = 0; i < formatNodes.length; i++) {
            var $formatNode = $(formatNodes[i]);
            
            if ($formatNode.is('li')) {
                var $list = $formatNode.parent();
                var $listParent = $list.parent();
                // $listParent will be ul or ol in case of invalid dom - <ul><li></li><ul><li></li></ul></ul>   
                if ($listParent.is('li,ul,ol') && !indent($list[0])) {
                    // already processed so skip it
                    if (targetNode && $.contains(targetNode, $listParent[0])) {
                        continue;
                    }

                    var $siblings = $formatNode.nextAll('li');
                    if ($siblings.length)
                        $($list[0].cloneNode(false)).appendTo($formatNode).append($siblings);
                                        
                    if ($listParent.is("li")) {
                        $formatNode.insertAfter($listParent);
                    } else {
                        $formatNode.appendTo($listParent);
                    } 

                    if (!$list.children('li').length)
                        $list.remove();
                        
                    continue;
                } else {
                    if (targetNode == $list[0]) {
                        // removing format on sibling LI elements
                        continue;
                    }
                    targetNode = $list[0];
                }
            } else {
                targetNode = formatNodes[i];
            }
                
            var marginLeft = parseInt(indent(targetNode)) - 30;
            indent(targetNode, marginLeft);
        }
    }
}

function IndentCommand(options) {
    options.formatter = {
        toggle : function(range) {
            new IndentFormatter().apply(RangeUtils.nodes(range));
        }
    };
    Command.call(this, options);
}

function OutdentCommand(options) {
    options.formatter = {
        toggle : function(range) {
            new IndentFormatter().remove(RangeUtils.nodes(range));
        }
    };
    
    Command.call(this, options);
}

function OutdentTool() {
    Tool.call(this, {command:OutdentCommand});
    
    var finder = new BlockFormatFinder([{tags:blockElements}]),
        baseInit = this.init;  

    this.init = function($ui, options) {
        baseInit.call(this, $ui, options);
        $ui.addClass('t-state-disabled');
    }
    
    this.update = function ($ui, nodes) {
        var suitable = finder.findSuitable(nodes),
            isOutdentable, listParentsCount;

        for (var i = 0; i < suitable.length; i++) {
            isOutdentable = indent(suitable[i]);

            if (!isOutdentable) {
                listParentsCount = $(suitable[i]).parents('ul,ol').length;
                isOutdentable = (dom.is(suitable[i], 'li') && (listParentsCount > 1 || indent(suitable[i].parentNode)))
                             || (dom.ofType(suitable[i], ['ul','ol']) && listParentsCount > 0);
            }

            if (isOutdentable) {
                $ui.removeClass('t-state-disabled');
                return;
            }
        }
    
        $ui.addClass('t-state-disabled').removeClass('t-state-hover');
    }
};function PendingFormats(editor) {
    this.editor = editor;
    this.formats = [];
}

PendingFormats.prototype = {
    apply: function(range) {
        if (!this.hasPending())
            return;
            
        var marker = new Marker();
        
        marker.addCaret(range);

        var caret = range.startContainer.childNodes[range.startOffset];

        var target = caret.previousSibling;

        /* under IE, target is a zero-length text node. go figure. */
        if (!target.nodeValue)
            target = target.previousSibling;

        range.setStart(target, target.nodeValue.length - 1);

        marker.add(range);

        if (textNodes(range).length == 0) {
            marker.remove(range);
            range.collapse(true);
            this.editor.selectRange(range);
            return;
        }

        var textNode = marker.end.previousSibling.previousSibling;

        var pendingFormat, formats = this.formats;

        for (var i = 0; i < formats.length; i++) {
            pendingFormat = formats[i];
            
            var command = pendingFormat.command($.extend({ range: range }, pendingFormat.params));
            command.editor = this.editor;
            command.exec();

            range.selectNode(textNode);
        }

        marker.remove(range);

        if (textNode.parentNode) {
            range.setStart(textNode, 1);
            range.collapse(true);
        }
        
        this.clear();

        this.editor.selectRange(range);
    },
    hasPending: function() {
        return this.formats.length > 0;
    },
    isPending: function(format) {
        return !!this.getPending(format);
    },
    getPending: function(format) {
        var formats = this.formats;
        for (var i = 0; i < formats.length; i++)
            if (formats[i].name == format)
                return formats[i];

        return;
    },
    toggle: function(format) {
        var formats = this.formats;

        for (var i = 0; i < formats.length; i++)
            if (formats[i].name == format.name) {
                if (formats[i].params && formats[i].params.value != format.params.value)
                    formats[i].params.value = format.params.value;
                else
                    formats.splice(i, 1);

                return;
            }

        formats.push(format);
    },
    clear: function() {
        this.formats = [];
    }
};
function createContentElement($textarea, stylesheets) {
    $textarea.hide();
    var iframe = $('<iframe />', { src: 'javascript:"<html></html>"', frameBorder: '0' })
                    .css('display', '')
                    .addClass("t-content")
                    .insertBefore($textarea)[0];

    var window = iframe.contentWindow || iframe;
    var document = window.document || iframe.contentDocument;
    
    var html = $textarea.val()
                // <img>\s+\w+ creates invalid nodes after cut in IE
                .replace(/(<\/?img[^>]*>)[\r\n\v\f\t ]+/ig, '$1')
                // indented HTML introduces problematic ranges in IE
                .replace(/[\r\n\v\f\t ]+/ig, ' ');

    if (!html.length && $.browser.mozilla)
        html = '<br _moz_dirty="true" />';

    document.designMode = 'On';
    document.open();
    document.write(
        new $t.stringBuilder()
            .cat('<!DOCTYPE html><html><head>')
            .cat('<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />')
            .cat('<style type="text/css">')
                .cat('html,body{padding:0;margin:0;font-family:Verdana,Geneva,sans-serif;background:#fff;}')
                .cat('html{font-size:100%}body{font-size:.75em;line-height:1.5;padding-top:1px;margin-top:-1px;')
                    .catIf('direction:rtl;', $textarea.closest('.t-rtl').length)
                .cat('}')
                .cat('h1{font-size:2em;margin:.67em 0}h2{font-size:1.5em}h3{font-size:1.16em}h4{font-size:1em}h5{font-size:.83em}h6{font-size:.7em}')
                .cat('p{margin:0 0 1em;padding:0 .2em}.t-marker{display:none;}.t-paste-container{position:absolute;left:-10000px;width:1px;height:1px;overflow:hidden}')
                .cat('ul,ol{padding-left:2.5em}')
                .cat('a{color:#00a}')
                .cat('code{font-size:1.23em}')
            .cat('</style>')
            .cat($.map(stylesheets, function(href){ return ['<link type="text/css" href="', href, '" rel="stylesheet"/>'].join(''); }).join(''))
            .cat('</head><body spellcheck="false">')
            .cat(html)
            .cat('</body></html>')
        .string());
        
    document.close();

    return window;
}

function selectionChanged(editor) {
    $t.trigger(editor.element, 'selectionChange');
}

var focusable = ".t-colorpicker,a.t-tool-icon:not(.t-state-disabled),.t-selectbox, .t-combobox .t-input";

function initializeContentElement(editor) {
    var isFirstKeyDown = true;

    editor.window = createContentElement($(editor.textarea), editor.stylesheets);
    editor.document = editor.window.contentDocument || editor.window.document;
    editor.body = editor.document.body;

    $(editor.document)
        .bind({
            keydown: function (e) {
                if (e.keyCode == 9 && e.shiftKey && !e.altKey && !e.ctrlKey) {
                                                var focusElement = $(editor.element).find(focusable);

                    if (focusElement.length) {
                        e.preventDefault();
                        focusElement.focus();
                    }
                } else if (e.keyCode === 121) {
                    //Using the timeout to avoid the default IE menu when F10 is pressed
                    setTimeout(function() {
                        var tabIndex = $(editor.element).attr("tabIndex");
    
                        //Chrome can't focus something which has already been focused
                        $(editor.element).attr("tabIndex", tabIndex || 0).focus().find(focusable).first().focus();
    
                        if (!tabIndex && tabIndex !== 0) {
                           $(editor.element).removeAttr("tabIndex"); 
                        } 

                    }, 100);
                    e.preventDefault();
                } else {
                    var toolName = editor.keyboard.toolFromShortcut(editor.tools, e);

                    if (toolName) {
                        e.preventDefault();
                        if (!/undo|redo/.test(toolName)) {
                            editor.keyboard.endTyping(true);
                        }
                        editor.exec(toolName);
                        return false;
                    }

                    if (editor.keyboard.isTypingKey(e) && editor.pendingFormats.hasPending()) {
                        if (isFirstKeyDown) {
                            isFirstKeyDown = false;
                        } else {
                            var range = editor.getRange();
                            editor.pendingFormats.apply(range);
                            editor.selectRange(range);
                        } 
                    }

                    editor.keyboard.clearTimeout();

                    editor.keyboard.keydown(e);
                }
            },
            keyup: function (e) {
                var selectionCodes = [8, 9, 33, 34, 35, 36, 37, 38, 39, 40, 40, 45, 46];

                if ($.browser.mozilla && e.keyCode == 8) {
                    fixBackspace(editor, e);
                }
                
                if ($.inArray(e.keyCode, selectionCodes) > -1 || (e.keyCode == 65 && e.ctrlKey && !e.altKey && !e.shiftKey)) {
                    editor.pendingFormats.clear();
                    selectionChanged(editor);
                }
                
                if (editor.keyboard.isTypingKey(e)) {
                    if (editor.pendingFormats.hasPending()) {
                        var range = editor.getRange();
                        editor.pendingFormats.apply(range);
                        editor.selectRange(range);
                    }
                } else {
                    isFirstKeyDown = true;
                }

                editor.keyboard.keyup(e);
            },
            mousedown: function(e) {
                editor.pendingFormats.clear();

                var target = $(e.target);

                if (!$.browser.gecko && e.which == 2 && target.is('a[href]'))
                window.open(target.attr('href'), '_new');
            },
            mouseup: function () {
                selectionChanged(editor);
            }
        });

    $(editor.window)
        .bind('blur', function () {
            var old = editor.textarea.value,
            value = editor.encodedValue();

            editor.update(value);

            if (value != old) {
                $t.trigger(editor.element, 'change');
            }
        });
    
    $(editor.body)
        .bind('cut paste', function (e) {
              editor.clipboard['on' + e.type](e);
          });
}

var os = (function detectOS(ua) {
    var os = false, match = [],
        agentRxs = {
            fire: /(Silk)\/(\d+)\.(\d+(\.\d+)?)/,
            android: /(Android)\s+(\d+)\.(\d+(\.\d+)?)/,
            iphone: /(iPhone|iPod).*OS\s+(\d+)[\._]([\d\._]+)/,
            ipad: /(iPad).*OS\s+(\d+)[\._]([\d_]+)/,
            meego: /(MeeGo).+NokiaBrowser\/(\d+)\.([\d\._]+)/,
            webos: /(webOS)\/(\d+)\.(\d+(\.\d+)?)/,
            blackberry: /(BlackBerry|PlayBook).*?Version\/(\d+)\.(\d+(\.\d+)?)/
        },
        osRxs = {
            ios: /^i(phone|pad|pod)$/i,
            android: /^android|fire$/i
        },
        testOs = function (agent) {
            for (var os in osRxs) {
                if (osRxs.hasOwnProperty(os) && osRxs[os].test(agent))
                    return os;
            }
            return agent;
        };

    for (var agent in agentRxs) {
        if (agentRxs.hasOwnProperty(agent)) {
            match = ua.match(agentRxs[agent]);
            if (match) {
                os = {};
                os.device = agent;
                os.name = testOs(agent);
                os[os.name] = true;
                os.majorVersion = match[2];
                os.minorVersion = match[3].replace("_", ".");
                break;
            }
        }
    }
    return os;
})(navigator.userAgent);

var supportedBrowser = !os || (os.ios && os.majorVersion >= 5);

$t.editor = function (element, options) {
    /* suppress initialization in mobile webkit devices (w/o proper contenteditable support) */
    if (!supportedBrowser)
        return;

    var self = this;

    this.element = element;

    var $element = $(element);

    $element.closest('form').bind('submit', function () {
        self.update();
    });

    $.extend(this, options);

    $t.bind(this, {
        load: this.onLoad,
        selectionChange: this.onSelectionChange,
        change: this.onChange,
        execute: this.onExecute,
        error: this.onError,
        paste: this.onPaste
    });

    for (var id in this.tools)
        this.tools[id].name = id.toLowerCase();
        
    this.textarea = $element.find('textarea').attr('autocomplete', 'off')[0];
    initializeContentElement(this);
    this.keyboard = new Keyboard([new TypingHandler(this), new SystemHandler(this)]);
        
    this.clipboard = new Clipboard(this);

    this.pendingFormats = new PendingFormats(this);
        
    this.undoRedoStack = new UndoRedoStack();

    function toolFromClassName(element) {
        var tool = $.grep(element.className.split(' '), function (x) {
            return !/^t-(widget|tool-icon|state-hover|header|combobox|dropdown|selectbox|colorpicker)$/i.test(x);
        });
        return tool[0] ? tool[0].substring(2) : 'custom';
    }

    function appendShortcutSequence(localizedText, tool) {
        if (!tool.key)
            return localizedText;

        return new $t.stringBuilder()
            .cat(localizedText)
            .cat(' (')
                .catIf('Ctrl + ', tool.ctrl)
                .catIf('Shift + ', tool.shift)
                .catIf('Alt + ', tool.alt)
                .cat(tool.key)
            .cat(')')
            .string();
    }

    var toolbarItems = '.t-editor-toolbar > li > *',
        buttons = '.t-editor-button .t-tool-icon',
        enabledButtons = buttons + ':not(.t-state-disabled)',
        disabledButtons = buttons + '.t-state-disabled';

     $element.find(".t-combobox .t-input").keydown(function(e) {
        var combobox = $(this).closest(".t-combobox").data("tComboBox"),
            key = e.keyCode;

        if (key == 39 || key == 37) {
            combobox.close();
        } else if (key == 40) {
            if (!combobox.dropDown.isOpened()) {
                e.stopImmediatePropagation();
                combobox.open();
            }
        }
    });

    $element
        .delegate(enabledButtons, 'mouseenter', $t.hover)
        .delegate(enabledButtons, 'mouseleave', $t.leave)
        .delegate(buttons, 'mousedown', $t.preventDefault)
        .delegate(focusable, "keydown", function(e) {
            var closestLi = $(this).closest("li"),
                focusableTool = "li:has(" + focusable + ")",
                focusElement,
                keyCode = e.keyCode;

            if (keyCode == 39) {
                focusElement = closestLi.nextAll(focusableTool).first().find(focusable);
            } else if (keyCode == 37) {
                focusElement = closestLi.prevAll(focusableTool).last().find(focusable);
            } else if (keyCode == 27) {
                focusElement = self;
            } else if (keyCode == 9 && !(e.ctrlKey || e.altKey)) {
                // skip tabbing to disabled tools, and focus the editing area when running out of tools
                if (e.shiftKey) {
                    focusElement = closestLi.prevAll(focusableTool).last().find(focusable);

                    if (focusElement.length) {
                        e.preventDefault();
                    } else {
                        return;
                    }
                } else {
                    e.preventDefault();

                    focusElement = closestLi.nextAll(focusableTool).first().find(focusable);

                    if (focusElement.length == 0) {
                        focusElement = self;
                    }
                }
            }

            if (focusElement) {
                focusElement.focus();
            }
        })
        .delegate(enabledButtons, 'click', $t.stopAll(function (e) {
            self.exec(toolFromClassName(this));
        }))
        .delegate(disabledButtons, 'click', function(e) { e.preventDefault(); })
        .find(toolbarItems)
            .each(function () {
                var toolName = toolFromClassName(this),
                    tool = self.tools[toolName],
                    description = self.localization[toolName],
                    $this = $(this);

                if (!tool)
                    return;
                    
                if (toolName == 'fontSize' || toolName == 'fontName') {
                    var inheritText = self.localization[toolName + 'Inherit'] || localization[toolName + 'Inherit']
                    self[toolName][0].Text = inheritText;
                    $this.find('input').val(inheritText).end()
                         .find('span.t-input').text(inheritText).end();
                }

                tool.init($this, {
                    title: appendShortcutSequence(description, tool),
                    editor: self
                });

            }).end()
        .bind('selectionChange', function() {
            var range = self.getRange();

            var nodes = textNodes(range);

            if (!nodes.length) {
                nodes = [range.startContainer];
            }

            $element.find(toolbarItems)
                .each(function () {
                    var tool = self.tools[toolFromClassName(this)];
                    if (tool) {
                        tool.update($(this), nodes, self.pendingFormats);
                    }
                });
        });

   
    $(document)
        .bind('DOMNodeInserted', function(e) {
            if ($.contains(e.target, self.element) || self.element == e.target) {
                // preserve updated value before re-initializing
                // don't use update() to prevent the editor from encoding the content too early
                self.textarea.value = self.value();
                $(self.element).find('iframe').remove();
                initializeContentElement(self);
            }
        })
        .bind('mousedown', function(e) {
            try {
                if (self.keyboard.typingInProgress())
                    self.keyboard.endTyping(true);
                
                if (!self.selectionRestorePoint) {
                    self.selectionRestorePoint = new RestorePoint(self.getRange());
                } 
            } catch (e) { }
        });
};

function fixBackspace(editor, e) {

    var range = editor.getRange(),
        startContainer = range.startContainer;

	if (startContainer == editor.body.firstChild || !dom.isBlock(startContainer)
    || (startContainer.childNodes.length > 0 && !(startContainer.childNodes.length == 1 && dom.is(startContainer.firstChild, 'br'))))
        return;
			
	var previousBlock = startContainer.previousSibling;

	while (previousBlock && !dom.isBlock(previousBlock))
        previousBlock = previousBlock.previousSibling;

	if (!previousBlock)
        return;

	var walker = editor.document.createTreeWalker(previousBlock, NodeFilter.SHOW_TEXT, null, false);

    var textNode;

	while (textNode = walker.nextNode())
		previousBlock = textNode;

	range.setStart(previousBlock, isDataNode(previousBlock) ? previousBlock.nodeValue.length : 0);
	range.collapse(true);
	selectRange(range);

	dom.remove(startContainer);

    e.preventDefault();
}

$.extend($t.editor, {
    BlockFormatFinder: BlockFormatFinder,
    BlockFormatter: BlockFormatter,
    Dom: dom,
    FormatCommand: FormatCommand,
    GenericCommand: GenericCommand,
    GreedyBlockFormatter: GreedyBlockFormatter,
    GreedyInlineFormatFinder: GreedyInlineFormatFinder,
    GreedyInlineFormatter: GreedyInlineFormatter,
    ImageCommand: ImageCommand,
    IndentCommand: IndentCommand,
    IndentFormatter: IndentFormatter,
    InlineFormatFinder: InlineFormatFinder,
    InlineFormatter: InlineFormatter,
    InsertHtmlCommand: InsertHtmlCommand,
    Keyboard: Keyboard,
    LinkCommand: LinkCommand,
    LinkFormatFinder: LinkFormatFinder,
    LinkFormatter: LinkFormatter,
    ListCommand: ListCommand,
    ListFormatFinder: ListFormatFinder,
    ListFormatter: ListFormatter,
    MSWordFormatCleaner: MSWordFormatCleaner,
    Marker: Marker,
    NewLineCommand: NewLineCommand,
    OutdentCommand: OutdentCommand,
    ParagraphCommand: ParagraphCommand,
    PendingFormats: PendingFormats,
    RangeEnumerator: RangeEnumerator,
    RangeUtils: RangeUtils,
    RestorePoint: RestorePoint,
    SystemHandler: SystemHandler,
    TypingHandler: TypingHandler,
    UndoRedoStack: UndoRedoStack,
    UnlinkCommand: UnlinkCommand
});

// public api
$t.editor.prototype = {
    value: function (html) {
        var body = this.body;
        if (typeof html == "undefined") return domToXhtml(body);

        this.pendingFormats.clear();

        // Some browsers do not allow setting CDATA sections through innerHTML so we encode them as comments
        html = html.replace(/<!\[CDATA\[(.*)?\]\]>/g, '<!--[CDATA[$1]]-->');

        // Encode script tags to avoid execution and lost content (IE)
        html = html.replace(/<script([^>]*)>(.*)?<\/script>/ig, '<telerik:script $1>$2<\/telerik:script>');

        // Add <br/>s to empty paragraphs in mozilla
        if ($.browser.mozilla)
            html = html.replace(/<p([^>]*)>(\s*)?<\/p>/ig, '<p $1><br _moz_dirty="" /><\/p>');

        if ($.browser.msie && parseInt($.browser.version) < 9) {
            // Internet Explorer removes comments from the beginning of the html
            html = '<br/>' + html;

            var originalSrc = 'originalsrc',
                originalHref = 'originalhref';

            // IE < 8 makes href and src attributes absolute
            html = html.replace(/href\s*=\s*(?:'|")?([^'">\s]*)(?:'|")?/, originalHref + '="$1"');
            html = html.replace(/src\s*=\s*(?:'|")?([^'">\s]*)(?:'|")?/, originalSrc + '="$1"');

            body.innerHTML = html;
            dom.remove(body.firstChild);

            $(body).find('telerik\\:script,script,link,img,a').each(function () {
                var node = this;
                if (node[originalHref]) {
                    node.setAttribute('href', node[originalHref]);
                    node.removeAttribute(originalHref);
                }
                if (node[originalSrc]) {
                    node.setAttribute('src', node[originalSrc]);
                    node.removeAttribute(originalSrc);
                }
            });
        } else {
            body.innerHTML = html;
            if ($.browser.msie) {
                // having unicode characters creates denormalized DOM tree in IE9
                normalize(body);
            }
        }
        
        this.selectionRestorePoint = null;
        this.update();
    },

    focus: function () {
        this.window.focus();
    },

    update: function (value) {
        this.textarea.value = value || this.encoded ? this.encodedValue() : this.value();
    },

    encodedValue: function () {
        return dom.encode(this.value());
    },

    createRange: function (document) {
        return createRange(document || this.document);
    },

    getSelection: function () {
        return selectionFromDocument(this.document);
    },
        
    selectRange: function(range) {
        this.focus();
        var selection = this.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
    },

    getRange: function () {
        var selection = this.getSelection();
        var range = selection.rangeCount > 0 ? selection.getRangeAt(0) : this.createRange();

        if (range.startContainer == this.document && range.endContainer == this.document && range.startOffset == 0 && range.endOffset == 0) {
            range.setStart(this.body, 0);
            range.collapse(true);
        }

        return range;
    },

    selectedHtml: function() {
        return domToXhtml(this.getRange().cloneContents());
    },
    
    paste: function (html) {
        this.clipboard.paste(html);
    },

    exec: function (name, params) {
        var range, body, id, tool = '';

        name = name.toLowerCase();

        // restore selection
        if (!this.keyboard.typingInProgress()) {
            this.focus();

            range = this.getRange();
            body = this.document.body;
        }

        // exec tool
        for (id in this.tools)
            if (id.toLowerCase() == name) {
                tool = this.tools[id];
                break;
            }

        if (tool) {
            range = this.getRange();

            if (!/undo|redo/i.test(name) && tool.willDelayExecution(range)) {
                this.pendingFormats.toggle({ name: name, params: params, command: tool.command });
                selectionChanged(this);
                return;
            }

            var command = tool.command ? tool.command($.extend({ range: range }, params)) : null;

            $t.trigger(this.element, 'execute', { name: name, command: command });

            if (/undo|redo/i.test(name)) {
                this.undoRedoStack[name]();
            } else if (command) {
                if (!command.managesUndoRedo) {
                    this.undoRedoStack.push(command);
                }
                    
                command.editor = this;
                command.exec();

                if (command.async) {
                    command.change = $.proxy(function () { selectionChanged(this); }, this);
                    return;
                }
            }

            selectionChanged(this);
        }
    }
}

$.fn.tEditor = function (options) {
    return $t.create(this, {
        name: 'tEditor',
        init: function (element, options) {
            return new $t.editor(element, options);
        },
        options: options
    });
}

var formats = {
    bold: [
        { tags: ['strong'] },
        { tags: ['span'], attr: { style: { fontWeight: 'bold'}} }
    ],

    italic: [
        { tags: ['em'] },
        { tags: ['span'], attr: { style: { fontStyle: 'italic'}} }
    ],

    underline: [{ tags: ['span'], attr: { style: { textDecoration: 'underline'}}}],

    strikethrough: [
        { tags: ['del'] },
        { tags: ['span'], attr: { style: { textDecoration: 'line-through'}} }
    ],
    
    superscript: [
        { tags: ['sup'] }
    ],
    
    subscript: [
        { tags: ['sub'] }
    ],
    
    justifyLeft: [
        { tags: blockElements, attr: { style: { textAlign: 'left'}} },
        { tags: ['img'], attr: { style: { 'float': 'left'}} }
    ],

    justifyCenter: [
        { tags: blockElements, attr: { style: { textAlign: 'center'}} },
        { tags: ['img'], attr: { style: { display: 'block', marginLeft: 'auto', marginRight: 'auto'}} }
    ],

    justifyRight: [
        { tags: blockElements, attr: { style: { textAlign: 'right'}} },
        { tags: ['img'], attr: { style: { 'float': 'right'}} }
    ],

    justifyFull: [
        { tags: blockElements, attr: { style: { textAlign: 'justify'}} }
    ]
};

function formatByName(name, format) {
    for (var i = 0; i < format.length; i++)
        if ($.inArray(name, format[i].tags) >= 0)
            return format[i];
}

function Tool(options) {
    $.extend(this, options);

    this.init = function($ui, options) {
        $ui.attr({ unselectable: 'on', title: options.title });
    }

    this.command = function (commandArguments) {
        return new options.command(commandArguments);
    }

    this.update = function() {
    }

    this.willDelayExecution = function() {
        return false;
    }
}

Tool.exec = function (editor, name, value) {
    editor.exec(name, { value: value });
}

function FormatTool(options) {
    Tool.call(this, options);

    this.command = function (commandArguments) {
        return new FormatCommand($.extend(commandArguments, {
                formatter: options.formatter
            }));
    }

    this.update = function($ui, nodes, pendingFormats) {
        var isPending = pendingFormats.isPending(this.name),
            isFormatted = options.finder.isFormatted(nodes),
            isActive = isPending ? !isFormatted : isFormatted;

        $ui.toggleClass('t-state-active', isActive);
    }
}

var emptyFinder = function () { return { isFormatted: function () { return false } } };

var localization = {
    bold: 'Bold',
    italic: 'Italic',
    underline: 'Underline',
    strikethrough: 'Strikethrough',
    superscript: 'Superscript',
    subscript: 'Subscript',
    justifyCenter: 'Center text',
    justifyLeft: 'Align text left',
    justifyRight: 'Align text right',
    justifyFull: 'Justify',
    insertUnorderedList: 'Insert unordered list',
    insertOrderedList: 'Insert ordered list',
    indent: 'Indent',
    outdent: 'Outdent',
    createLink: 'Insert hyperlink',
    unlink: 'Remove hyperlink',
    insertImage: 'Insert image',
    insertHtml: 'Insert HTML',
    fontName: 'Select font family',
    fontNameInherit: '(inherited font)',
    fontSize: 'Select font size',
    fontSizeInherit: '(inherited size)',
    formatBlock: 'Format',
    style: 'Styles',
    emptyFolder: 'Empty Folder',
    uploadFile: 'Upload',
    orderBy: 'Arrange by:',
    orderBySize: 'Size',
    orderByName: 'Name',
    invalidFileType: "The selected file \"{0}\" is not valid. Supported file types are {1}.",
    deleteFile: 'Are you sure you want to delete "{0}"?',
    overwriteFile: 'A file with name "{0}" already exists in the current directory. Do you want to overwrite it?',
    directoryNotFound: 'A directory with this name was not found.'
};

$.fn.tEditor.defaults = {
    localization: localization,
    formats: formats,
    encoded: true,
    stylesheets: [],
    dialogOptions: {
        modal: true, resizable: false, draggable: true,
        effects: {list:[{name:'toggle'}]}
    },
    fontName: [
        { Text: localization.fontNameInherit,  Value: 'inherit' },
        { Text: 'Arial', Value: "Arial,Helvetica,sans-serif" },
        { Text: 'Courier New', Value: "'Courier New',Courier,monospace" },
        { Text: 'Georgia', Value: "Georgia,serif" },
        { Text: 'Impact', Value: "Impact,Charcoal,sans-serif" },
        { Text: 'Lucida Console', Value: "'Lucida Console',Monaco,monospace" },
        { Text: 'Tahoma', Value: "Tahoma,Geneva,sans-serif" },
        { Text: 'Times New Roman', Value: "'Times New Roman',Times,serif" },
        { Text: 'Trebuchet MS', Value: "'Trebuchet MS',Helvetica,sans-serif" },
        { Text: 'Verdana', Value: "Verdana,Geneva,sans-serif" }
    ],
    fontSize: [
        { Text: localization.fontSizeInherit,  Value: 'inherit' },
        { Text: '1 (8pt)',  Value: 'xx-small' },
        { Text: '2 (10pt)', Value: 'x-small' },
        { Text: '3 (12pt)', Value: 'small' },
        { Text: '4 (14pt)', Value: 'medium' },
        { Text: '5 (18pt)', Value: 'large' },
        { Text: '6 (24pt)', Value: 'x-large' },
        { Text: '7 (36pt)', Value: 'xx-large' }
    ],
    formatBlock: [
        { Text: 'Paragraph', Value: 'p' },
        { Text: 'Quotation', Value: 'blockquote' },
        { Text: 'Heading 1', Value: 'h1' },
        { Text: 'Heading 2', Value: 'h2' },
        { Text: 'Heading 3', Value: 'h3' },
        { Text: 'Heading 4', Value: 'h4' },
        { Text: 'Heading 5', Value: 'h5' },
        { Text: 'Heading 6', Value: 'h6' }
    ],
    tools: {
        bold: new InlineFormatTool({ key: 'B', ctrl: true, format: formats.bold}),
        italic: new InlineFormatTool({ key: 'I', ctrl: true, format: formats.italic}),
        underline: new InlineFormatTool({ key: 'U', ctrl: true, format: formats.underline}),
        strikethrough: new InlineFormatTool({format: formats.strikethrough}),
        superscript: new InlineFormatTool({format: formats.superscript }),
        subscript: new InlineFormatTool({format: formats.subscript }),
        undo: { key: 'Z', ctrl: true },
        redo: { key: 'Y', ctrl: true },
        insertLineBreak: new Tool({ key: 13, shift: true, command: NewLineCommand }),
        insertParagraph: new Tool({ key: 13, command: ParagraphCommand }),
        justifyCenter: new BlockFormatTool({format: formats.justifyCenter}),
        justifyLeft: new BlockFormatTool({format: formats.justifyLeft}),
        justifyRight: new BlockFormatTool({format: formats.justifyRight}),
        justifyFull: new BlockFormatTool({format: formats.justifyFull}),
        insertUnorderedList: new ListTool({tag:'ul'}),
        insertOrderedList: new ListTool({tag:'ol'}),
        createLink: new Tool({ key: 'K', ctrl: true, command: LinkCommand}),
        unlink: new UnlinkTool({ key: 'K', ctrl: true, shift: true}),
        insertImage: new Tool({ command: ImageCommand }),
        indent: new Tool({ command: IndentCommand }),
        outdent: new OutdentTool(),
        insertHtml: new InsertHtmlTool(),
        style: new StyleTool(),
        fontName: new FontTool({cssAttr:'font-family', domAttr: 'fontFamily', name:'fontName'}),
        fontSize: new FontTool({cssAttr:'font-size', domAttr:'fontSize', name:'fontSize'}),
        formatBlock: new FormatBlockTool(),
        foreColor: new ColorTool({cssAttr:'color', domAttr:'color', name:'foreColor'}),
        backColor: new ColorTool({cssAttr:'background-color', domAttr: 'backgroundColor', name:'backColor'})
    }
}
})(jQuery);
(function ($) {

    var $t = $.telerik,
        keycodes = [8, // backspace
                    9, // tab
                    37, // left arrow
                    38, // up arrow
                    39, // right arrow
                    40, // down arrow
                    46, // delete
                    35, // end
                    36, // home
                    44], //","
        styles = ["font-family",
                  "font-size",
                  "font-stretch",
                  "font-style",
                  "font-weight",
                  "line-height",
                  "color",
                  "text-align",
                  "text-decoration",
                  "text-transform"];
    
    $t.scripts.push("telerik.textbox.js");

    function getStyles(input) {
        var retrievedStyles = {};
        for (var i = 0, length = styles.length; i < length; i++) {
            var style = styles[i],
                value = input.css(style);

            if (value) {
                if (styles[i] != "font-style" && value != "normal") {
                    retrievedStyles[style] = value;
                }
            }
        }
        return retrievedStyles;
    }

    $t.textbox = function (element, options) {
        if (element.nodeName.toLowerCase() !== "input" && element.type.toLowerCase() !== "text") {
            throw "Target element is not a INPUT";
        }

        var that = this;

        $.extend(that, options);

        that.element = element;
        var $element = that.$element = $(element)
            .bind({
                keydown: $.proxy(that._keydown, that),
                keypress: $.proxy(that._keypress, that)
            })
            .bind("paste", $.proxy(that._paste, that));

        $element.closest("form").bind("reset", $.proxy(that._onParentFormReset, that));

        var builder = new $t.stringBuilder();

        if (element.parentNode.nodeName.toLowerCase() !== "div") {
            $element.addClass('t-input')
                    .wrap($('<div class="t-widget t-numerictextbox"></div>'));

            if (that.showIncreaseButton) {
                builder.cat('<a class="t-link t-icon t-arrow-up" href="#" tabindex="-1" title="')
                       .cat(that.increaseButtonTitle)
                       .cat('">Increment</a>');
            }

            if (that.showDecreaseButton) {
                builder.cat('<a class="t-link t-icon t-arrow-down" href="#" tabindex="-1" title="')
                       .cat(that.decreaseButtonTitle)
                       .cat('">Decrement</a>');
            }

            if (builder.buffer.length > 0) {
                $(builder.string()).insertAfter($element);
            }
        }

        that.$wrapper = $element.closest('.t-numerictextbox')
            .find('.t-arrow-up, .t-arrow-down')
                .bind({
                    click: $t.preventDefault,
                    dragstart: $t.preventDefault
                })
            .end()
            .bind({
                focusin: $.proxy(that._focus, that),
                focusout: $.proxy(that._blur, that)
            });

        that.enabled = !$element.is('[disabled]');

        builder.buffer = [];
        builder.cat('[ |')
               .cat(that.groupSeparator)
               .catIf('|' + that.symbol, that.symbol)
               .cat(']');
        that.replaceRegExp = new RegExp(builder.string(), 'g');

        var inputValue = $element.attr('value'),
            cssClass = $element.attr('class').replace("t-input", "").replace("input-validation-error", "");

        builder.buffer = [];
        builder.cat('<div class="t-formatted-value')
               .catIf(' t-state-empty', inputValue == '' && that.enabled)
               .catIf(cssClass, cssClass)
               .cat('">')
               .cat(inputValue || (that.enabled ? that.text : ''))
               .cat('</div>');

        that.$text = $(builder.string())
                        .insertBefore($element)
                        .css(getStyles($element))
                        .click(function (e) {
                            if (that.enabled) {
                                element.focus();
                            }
                        });

        //set text color to the background-color
        that._blur();
        that[that.enabled ? 'enable' : 'disable']();

        that.numFormat = that.numFormat === undefined ? that.type.charAt(0) : that.numFormat;
        that.step = that.parse(that.step);
        that.val = that.parse(that.val);
        that.minValue = that.parse(that.minValue);
        that.maxValue = that.parse(that.maxValue);
        that.decimals = { '190': '.', '188': ',' };
        that.specialDecimals = { '110': that.separator };

        that.value(inputValue || that.val);

        $t.bind(that, {
            load: that.onLoad,
            valueChange: that.onChange
        });
    }

    $t.textbox.prototype = {
        _paste: function (e) {
            setTimeout($.proxy(function () {
                var val = e.target.value;

                if (val == '-') {
                    return true;
                }

                var parsedValue = this.parse(val);
                if (parsedValue || parsedValue == 0) {
                    this._update(parsedValue);
                }
            }, this));
        },

        _keydown: function (e) {
            setTimeout($.proxy(function () {
                $element.toggleClass('t-state-error', !this.inRange(this.parse($element.val()), this.minValue, this.maxValue));
            }, this));

            var key = e.keyCode,
                $element = this.$element,
                element = $element[0],
                value = $element.val(),
                separator = this.separator,
                selection = currentSelection(element),
                start = selection.start,
                end = selection.end,
                separatorIndex = value ? value.indexOf(separator) : -1,
                allowSeparator = separatorIndex === -1;

            if (!allowSeparator && start !== -1) {
                if (separatorIndex >= start && separatorIndex < end) {
                    allowSeparator = true;
                }
            }

            var specialDecimals = this.specialDecimals[key];
            if (specialDecimals) {
                if (allowSeparator) {
                    var firstSliceEnd,
                        secondSliceStart;

                    if (start != -1) {
                        firstSliceEnd = start;
                        secondSliceStart = end;
                    } else {
                        var caret = $t.caretPos(element);
                        firstSliceEnd = caret;
                        secondSliceStart = caret;
                    }
                    $element.val(value.slice(0, firstSliceEnd) + specialDecimals + value.slice(secondSliceStart, value.length));
                    if ($.browser.msie) {
                        if (element.createTextRange) {
                            var range = element.createTextRange();
                            range.moveStart('textedit', 1);
                            range.select();
                        }
                    }
                }
                return false;
            }

            // Allow decimal
            var decimalSeparator = this.decimals[key];
            if (decimalSeparator) {
                if (decimalSeparator === separator && this.digits > 0 && allowSeparator) {
                    return true;
                } else {
                    e.preventDefault();
                }
            }

            if (key == 13 || key == 9) { //backspace and delete
                this._update(this.parse($element.val()));
                return true;
            }

            if (key == 38 || key == 40) {
                var direction = key == 38 ? 1 : -1;
                this._modify(direction * this.step);
                return true;
            }

            if (key == 222) e.preventDefault();
        },

        _keypress: function (e) {
            var element = e.target,
                key = e.keyCode || e.which;

            if (key == 0 || $.inArray(key, keycodes) != -1 || e.ctrlKey || (e.shiftKey && key == 45)) {
                return true;
            }

            var isSignAllowed;
            if (this.minValue === null || this.minValue < 0) {
                if (currentSelection(element).start === 0
                || ($t.caretPos(element) === 0 && element.value.indexOf("-") === -1)) {
                    isSignAllowed = true;
                }
            }

            if ((isSignAllowed && String.fromCharCode(key) == "-") || this.inRange(key, 48, 57)) {
                return true;
            }

            e.preventDefault();
        },

        _focus: function () {
            if (this.enabled) {
                this._showTextBoxValue();
                this.$text.hide();
                var input = this.$element[0];
                this._focusing = setTimeout(function () {
                    input.focus();
                    if ($.browser.msie) {
                        input.select();
                    } else {
                        input.selectionStart = 0;
                        input.selectionEnd = input.value.length;
                    }
                }, 0);
            }
        },

        _blur: function () {
            clearTimeout(this._focusing);
            this.$element.removeClass('t-state-error');

            if (this.enabled) {
                this.$text.show();
                this._hideTextBoxValue();
            }

            var min = this.minValue,
                max = this.maxValue,
                parsedValue = this.parse(this.$element.val());

            if (parsedValue != null) {
                if (min != null && parsedValue < min) {
                    parsedValue = min;
                } else if (max != null && parsedValue > max) {
                    parsedValue = max;
                }
                parsedValue = parseFloat(parsedValue.toFixed(this.digits));
            }
            this._update(parsedValue);
        },

        _clearTimer: function (e) {
            clearTimeout(this.timeout);
            clearInterval(this.timer);
            clearInterval(this.acceleration);
        },

        _stepper: function (e, stepMod) {
            if (e.which == 1) {

                var step = this.step;

                this._modify(stepMod * step);

                this.timeout = setTimeout($.proxy(function () {
                    this.timer = setInterval($.proxy(function () {
                        this._modify(stepMod * step);
                    }, this), 80);

                    this.acceleration = setInterval(function () { step += 1; }, 1000);
                }, this), 200);
            }
        },

        _modify: function (step) {
            var value = this.parse(this.element.value),
                min = this.minValue,
                max = this.maxValue;

            value = value ? value + step : step;

            if (min !== null && value < min) {
                value = min;
            } else if (max !== null && value > max) {
                value = max;
            }

            this._update(parseFloat(value.toFixed(this.digits)));
        },

        _update: function (val) {
            var oldValue = this.val;
            this._value(val);

            if (oldValue != val) {
                if ($t.trigger(this.element, 'valueChange', { oldValue: oldValue, newValue: val })) {
                    this._value(oldValue);
                }
            }
        },

        _value: function (value) {
            var parsedValue = (typeof value === "number") ? value : this.parse(value),
                text = this.enabled ? this.text : '',
                isNull = parsedValue === null;

            if (parsedValue != null) {
                parsedValue = parseFloat(parsedValue.toFixed(this.digits));
            }

            this.val = parsedValue;
            this.$element.val(isNull ? '' : this.formatEdit(parsedValue));
            this.$text.html(isNull ? text : this.format(parsedValue));
            this.$text.toggleClass('t-state-empty', isNull);
        },

        _hideTextBoxValue: function () {
            var $element = this.$element;
            if (this.enabled) {
                setTimeout(function () { $element.css('color', $element.css('background-color')); });
                if ($.browser.opera) {
                    $element.css({ 'color': $element.css('background-color'), 'text-indent': '-4444px' });
                }
            } else {
                if (!$.browser.msie) {
                    $element.css({ 'color': $element.css('background-color'), 'text-indent': '-4444px' });
                } else {
                    $element.css({ 'color': $element.css('background-color'), 'letter-spacing': '1000px' });
                }
            }
        },

        _showTextBoxValue: function () {
            var $element = this.$element,
                $text = this.$text;
            if (this.enabled) {
                setTimeout(function () { $element.css({ 'color': $text.css('color'), 'text-indent': '', 'letter-spacing': '' }); });
            } else {
                if (!$.browser.msie) {
                    $element.css({ 'color': $text.css('background-color'), 'text-indent': '0px' });
                } else {
                    $element.css({ 'color': $text.css('background-color'), 'letter-spacing': '0px' });
                }
            }
        },

        _onParentFormReset: function () {
            var that = this;
            window.setTimeout(function () { that._value(that.$element.val()); }, 1);
        },

        enable: function () {
            var $buttons = this.$wrapper.find('.t-arrow-up, .t-arrow-down'),
                clearTimerProxy = $.proxy(this._clearTimer, this);

            this.enabled = true;
            this.$element.removeAttr("disabled");

            if (!this.val && this.val != 0) {
                this.$text
                    .addClass('t-state-empty')
                    .html(this.text);
            } else {
                this._hideTextBoxValue();
            }
            this.$wrapper.removeClass('t-state-disabled');
            $buttons.unbind('mouseup').unbind('mouseout').unbind('dblclick')
                    .bind({
                        mouseup: clearTimerProxy,
                        mouseout: clearTimerProxy,
                        dblclick: clearTimerProxy
                    });

            var eventName = "mousedown";
            $buttons.eq(0)
                    .unbind(eventName)
                    .bind(eventName, $.proxy(function (e) {
                        this._stepper(e, 1);
                    }, this));

            $buttons.eq(1)
                    .unbind(eventName)
                    .bind(eventName, $.proxy(function (e) {
                        this._stepper(e, -1);
                    }, this));
        },

        disable: function () {
            var that = this;
            that.enabled = false;

            that.$wrapper
                .addClass('t-state-disabled')
                .find('.t-icon')
                    .unbind('mousedown')
                    .bind('mousedown', $t.preventDefault);

            that.$element.attr('disabled', 'disabled');
            that.$text.css("color", "");

            if (!that.val && that.val != 0) {
                that.$text.html('');
            } else {
                that._hideTextBoxValue();
            }
        },

        value: function (value) {
            if (value === undefined) {
                return this.parse(this.element.value);
            }

            var parsedValue = (typeof value === "number") ? value : this.parse(value);
            if (!this.inRange(parsedValue, this.minValue, this.maxValue)) {
                parsedValue = null;
            }

            this._value(parsedValue);
        },

        formatEdit: function (value) {
            var separator = this.separator;

            if (value.toString().toLowerCase().indexOf("e") > -1) {
                value = value.toFixed(this.digits);
            }

            if (value && separator != '.'){
                value = value.toString().replace('.', separator);
            }
            return value;
        },

        format: function (value) {
            return $t.formatNumber(value,
                                           this.numFormat,
                                           this.digits,
                                           this.separator,
                                           this.groupSeparator,
                                           this.groupSize,
                                           this.positive,
                                           this.negative,
                                           this.symbol,
                                           true);
        },

        inRange: function (key, min, max) {
            return key === null || ((min !== null ? key >= min : true) && (max !== null ? key <= max : true));
        },

        parse: function (value) {
            var result = null,
                separator = this.separator;

            if (value || value == "0") {
                if (typeof value == typeof 1) {
                    return value;
                }

                if (value.toLowerCase().indexOf("e") > -1 && !isNaN(Number(value))) {
                    value = Number(value);
                    value = value.toFixed(this.digits).replace('.', separator);
                }

                value = value.replace(this.replaceRegExp, '');
                if (separator && separator != '.') {
                    value = value.replace(separator, '.');
                }

                var negativeFormatPattern = $t.patterns[this.type].negative[this.negative]
                        .replace(/(\(|\))/g, '\\$1').replace('*', '').replace('n', '([\\d|\\.]*)'),
                    negativeFormatRegEx = new RegExp(negativeFormatPattern);

                if (negativeFormatRegEx.test(value))
                    result = -parseFloat(negativeFormatRegEx.exec(value)[1]);
                else
                    result = parseFloat(value);
            }
            return isNaN(result) ? null : result;
        }
    }

    $.fn.tTextBox = function (options) {
        var type = 'numeric';
        if (options && options.type) {
            type = options.type;
        }

        var defaults = $.fn.tTextBox.defaults[type];
        defaults.digits = $t.cultureInfo[type + 'decimaldigits'];
        defaults.separator = $t.cultureInfo[type + 'decimalseparator'];
        defaults.groupSeparator = $t.cultureInfo[type + 'groupseparator'];
        defaults.groupSize = $t.cultureInfo[type + 'groupsize'];
        defaults.positive = $t.cultureInfo[type + 'positive'];
        defaults.negative = $t.cultureInfo[type + 'negative'];
        defaults.symbol = $t.cultureInfo[type + 'symbol'];

        options = $.extend({}, defaults, options);
        options.type = type;

        return this.each(function () {
            var $element = $(this);
            options = $.meta ? $.extend({}, options, $element.data()) : options;

            if (!$element.data('tTextBox')) {
                $element.data('tTextBox', new $t.textbox(this, options));
                $t.trigger(this, 'load');
            }
        });
    };

    var commonDefaults = {
        val: null,
        text: '',
        step: 1,
        inputAttributes: '',
        increaseButtonTitle: "Increase value",
        decreaseButtonTitle: "Decrease value",
        showIncreaseButton: true,
        showDecreaseButton: true
    };

    $.fn.tTextBox.defaults = {
        numeric: $.extend(commonDefaults, {
            minValue: -100,
            maxValue: 100
        }),
        currency: $.extend(commonDefaults, {
            minValue: 0,
            maxValue: 1000
        }),
        percent: $.extend(commonDefaults, {
            minValue: 0,
            maxValue: 100
        })
    };

    function currentSelection(element) {
        var selectionStart = -1,
            selectionEnd = -1;

        if (document.selection) {
            var selectedText = element.document.selection.createRange().text,
                length = selectedText.length;
            if (length > 0) {
                selectionStart = element.value.indexOf(selectedText);
                selectionEnd = length;
            }
        } else if (element.selectionStart !== undefined) {
            var selStart = element.selectionStart,
                selEnd = element.selectionEnd;
            if (selStart != selEnd) {
                selectionStart = selStart;
                selectionEnd = selEnd;
            }
        }
        return { start: selectionStart, end: selectionEnd };
    }

})(jQuery);
(function ($, undefined) {
    var keys = {            
            TAB: 9,
            ENTER: 13,
            ESC: 27,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,            
            SPACEBAR: 32,
            PAGEUP: 33,
            PAGEDOWN: 34,
            F12: 123
        };
    var $t = $.telerik;
    var rdate = /"+\\\/Date\((.*?)\)\\\/"+/g;
    var ROWSELECTOR = "tr:not(.t-grouping-row,.t-group-footer,.t-detail-row,.t-no-data,.t-footer-template):visible",
        CELLSELECTOR = ">td:not(.t-group-cell,.t-hierarchy-cell):visible",
        FIRST_CELL_SELECTOR = ROWSELECTOR + CELLSELECTOR + ":first",
        FOCUSED = "t-state-focused";

    $t.scripts.push("telerik.grid.js");

    function template(value) {
        return new Function('data', ("var p=[];" +
            "with(data){p.push('" + unescape(value).replace(/[\r\t\n]/g, " ")
                .replace(/'(?=[^#]*#>)/g, "\t")
                .split("'").join("\\'")
                .split("\t").join("'")
                .replace(/<#=(.+?)#>/g, "',$1,'")
                .split("<#").join("');")
                .split("#>").join("p.push('")
                + "');}return p.join('');"));
    }

    function encode(value) {
        return (value != null ? value + '' : '').replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
    }    

    function normalizeCols(cols, columns, columnIndex) {
        var col = $("<col />").css("width", columns[columnIndex].width),
            idx,
            length,
            colIndex = 0;
        
        for(idx = 0, length = columns.length; idx < length; idx++) {                
            if(idx >= columnIndex && colIndex) {
                break;
            }

            if(!columns[idx].hidden) {
                colIndex++;
            }
        }
        
        if(idx > columnIndex) {
            cols.eq(colIndex - 1).before(col);
        } 
        else {
            cols.eq(colIndex - 1).after(col);
        }
    }

    $t.grid = function (element, options) {
        var grid = this;
        this.element = element;
        this.groups = [];
        this.editing = {};
        this.filterBy = '';
        this.groupBy = '';
        this.orderBy = '';

        $.extend(this, options);

        this.sorted = $.grep(this.columns, function (column) { return column.order; });

        this.$tbody = $('> .t-grid-content > table > tbody', element);
        this.scrollable = this.$tbody.length > 0;

        this.$headerWrap = $('> .t-grid-header > .t-grid-header-wrap', element);
        this.$footerWrap = $('> .t-grid-footer > .t-grid-footer-wrap', element);

        if (!this.scrollable) {
            this.$tbody = $('> table > tbody', element);
            this.$header = $('> table > thead > tr', element);
            this.$footer = $('> table > tfoot', element);
        } else {
            
            $('> .t-grid-content', element).tScrollable();

            this.$header = $('> .t-grid-header > .t-grid-header-wrap > table > tbody > tr', element);
            this.$footer = $('> .t-grid-footer', element);

            var isRtl = $(element).closest('.t-rtl').length,
                isRightScroll = this._isRightScrollBar();

            if (isRtl) {
                if (isRightScroll) {
                    $(element).addClass("t-grid-rightscroll"); //reverses header div padding
                }
            }            

            var scrollables = this.$headerWrap.add(this.$footerWrap),
                scrollbarWidth = $t.scrollbarWidth(),
                scrollParents = scrollables.parent();

            var isTouch = (/iphone|ipad|android/gi).test(navigator.appVersion);

            if (isTouch) {
                scrollParents.css("padding", "0");
                scrollables.css({"width": "auto", "border-width": 0});
            } else {
                if (!isRtl || isRightScroll) {
                    scrollParents.css("padding-right", scrollbarWidth);
                } else {
                    scrollParents.css("padding-left", scrollbarWidth);
                }
                if (scrollbarWidth == 0) {
                    scrollables.css("border-width", 0);
                }
            }
                        
            $('> .t-grid-content', element).bind('scroll', function () {
                if(grid.pageOnScroll) {
                    var pos = this.scrollTop + this.clientHeight;
                    if(pos === this.scrollHeight && grid.currentPage < grid.totalPages() && !grid._pagingInProgress) {
                        grid._pagingInProgress = true;
                        grid.pageTo(grid.currentPage + 1);    
                    }
                }
                scrollables.scrollLeft(this.scrollLeft);
            });
        }

        if (this.rowTemplate) {
            this.rowTemplate = template(this.rowTemplate);
        }

        this.$tbody.delegate('.t-hierarchy-cell .t-plus, .t-hierarchy-cell .t-minus', 'click', $t.stopAll(function (e) {
            var $icon = $(e.target);
            var expanding = $icon.hasClass('t-plus');

            $icon.toggleClass('t-minus', expanding)
                .toggleClass('t-plus', !expanding);
            var $tr = $icon.closest('tr.t-master-row');
            if (this.detail && !$tr.next().hasClass('t-detail-row')) {
                var colSpan = 0;
                $.each(this.columns, function(){ if(!this.hidden){ colSpan++; } });                

                $(new $t.stringBuilder()
                        .cat('<tr class="t-detail-row')
                        .catIf(' t-alt', $tr.hasClass('t-alt'))
                        .cat('">')
                        .rep('<td class="t-group-cell"></td>', $tr.find('.t-group-cell').length)
                        .cat('<td class="t-hierarchy-cell"></td>')
                        .cat('<td class="t-detail-cell" colspan="')
                        .cat(colSpan)
                        .cat('">')
                        .cat(this.displayDetails(this.dataItem($tr)))
                        .cat('</td></tr>').string()).insertAfter($tr);
            }
            $t.trigger(this.element, expanding ? 'detailViewExpand' : 'detailViewCollapse', { masterRow: $tr[0], detailRow: $tr.next('.t-detail-row')[0] });
            $tr.next().toggle(expanding);
        }, this));

        this.$pager = $('> .t-grid-pager .t-pager', element);

        var dropDown = new $t.dropDown({ 
            effects: $t.fx.slide.defaults(),
            onClick: $.proxy(function (e) {                                             
                this.changePageSize($(e.item).text());                                
                dropDown.close();   
            },this)
        });

        $(element).delegate(".t-button", "click", $.proxy(function(e) {
           this._command(e); 
        }, this));

        dropDown.dataBind(options.pageSizesInDropDown || []);
        
        $(document.documentElement).bind('mousedown', function (e) {
            var element = dropDown.$element[0];

            if (!$.contains(element, e.target)) {
                dropDown.close();
            }
        });

        this.$pager.delegate('.t-state-disabled', 'click', $t.preventDefault)
                   .delegate('.t-link:not(.t-state-disabled)', 'mouseenter', $t.hover)
                   .delegate('.t-link:not(.t-state-disabled)', 'mouseleave', $t.leave)
                   .delegate('input[type=text]', 'keydown', $.proxy(this.pagerKeyDown, this))
                   .delegate('.t-page-size .t-dropdown-wrap', 'click', function(){
                        var a = $(this);
                        dropDown.open({
                            offset: a.offset(),
                            outerHeight: a.outerHeight(),
                            outerWidth: a.outerWidth(),
                            zIndex: $t.getElementZIndex(this)
                        });
                    });

        $('> .t-grid-pager', element).delegate('.t-refresh', 'click', $.proxy(this.refreshClick, this));

        $(element).delegate('.t-button', 'hover', $t.preventDefault);

        if (this.sort)
            this.$header.delegate('a.t-link', 'hover', function () {
                $(this).toggleClass('t-state-hover');
            });

        var nonSelectableRows = 'tr:not(.t-grouping-row,.t-detail-row,.t-no-data,.t-group-footer,:has(>.t-edit-container))';
        
        if (this.selectable) {
            var tbody = this.$tbody[0];
            this.$tbody.delegate(nonSelectableRows, 'click', function (e) {
                if (this.parentNode == tbody)
                    grid.rowClick(e);
            })
            .delegate(nonSelectableRows, 'hover', function (e) {                
                if (this.parentNode == tbody) {                 
                    if(e.type == "mouseenter") {
                        $(this).addClass('t-state-hover');
                    } else {
                        $(this).removeClass('t-state-hover');
                    }
                }
            });
        }

        if (this.isAjax() || this.operationMode === "client") {
            this.$pager.delegate('.t-link:not(.t-state-disabled)', 'click', $t.stop(this.pagerClick, this));
            if (this.sort)
                this.$header.delegate('a.t-link', 'click', $t.stop(this.headerClick, this));
        }
        
        for (var i = 0; i < this.plugins.length; i++) {
            $t[this.plugins[i]].initialize(this);
        }

        $t.bind(this, {
            columnResize: this.onColumnResize,
            columnReorder: this.onColumnReorder,
            command: this.onCommand,
            complete: this.onComplete,
            'delete': this.onDelete,
            detailViewExpand: this.onDetailViewExpand,
            detailViewCollapse: this.onDetailViewCollapse,
            dataBinding: this.onDataBinding,
            dataBound: this.onDataBound,
            edit: this.onEdit,
            error: this.onError,
            load: this.onLoad,
            rowSelect: this.onRowSelect,
            rowDataBound: this.onRowDataBound,
            save: this.onSave,
            submitChanges: this.onSubmitChanges
        });

        this.initializeColumns(); 
                
        if(this.keyboardNavigation) {
            this.initializeNavigation();
        }

        if(this.isAjax() || this.operationMode === "client") {
            this._dataSource();
        } 
        
        if(this.columnContextMenu) {
            this.initializeContextMenu();
        }
    }    

    $t.grid.prototype = {
        initializeNavigation: function() {
            var that = this,
                element = $(that.element).attr("tabIndex", 0),
                KEYDOWN = "keydown",
                keyDownProxy = $.proxy(that._keyDown, that);                
            
            that._initNavigationMouseEvents();    
            element.bind({
                focus: function(e) {
                    var current = that.current();
                    if(current) {
                        current.addClass(FOCUSED);
                    } else if(current = that.$tbody.find("td." + FOCUSED).eq(0), current.length) {
                        that._current = current;
                    } else {
                        that.current(element.find(FIRST_CELL_SELECTOR));
                    }                    
                },
                focusin: function(e) {                    
                    var td = $(e.target).closest("td");                    
                    if (td.parent().hasClass("t-grid-new-row")) {
                        that.current(td);
                    }
                },
                focusout: function() {
                    if (that._current) {
                        that._current.removeClass(FOCUSED);
                    }
                },
                keydown: keyDownProxy
            });
                       
            if(that.editing && that.editing.mode == "PopUp") {
                element.bind("edit", function(e) {
                    $(e.form).bind(KEYDOWN, keyDownProxy);
                });
                
                $("#" + that.formId()+":visible").bind(KEYDOWN, keyDownProxy);
            }

            if(that.pageOnScroll) {
                element.bind("dataBinding", function() {
                    var current = that.current(),
                        rowIndex = current ? current.parent().index(ROWSELECTOR) - 1 : 0,
                        cellIndex = current ? current.index() : 0;
                    
                    element.one("dataBound", function () {                          
                        var rows = that.$tbody.find(ROWSELECTOR);
                        that._focusGridElement();                        
                        if(that._current) {
                            that._current.removeClass(FOCUSED);
                        }
                        that._current = rows.eq(rowIndex).children().eq(cellIndex).addClass(FOCUSED);
                    });
                });
            }
        },
        _onCommand: function(e) {
            if (e.row) {
                e.dataItem = this.dataItem(e.row);
            }
            return  $t.trigger(this.element, 'command', e);
        },
        _onComplete: function(e) {
            return  $t.trigger(this.element, 'complete', e);
        },
        _command: function(e) {
            var button = $(e.currentTarget);
            var grid = button.closest(".t-grid")[0];
            if (button.is(".t-ajax") && grid == this.element) {
                var name = /t-grid-([^\s]*)/.exec(button.attr("class"));
                
                if (name) {
                    name = name[1];
                }             
    
                var args = { 
                    name: name, 
                    row: button.closest("tr")[0] 
                };


                e.preventDefault();

                if(this._onCommand(args)) {
                    return;
                }

                $.ajax(this.ajaxOptions( {
                    url: button.attr("href"),
                    data: args.data || {},
                    success: $.proxy(function(data) {
                        try {
                            data = eval('(' + data + ')');
                        } catch (e) {
                            // in case the result is not JSON raise the 'error' event
                            if (!$t.ajaxError(this.element, 'error', xhr, 'parsererror'))
                                alert('Error! The requested URL did not return JSON.');
                            return;
                        }

                        this._onComplete({ name: name, response: data });
                    }, this) 
                }));
            }
        },

        _keyDown: function(e) {
            var that = this,
                element = $(that.element),
                tbody = that.$tbody,
                isRtl = element.closest('.t-rtl').length,
                key = e.keyCode,
                DATABOUND = "dataBound",
                currentProxy = $.proxy(that.current, that),
                current = currentProxy(),
                pageable = that.$pager.length > 0,
                clientSelect = that.selectable, 
                serverSelect = tbody.has("tr>td>.t-grid-select").length > 0,
                target = $(e.target),
                canHandle = !target.is(':button,a,:input,a>.t-icon'),
                editable = that.editRow,
                handled = false,
                cellIndex;
            
            if(!current) {
                if(that.editing && that.editing.mode == "PopUp") {
                    current = that._current = element.find(FIRST_CELL_SELECTOR);                    
                } else {
                    return;
                }
            }            
            cellIndex = current.index();
            if(!$.browser.msie) {
                canHandle = canHandle && target[0] === element[0];
            }

            if(canHandle) {
                if(pageable && keys.PAGEDOWN == key) {
                    if(!that.pageOnScroll) {
                        element.one(DATABOUND, function () {
                            currentProxy(element.find(FIRST_CELL_SELECTOR));
                            that._focusGridElement();
                        });
                    }
                    if(that.currentPage < that.totalPages()) {
                        that.pageTo(that.currentPage + 1);
                    }
                    handled = true;
                } else if(pageable && keys.PAGEUP == key) { 
                    if(!that.pageOnScroll) {
                        element.one(DATABOUND, function () {
                            currentProxy(element.find(FIRST_CELL_SELECTOR));
                            that._focusGridElement();
                        });
                        if(that.currentPage > 1) {
                            that.pageTo(Math.max(that.currentPage - 1, 1));
                        }
                    }
                    handled = true;
                } else if(keys.UP === key) {                    
                    currentProxy(current ? current.parent().prevAll(ROWSELECTOR).last().children(":eq(" + cellIndex + "),:eq(0)").last() : element.find(FIRST_CELL_SELECTOR));
                    handled = true;
                } else if(keys.DOWN === key) {
                    currentProxy(current ? current.parent().nextAll(ROWSELECTOR).first().children(":eq(" + cellIndex + "),:eq(0)").last() : element.find(FIRST_CELL_SELECTOR));
                    handled = true;                    
                } else if (keys.LEFT === key) {
                    if(current) {
                        if(isRtl) {
                            current = current.nextAll(":visible:first");
                        } else {
                            current = current.prevAll(":not(.t-group-cell, .t-hierarchy-cell):visible:first");
                        }
                    } else {
                        current = element.find(FIRST_CELL_SELECTOR);
                    }                    
                    currentProxy(current);
                    handled = true;
                } else if (keys.RIGHT === key) {
                    if(current) {
                        if(isRtl) {
                            current = current.prevAll(":not(.t-group-cell, .t-hierarchy-cell):visible:first");
                        } else {
                            current = current.nextAll(":visible:first");
                        }
                    } else {
                        current = element.find(FIRST_CELL_SELECTOR);
                    }
                    currentProxy(current);
                    handled = true;
                } else if((clientSelect || serverSelect) && keys.SPACEBAR == key) {
                    handled = true;
                    var elements = current.parent().find(".t-grid-select:first").andSelf();
                    if(serverSelect && elements[1]) {
                        location.href = elements[1].href;
                    } else if(clientSelect) {
                        elements.click();
                    }
                }
            }
            
            if(!handled && editable && !target.is(":button,a,a>.t-icon")) {
                handled = that._handleEditing(e);
            }
            
            if(handled) {
                e.preventDefault();
                e.stopPropagation();
            }            
        },
        _handleEditing: function(e) {
            var that = this,
                key = e.keyCode,
                shiftKey = e.shiftKey,
                nextCell,
                currentProxy = $.proxy(that.current, that),
                clearInputSelection = $.proxy(that._clearInputSelection, that),
                focusGridElement = $.proxy(that._focusGridElement, that),
                current = currentProxy(),                
                element = $(that.element),
                tbody = that.$tbody,
                row = current.parent(),
                rowIndex = row.index(),
                valid,
                handled = false,
                editCellSelector = "td.t-grid-edit-cell",
                firstInputSelector = ":input:visible:first",
                isAjax = that.isAjax(),                
                isInsert = row.closest("tr.t-grid-new-row")[0],
                isInCell = that.editing.mode === "InCell",
                isPopup = that.editing.mode === "PopUp",
                isEdited = row.closest("tr.t-grid-edit-row")[0] || (isPopup && $("#" + that.formId()+":visible").length);
            
            if(keys.ENTER == key || keys.F12 == key) {
                handled = true;                
                if(isEdited) {  
                    if ($(e.target).is("textarea")) {
                        handled = false;
                        return;
                    }
                                      
                    clearInputSelection(current.find(firstInputSelector)[0]);
                    if(isInCell) {
                        valid = that.validate();                        
                        if(!valid) { 
                            current.find(firstInputSelector).focus();
                            return;
                        }
                        if(current.is(editCellSelector)) {
                            that.saveCell(current[0]);
                        } else {                                                                                
                            row.find(editCellSelector)
                                .each(function() {
                                    that.saveCell(this);
                                });
                            that.editCell(current[0]);
                        }
                        if(that.valid) {
                            focusGridElement();                                       
                        } 
                    } else if(isAjax) {                        
                        element.one("dataBound", function () {
                            var grid = $(this).data("tGrid");
                            grid._current = grid.$tbody.children().eq(rowIndex).find(CELLSELECTOR).eq(0);
                            focusGridElement();
                        });
                        if(isPopup) {                            
                            $(".t-grid-update,.t-grid-insert","#" + that.formId()).click();
                        } else {
                            if(isInsert) {
                                that.insertRow(row);
                            } else {
                                that.updateRow(row);
                            }
                        }
                    } else {
                        if(that.validate()) {
                            if(isPopup) {
                                row = $("#" + that.formId());
                            }
                            row.find(".t-grid-update,.t-grid-insert").click();
                        }
                    }
                } else {                    
                    if(isInCell) {
                        tbody.find(editCellSelector)
                            .each(function() {
                                that.saveCell(this);
                            });
                        that.editCell(current[0]);
                    } else if(isAjax) {
                        that.editRow(row);
                        currentProxy(row.children().eq(0));
                        if(isPopup) {
                            row = $("#" + that.formId());
                        }
                        row.find(firstInputSelector).focus();                                                
                    } else {
                        location.href = row.find(".t-grid-edit:first").attr("href");
                    }
                }
            } else if (keys.ESC == key && isEdited) {
                handled = true;                
                clearInputSelection(current.find(firstInputSelector)[0]);
                if(isInCell && current.is(editCellSelector)) {
                    that.cancelCell(current);
                    focusGridElement();
                } else if(isAjax) {   
                    if(isPopup) {
                        $(".t-grid-cancel","#" + this.formId()).click();
                    } else {                 
                        that.cancelRow(row);
                    }
                    currentProxy(row.find(CELLSELECTOR).eq(0));
                    focusGridElement();
                } else {                    
                    if(isPopup) {
                        row = $("#" + that.formId());
                    }                    
                    location.href = row.find(".t-grid-cancel:first").attr("href");
                }
            } else if(isInCell && keys.TAB == key)  {               
                if(isEdited) {
                    clearInputSelection(current.find(firstInputSelector)[0]);
                    that.saveCell(current);                    
                    if(that.valid) {                    
                        focusGridElement();                        
                    } else {
                        current.find(firstInputSelector).focus();
                        return true;
                    }                    
                    handled = true;
                } 
                nextCell = shiftKey ? current.prevAll(":not(.t-group-cell, .t-hierarchy-cell):visible:first") : current.nextAll(":visible:first");
                if(!nextCell.length) {
                    nextCell = current.parent()[shiftKey ? "prevAll" : "nextAll"](ROWSELECTOR).children(shiftKey ? ":not(.t-group-cell, .t-hierarchy-cell):visible:last" : ":not(.t-group-cell, .t-hierarchy-cell):visible:first");
                }                
                currentProxy(nextCell);
                if(that.keyboardNavigation.editOnTab && nextCell.length) {                    
                    that.editCell(nextCell[0]);
                    setTimeout(function() { 
                        if (nextCell.hasClass("t-grid-edit-cell")) { 
                            nextCell.find(firstInputSelector).focus(); 
                        }
                    });
                    handled = true;
                }
            }

            return handled;
        },
        _initNavigationMouseEvents: function() {
            var that = this,
                tbody = that.$tbody,
                selector = ROWSELECTOR + CELLSELECTOR,
                browser = $.browser,
                CLICK = "click",
                DOWN = "mousedown",
                current,
                target,
                currentTarget,
                editRowClass = ".t-grid-edit-row",
                escapedSelector = ":button,a,:input,a>.t-icon";
            
            if(browser.msie) {
                tbody.delegate(selector, CLICK, function(e) { 
                    target = $(e.target),
                    currentTarget = $(e.currentTarget),
                    current = that._current;
                    
                    if(currentTarget.closest("tbody")[0] !== tbody[0]) {
                        return;
                    }
                    if (target.is(escapedSelector)) {
                        if(!(current && !currentTarget.parent().is(editRowClass))) {
                            if(current) {
                                current.removeClass(FOCUSED);
                            }
                            that._current = currentTarget;                            
                        }                                                
                    } else {                        
                        if(current && current[0] === currentTarget[0]) {
                            that._current = null;
                        }
                        that.current(currentTarget);
                        e.preventDefault();
                    }
                });
            } else {                
                tbody.delegate(selector, DOWN, function(e) {
                    target = $(e.target),
                    currentTarget = $(e.currentTarget),
                    current = that._current;

                    if(currentTarget.closest("tbody")[0] !== tbody[0]) {
                        return;
                    }
                    if (target.is(escapedSelector)) {                        
                        if(!(current && !currentTarget.parent().is(editRowClass))) {
                            if(current) {
                                current.removeClass(FOCUSED);
                            }
                            that._current = currentTarget;
                        }
                    } else {
                        that.current(currentTarget);
                    }                    
                });
            }
        },
        _clearInputSelection: function(input) {
            if(!input || $(input).is(":checkbox, :radio")) {
                return;
            }
            var browser = $.browser,
                range;
            if(browser.msie && parseInt(browser.version) == 8) {
                range = input.createTextRange();
                range.moveStart('textedit', 1);
                range.select();
            }
        },
        _focusGridElement: function() {
            var browser = $.browser;
            if(browser.msie && parseInt(browser.version) < 9) {
                $("body", document).focus();
            }
            this.element.focus();
        },
        current: function(element) {
            var that = this,
                current = that._current;                
            if(element !== undefined && element.length) {
                if (!current || current[0] !== element[0]) {
                    element.addClass(FOCUSED);                    
                    if (current) {
                        current.removeClass(FOCUSED);
                    }
                    that._current = element;
                    that._scrollTo(element.parent()[0]);
                }
            } else {
                return that._current;
            }
        },
        _scrollTo: function(element) {            
            var container = this.$tbody.closest("div.t-grid-content")[0];
            if(!element || !container) {
                return;
            }
            
            var elementOffsetTop = element.offsetTop,
                elementOffsetHeight = element.offsetHeight,                
                containerScrollTop = container.scrollTop,
                containerOffsetHeight = container.clientHeight,
                bottomDistance = elementOffsetTop + elementOffsetHeight;
                        
            container.scrollTop = containerScrollTop > elementOffsetTop
                                    ? elementOffsetTop
                                    : bottomDistance > (containerScrollTop + containerOffsetHeight)
                                    ? bottomDistance - containerOffsetHeight
                                    : containerScrollTop;        
        },
        _isRightScrollBar: function() {
            return $.browser.webkit || ($.browser.mozilla && parseInt($.browser.version, 10) < 2);
        },
        _transformParams: function(data) {
            var that = this, 
                remoteOperations = that._isServerOperation(),
                params = {},
                filter = that.filterBy || "",
                orderBy = that.orderBy || "";

            if (remoteOperations) {
                if(data["page"]) {
                    params[that.queryString.page] = data["page"];
                }

                if(data["pageSize"]) {
                    params[that.queryString.size] = data["pageSize"];                    
                }

                if(orderBy !== "") {
                    params[that.queryString.orderBy] = orderBy;
                }                                    

                if(filter !== "") {
                    params[that.queryString.filter] = filter;                                        
                }
                                    
                if(that.groupBy) {
                    params[that.queryString.groupBy] = that.groupBy;                                        
                }                   
                                                     
                if(data["aggregates"] && data["aggregates"].length) {
                    params["aggregates"] = $.map(that.columns, function(c) {
                        if (c.aggregates) {
                            return c.member + '-' + c.aggregates.join('-');
                        }
                    }).join('~')                                        
                }                
            }
            delete data["page"];
            delete data["pageSize"];
            delete data["sort"];
            delete data["filter"];
            delete data["group"];
            delete data["aggregates"];

            if (that.ws) {
                params =  $t.toJson($.extend(data, { state: params }));
            } else {
                params = $.extend(params, data);
            }

            return params;
        },
        _dataSourceOptions: function() {
            var that = this, 
                paging = this.pageSize > 0,
                options,
                data = that.data || [],
                remoteOperations = that._isServerOperation(),
                aggregates = $.map(that.columns || [], function(c) {
                    return $.map(c.aggregates || [], function(a) {
                        return { field: c.member, aggregate: a };
                    });
                }),
                deserializer = {
                    translateGroup: function(group) {                        
                        return { 
                            value: group.Key,
                            hasSubgroups: group.HasSubgroups,
                            aggregates: group.Aggregates,
                            items: group.HasSubgroups ? $.map(group.Items, $.proxy(this.translateGroup, this)) : group.Items
                        };
                    },
                    flatGroups: function(group) {
                        if(group.HasSubgroups) {
                            return this.flatGroups(group.Items);
                        }
                        return group.Items;
                    },
                    convert: function (data) {                        
                        return data.d || data;
                    },
                    mergeChanges: function(data, updated, deleted) {
                        var id,
                            idx,
                            length,
                            inserted = [],
                            found,
                            dataSource = that.dataSource;

                        $.each(deleted, function(index, id) {
                            for(idx = 0, length = data.length; idx < length; idx++){
                                if(id === dataSource.id(data[idx])) {
                                    data.splice(idx, 1);
                                    break;
                                }
                            }                                
                        });

                        $.each(updated, function(index, item) {
                            id = dataSource.id(this);
                            found = false;
                            for(idx = 0, length = data.length; idx < length; idx++) {
                                if(id === dataSource.id(data[idx])) {
                                    $.extend(true, data[idx], item); 
                                    found = true;                                       
                                    break;
                                }
                            }
                            if(!found) {
                                inserted.push(item);
                            }
                        });                            
                        return data.concat(inserted);
                    },
                    data: function(data) {
                        var dataSource = that.dataSource,
                            currentData = dataSource.data(),
                            pageIndex = dataSource.page() - 1,
                            pageSize = dataSource.pageSize(),
                            deleted = that.deletedIds || [];

                        that.deletedIds = [];
                        if(data) {
                            data = this.convert(data);                         
                            data = !$.isArray(data) ? data.data || data.Data : data;

                            if (currentData && currentData.length && !remoteOperations && dataSource.id) {
                                if(data.length && typeof data[0].HasSubgroups != 'undefined' && !remoteOperations) {
                                    data = $.map(data, $.proxy(this.flatGroups, this));
                                }
                                return this.mergeChanges(currentData, data, deleted);
                            }
                        }
                        return data;
                    },
                    total: function(data) {
                        if(data) {
                            data = this.convert(data);  
                            return !$.isArray(data) ? data.total || data.Total || 0 : data.length;
                        }
                        return 0;
                    },
                    groups: function(data) {
                        data = this.data(data);
                        return $.map(data, $.proxy(this.translateGroup, this));
                    },
                    aggregates: function(data) {
                        data = this.convert(data);
                        return data.aggregates || {};
                    }
                };
            
            options = {
                serverSorting: remoteOperations,
                serverPaging: remoteOperations,
                serverFiltering: remoteOperations,
                serverGrouping: remoteOperations,
                serverAggregates: remoteOperations,
                page: paging ? that.currentPage : undefined,
                pageSize: paging ? that.pageSize : undefined,
                aggregates: that.aggregates || aggregates,
                error: $.proxy(function (args) {
                    var xhr = args[0],
                        status = args[1];
                    if ($t.ajaxError(this.element, 'error', xhr, status))
                        return;
                }, this),
                //change: $.proxy(that._dataChange, that),
                group: $.map(that.groups || [], function(group) {
                    return { field: group.member, dir: group.order, aggregates: aggregates };
                }),
                sort: $.map(that.sorted, function(column) {
                    return { 
                        field: column.member,
                        dir: column.order
                    }
                }),
                filter: $.map($.grep(that.columns, function (column) {
                    return column.filters;
                }), function(column) {
                    return $.map(column.filters, function(filter) {
                        var value = filter.value;

                        if (column.type == "Number") {
                            value = parseFloat(value);
                        } else if (column.type == "Date") {                                                        
                            if (typeof value === "string") {
                                var date = /^\/Date\((.*?)\)\/$/.exec(value);
                                if (date) {
                                    value = new Date(parseInt(date[1]));
                                } else {
                                    var format = column.format ? /\{0(:([^\}]+))?\}/.exec(column.format)[2] : $t.cultureInfo.shortDate;
                                    value = $t.datetime.parse({ value: value, format: format }).toDate();
                                }
                            }
                        }
                        return {
                            field: column.member,
                            operator: filter.operator,
                            value: value                       
                        }; 
                    });
                })
            };

            if (remoteOperations || (that.isAjax() && !data.length)) {
                $.extend(options, {
                    transport: {
                        dialect: {
                            read: $.proxy(that._transformParams, this)
                        },
                        read: {
                            type: "POST",
                            //url: that.url("selectUrl"),
                            dataType: 'text', // using 'text' instead of 'json' because of DateTime serialization
                            dataFilter: function (data, dataType) {
                                // convert "\/Date(...)\/" to "new Date(...)"
                                data = eval('(' + data.replace(rdate, 'new Date($1)') + ')');
                                that._onComplete({ name: "dataBinding", response: data });
                                return data;
                            },
                            contentType: that.ws ? "application/json; charset=utf-8" : undefined,
                            complete: $.proxy(that.hideBusy, that)                   
                        }
                    },                   
                    deserializer: deserializer
                });
            } else if (data.length) {
                $.extend(options, {
                    data: {
                        data: that.data,
                        total: that.total || data.length
                    },
                    deserializer: deserializer
                });
            }
            return options;
        },
        _dataSource: function() {
            var that = this,
                options = that._dataSourceOptions(),
                data = options.data;

            that.dataSource = new $t.DataSource(options);            
           
            if (data && data.data) {
                that._convertInitialData(data.data);
            }

            that.dataSource.bind("change", $.proxy(that._dataChange, that));
        },

        _convertInitialData: function(data) {
            var that = this;

            if (!that._isServerOperation() && data && data.length) {
                that.dataSource.read();
                var view = that.dataSource.view();

                if (view.length && view[0].hasSubgroups != undefined) {
                    var result = [],
                        extractor = function(group) {
                            if (group.hasSubgroups) {
                                return extractor(group.items);
                            }
                            return group.items;
                        };

                    for (var i=0, len=view.length; i < len; i++) {
                        result = result.concat(extractor(view[i]));
                    }

                    that.data = result;
                } else {
                    that.data = view;
                }
            }
        },
        _mapAggregates: function(aggregates) {
            var result = {};
            for(var member in aggregates) {
                result[member.replace(/^\w/, function($0) { return $0.toUpperCase(); })] = aggregates[member];
            }
            return result;
        },
        rowClick: function (e) {
            var $target = $(e.target);
            if (!$target.is(':button,a,input,select,textarea,option,a>.t-icon')) {
                e.stopPropagation();
                var $row = $target.closest('tr')
                                  .addClass('t-state-selected')
                                  .siblings()
                                  .removeClass('t-state-selected')
                                  .end();
                $t.trigger(this.element, 'rowSelect', { row: $row[0] });
            }
        },

        $rows: function () {
            return this.$tbody.find('> tr:not(.t-grouping-row,.t-detail-row)');
        },

        expandRow: function (tr) {
            $(tr).find('> td .t-plus, > td .t-expand').click();
        },

        collapseRow: function (tr) {
            $(tr).find('> td .t-minus, > td .t-collapse').click();
        },

        headerClick: function (e) {
            e.preventDefault();
            this.toggleOrder(this.$columns().index($(e.target).closest('th')));
            this.sort(this.sortExpr());
        },

        refreshClick: function (e, element) {
            if ($(element).is('.t-loading'))
                return;

            if (this.isAjax()) {
                e.preventDefault();
                if(!this._isServerOperation()) {
                    this.dataSource.data([]);
                } 

                this.ajaxRequest();                
            }
        },

        sort: function (orderBy) {
            this.orderBy = orderBy;
            this.ajaxRequest();
        },
        
        columnFromTitle: function (title) {
            title = $.trim(title);
            
            var result = $.grep(this.$columns(), function(th) {
                return $.trim($(th).text()) == title;
            })[0];

            if (result)
                return this.columns[this.$columns().index(result)];

            return $.grep(this.columns, function (c) { return c.title == title; })[0];
        },

        columnFromMember: function (member) {
            var column = $.grep(this.columns, function (c) { return c.member == member })[0];

            if (!column)
                column = $.grep(this.columns, function (c) {
                    var suffix = "." + c.member;
                    return member.substr(member.length - suffix.length) == suffix
                })[0];

            return column;
        },

        toggleOrder: function (column) {
            column = typeof column == 'number' ? this.columns[column] : column;

            var order = 'asc';

            if (column.order == 'asc')
                order = 'desc';
            else if (column.order == 'desc')
                order = null;

            column.order = order;

            var sortedIndex = $.inArray(column, this.sorted);

            if (this.sortMode == 'single' && sortedIndex < 0) {
                $.each(this.sorted, function () {
                    this.order = null;
                });
                this.sorted = [];
            }
            if (sortedIndex < 0 && order)
                this.sorted.push(column);

            if (!order)
                this.sorted.splice(sortedIndex, 1);
        },

        sortExpr: function () {
            return $.map(this.sorted, function (s) { return s.member + '-' + s.order; }).join('~');
        },

        pagerKeyDown: function (e) {
            if (e.keyCode == 13) {
                var page = this.sanitizePage($(e.target).val());
                if (page != this.currentPage) {
                    this.pageTo(page);
                }
                else {
                    $(e.target).val(page);
                }
                e.preventDefault();
            }
        },

        isAjax: function () {
            return this.ajax || this.ws || this.onDataBinding;
        },

        url: function (which) {
            return (this.ajax || this.ws)[which];
        },

        pagerClick: function (e) {
            e.preventDefault();
            var $element = $(e.target).closest('.t-link');

            var page = this.currentPage;
            var pagerButton = $element.find('.t-icon');

            if (pagerButton.hasClass('t-arrow-next'))
                page++;
            else if (pagerButton.hasClass('t-arrow-last'))
                page = this.totalPages();
            else if (pagerButton.hasClass('t-arrow-prev'))
                page--;
            else if (pagerButton.hasClass('t-arrow-first'))
                page = 1;
            else {
                var linkText = $element.text();

                if (linkText == '...') {
                    var elementIndex = $element.parent().children().index($element);

                    if (elementIndex == 0)
                        page = parseInt($element.next().text()) - 1;
                    else
                        page = parseInt($element.prev().text()) + 1;
                } else {
                    page = parseInt(linkText);
                }
            }

            this.pageTo(isFinite(page) ? page : this.currentPage);
        },

        changePageSize: function (size) {            
            var result = parseInt(size, 10);
            if (isNaN(result) || result < 1) {
                return this.pageSize;
            }
        
            result = Math.max(result, 1);
            this.currentPage = 1;
            this.pageSize = result;

            if (this.isAjax()) {
                this.ajaxRequest();
            } else {
                this.serverRequest();            
            }
        },

        pageTo: function (page) {
            this.currentPage = page;
            if (this.isAjax())
                this.ajaxRequest();
            else
                this.serverRequest();
        },
        _dataChange: function() {
            var dataSource = this.dataSource;

            if (!this._clientBindingInProgress) {
                this.total = dataSource.total();
            }

            this.aggregates = dataSource.aggregates();
            var data = dataSource.view();      
                            
            if(this.pageOnScroll && this._pagingInProgress === true) {
                data = (this.data || []).concat(data);
                this._pagingInProgress = false;
            }
            this._current = null;

            this._populate(data);           
        },
        _populate: function(data) {
            this.data = [];
            this.bindTo(data);

            this.bindFooter();
            
            this.updatePager();
            this.updateSorting();
            $t.trigger(this.element, 'dataBound');
            $t.trigger(this.element, 'repaint'); 
        },
        ajaxOptions: function (options) {                        
            var result = {
                type: 'POST',
                dataType: 'text', // using 'text' instead of 'json' because of DateTime serialization
                dataFilter: function (data, dataType) {
                    // convert "\/Date(...)\/" to "new Date(...)"
                    return data.replace(rdate, 'new Date($1)');
                },
                error: $.proxy(function (xhr, status) {
                    if ($t.ajaxError(this.element, 'error', xhr, status))
                        return;
                }, this),

                complete: $.proxy(this.hideBusy, this),

                success: $.proxy(function (data, status, xhr) {
                    try {
                        data = eval('(' + data + ')');
                    } catch (e) {
                        // in case the result is not JSON raise the 'error' event
                        if (!$t.ajaxError(this.element, 'error', xhr, 'parsererror'))
                            alert('Error! The requested URL did not return JSON.');
                        return;
                    }

                    if (options.commandName) {
                        this._onComplete( { name: options.commandName, response: data } );
                    }

                    data = data.d || data; // Support the `d` returned by MS Web Services 

                    if (options.hasErrors && options.hasErrors(data)) {
                        if(!$t.trigger(this.element, 'error', {
                                XMLHttpRequest: xhr, 
                                textStatus: 'modelstateerror', 
                                modelState: data.modelState
                            })) {
                            options.displayErrors(data);
                        }
                        return;
                    }

                    this.dataSource.success(data);
                }, this)
            };
            $.extend(result, options);

            var state = this.ws ? result.data.state = {} : result.data;

            if (this._isServerOperation()) {
                state[this.queryString.page] = this.currentPage;
                state[this.queryString.size] = this.pageSize;
                state[this.queryString.groupBy] = this.groupBy;
                state[this.queryString.filter] = (this.filterBy || '').replace(/\"/g, '\\"');
            }            
            state[this.queryString.orderBy] = this.orderBy || '';                                    
            state[this.queryString.aggregates] = $.map(this.columns, function(c) {
                if (c.aggregates)
                    return c.member + '-' + c.aggregates.join('-');
            }).join('~');

            if (this.ws) {
                result.data = $t.toJson(result.data);
                result.contentType = 'application/json; charset=utf-8';
            }
            return result;
        },

        showBusy: function () {
            this.busyTimeout = setTimeout($.proxy(function () {
                $('> .t-grid-pager .t-status .t-icon', this.element).addClass('t-loading');
            }, this), 100);
        },

        hideBusy: function () {
            clearTimeout(this.busyTimeout);
            $('> .t-grid-pager .t-status .t-icon', this.element).removeClass('t-loading');
        },

        serverRequest: function () {
            if (this.operationMode === "client") {
                this.ajaxRequest();
            } else {
                location.href = $t.formatString(unescape(this.urlFormat),
                    this.currentPage, this.orderBy || '~', this.groupBy || '~', encodeURIComponent(this.filterBy) || '~', this.pageSize || '~');
            }
        },
        _isServerOperation: function() {
            return this.operationMode !== "client";
        },
        ajaxRequest: function (additionalData) {           
            var that = this,
                paging = that.pageSize > 0,
                pageSize = that.pageSize,                
                currentPage = that.currentPage,
                aggregates = $.map(that.columns, function(c) {
                    return $.map(c.aggregates || [], function(a) {
                        return { field: c.member, aggregate: a };
                    });
                });                
            
            if(currentPage > 1 && that.pageOnScroll && !that._pagingInProgress) {                
                pageSize = currentPage * that.pageSize;
                currentPage = 1;
            }

            var e = {
                page: currentPage,
                sortedColumns: that.sorted,
                filteredColumns: $.grep(that.columns, function (column) {
                    return column.filters;
                })
            };

            if ($t.trigger(that.element, 'dataBinding', e))
                return;

            if (!that.ajax && !that.ws && this.operationMode !== "client")
                return;

            if(that.dataSource.transport.options && that.dataSource.transport.options.read) {
                that.dataSource.transport.options.read.url = this.url('selectUrl');
            }

            if(that._isServerOperation()) {
                that.showBusy();                
            }            
            
            that.dataSource.query($.extend({
                page: currentPage,
                pageSize: paging ? pageSize : undefined,
                sort: $.map(that.sorted, function(column) {
                    return { 
                        field: column.member,
                        dir: column.order
                    }
                }),
                filter: $.map($.grep(that.columns, function (column) {
                    return column.filters;
                }), function(column) {
                    return $.map(column.filters, function(filter) {
                        var value = filter.value;

                         if (column.type == "Number") {
                            value = parseFloat(value);
                        } else if (column.type == "Date") {                                                        
                            if (typeof value === "string") {
                                var date = /^\/Date\((.*?)\)\/$/.exec(value);
                                if (date) {
                                    value = new Date(parseInt(date[1]));
                                } else {
                                    var format = column.format ? /\{0(:([^\}]+))?\}/.exec(column.format)[2] : $t.cultureInfo.shortDate;
                                    value = $t.datetime.parse({ value: value, format: format }).toDate();
                                }
                            }
                        }
                        return {
                            field: column.member,
                            operator: filter.operator,
                            value: value                       
                        }; 
                    });
                }),
                group: $.map(that.groups, function(group) {                    
                    return { field: group.member, dir: group.order, aggregates: aggregates };
                }),
                aggregates: aggregates                
            }, $.extend({}, e.data, additionalData)));
        },
        valueFor: function (column) {
            if (column.type == 'Date')                
                return new Function('data', 'var value = data.' + column.member +
                    '; if (!value) return null; return value instanceof Date? value : new Date(parseInt(value.replace(/\\/Date\\((.*?)\\)\\//, "$1")));');

            return new Function('data', 'return data' + (column.member ? '.' + column.member : '') + ';');
        },

        displayFor: function (column) {
            var localization = this.localization, grid = this;

            if (column.commands) {
                var builders = $.map(column.commands, function(command) {
                    return $t.grid.ButtonBuilder.create($.extend({text:localization[command.name]}, command));
                });

                return function(dataItem) {
                    return $.map(builders, function(builder) {
                        return builder.build($.extend({}, dataItem, {
                           __page: grid.currentPage,
                           __orderBy: grid.orderBy || "", 
                           __filter: grid.filterBy || "",
                           __groupBy: grid.groupBy || "" 
                        }));
                    }).join('');
                };
            }

            if (!column.template) {
                var result = column.value || function () { return "" };

                var getter = result = !column.data ? result : function(dataItem) {
                    var key = column.value(dataItem),
                        records = column.data,
                        value = "",
                        idx,
                        length;

                    for (idx = 0, length = records.length; idx < length; idx++) {
                        if (key == records[idx].Value) {
                            return records[idx].Text;
                        }
                    }            
                      
                    return value;   
                }

                if (column.format || column.type == 'Date')
                    result = function (data) {
                        var value = getter(data);
                        return value == null ? '' : $t.formatString(column.format || '{0:G}', value);
                    };

                return column.encoded === false ? result : function (data) { return encode(result(data)) };
            }

            return template(column.template);
        },
        
        insertFor: function(column) {
            return this.displayFor(column);
        },

        editFor: function(column) {
            return this.displayFor(column);
        },
        
        initializeColumns: function () {
            $.each(this.columns, $.proxy(function (_, column) {
                if (column.member !== undefined) {
                    column.value = this.valueFor(column);
                } else {
                    column.readonly = true;
                }
                
                column.insert = this.insertFor(column)
                column.edit = this.editFor(column);
                column.display = this.displayFor(column);
                
                if (column.footerTemplate)
                    column.footer = template(column.footerTemplate);
                
                if (column.groupFooterTemplate) {
                    this.showGroupFooter = true;
                    column.groupFooter = template(column.groupFooterTemplate);
                }
                
                column.groupHeader = template('<#= Title #>: <#= Key #>');
                
                if (column.groupHeaderTemplate)
                    column.groupHeader = template(column.groupHeaderTemplate);
            }, this));

            var j = this.columns.length - 1;
            while (j >= 0)
            {
                var col = this.columns[j];

                if (col.hidden) {
                    j--;
                    continue;
                }

                if (!col.attr) {
                    col.attr = ' class="t-last"';
                    break;
                } else if (col.attr.indexOf("class") == -1) {
                    col.attr += ' class="t-last"';
                    break;
                } else {
                    col.attr = col.attr.replace('class="', 'class="t-last ');
                    break;
                }
                j--;
            }

            if (this.detail)
                this.displayDetails = template(this.detail.template);
        },

        bindData: function (data, html, groups) {
            Array.prototype.push.apply(this.data, data);

            var dataLength = this.pageOnScroll ? data.length : Math.min(this.pageSize, data.length);
            var colspan = this.columns.length;

            dataLength = this.pageSize ? dataLength : data.length;

            /* fix for ie8 hidden columns in ajax binding becoming ghosts */
            if ($.browser.msie)
                $(this.element).find('.t-grid-content colgroup:first col').css('display', '');

            for (var rowIndex = 0; rowIndex < dataLength; rowIndex++) {
                var className = $.trim((this.detail ? 't-master-row' : '') + (rowIndex % 2 == 1 ? ' t-alt' : ''));

                if (className)
                    html.cat('<tr class="')
                        .cat(className)
                        .cat('">')
                else
                    html.cat('<tr>');

                html.rep('<td class="t-group-cell"></td>', groups)
                    .catIf('<td class="t-hierarchy-cell"><a class="t-icon t-plus" href="#" /></td>', this.detail);

                if (this.rowTemplate) {
                    html.cat('<td colspan="')
                    .cat(colspan)
                    .cat('">')
                    .cat(this.rowTemplate(data[rowIndex]))
                    .cat("</td>");
                } else { 
                    for (var i = 0, len = this.columns.length; i < len; i++) {
                        var column = this.columns[i];
                       
                        html.cat('<td')
                            .cat(column.attr)
                            .cat('>')
                            .cat(column.display(data[rowIndex]));
    
                        html.cat('</td>');
                    }
                }

                html.cat('</tr>');
            }
        },

        normalizeColumns: function () {
            // empty - overridden in telerik.grid.grouping.js
        },

        dataItem: function (tr) {
            return (this.data||[])[this.$tbody.find('> tr:not(.t-grouping-row,.t-detail-row,.t-grid-new-row,.t-group-footer)').index($(tr))];
        },

        _colspan: function() {
            return this.groups.length + $.grep(this.columns, function(column) { return !column.hidden; }).length + (this.detail ? 1 : 0);
        }, 
        bindTo: function (data) {                    
            var html = new $t.stringBuilder();
            var colspan = this._colspan();

            if (data && data.length) {

                this.normalizeColumns(colspan);
                if (typeof data[0].hasSubgroups != 'undefined')
                    for (var i = 0, l = data.length; i < l; i++)
                        this.bindGroup(data[i], colspan, html, 0);
                else
                    this.bindData(data, html);
            }
            else
                html.cat("<tr class='t-no-data'>")
                    .cat("<td colspan='")
                    .cat(colspan)
                    .cat("'>")
                    .cat(this.noRecordsTemplate ? this.noRecordsTemplate : this.localization.noRecords)
                    .cat('</td></tr>');

            this.$tbody.html(html.string());

            if (this.onRowDataBound) {

                var rows = jQuery.grep(this.$tbody[0].rows, function (row) {
                    return !$(row).is('.t-grouping-row, .t-group-footer, .t-footer-template')
                });

                for (var i = 0, l = this.data.length; i < l; i++)
                    $t.trigger(this.element, 'rowDataBound', { row: rows[i], dataItem: this.data[i] });
            }
        },

        updatePager: function () {
            var totalPages = this.totalPages(this.total);
            var currentPage = this.currentPage;
            var pageSize = this.pageSize;

            // nextPrevious
            // work-around for weird issue in IE, when using comma-based selector
            this.$pager.find('.t-arrow-next').parent().add(this.$pager.find('.t-arrow-last').parent())
	            .toggleClass('t-state-disabled', currentPage >= totalPages)
	            .removeClass('t-state-hover');

            this.$pager.find('.t-arrow-prev').parent().add(this.$pager.find('.t-arrow-first').parent())
	            .toggleClass('t-state-disabled', currentPage == 1)
	            .removeClass('t-state-hover');

            var localization = this.localization;
            // pageInput
            this.$pager.find('.t-page-i-of-n').each(function () {
                this.innerHTML = new $t.stringBuilder()
                                       .cat(localization.page)
                                       .cat('<input type="text" value="')
                                       .cat(currentPage)
                                       .cat('" /> ')
                                       .cat($t.formatString(localization.pageOf, totalPages))
                                       .string();
            });

            this.$pager.find('.t-page-size').each(function () {
                var html = '<div style="width: 50px;" class="t-dropdown t-header">' +
                         '<div class="t-dropdown-wrap t-state-default"><span class="t-input">' + pageSize + '</span>' + 
                                '<span class="t-select"><span class="t-icon t-arrow-down">select</span></span>' + 
                             '</div>' + 
                           '</div>';
                this.innerHTML = html;
            });

            // numeric
            this.$pager.find('.t-numeric').each($.proxy(function (index, element) {
                this.numericPager(element, currentPage, totalPages);
            }, this));

            // status
            this.$pager.parent()
                       .find('.t-status-text')
                       .text($t.formatString(localization.displayingItems,
                            this.firstItemInPage(),
	                        this.lastItemInPage(),
	                        this.total));
        },

        numericPager: function (pagerElement, currentPage, totalPages) {
            var numericLinkSize = 10;
            var numericStart = 1;

            if (currentPage > numericLinkSize) {
                var reminder = (currentPage % numericLinkSize);

                numericStart = (reminder == 0) ? (currentPage - numericLinkSize) + 1 : (currentPage - reminder) + 1;
            }

            var numericEnd = (numericStart + numericLinkSize) - 1;

            numericEnd = Math.min(numericEnd, totalPages);

            var pagerHtml = new $t.stringBuilder();
            if (numericStart > 1)
                pagerHtml.cat('<a class="t-link">...</a>');

            for (var page = numericStart; page <= numericEnd; page++) {
                if (page == currentPage) {
                    pagerHtml.cat('<span class="t-state-active">')
                        .cat(page)
                        .cat('</span>');
                } else {
                    pagerHtml.cat('<a class="t-link">')
	                .cat(page)
	                .cat('</a>');
                }
            }

            if (numericEnd < totalPages)
                pagerHtml.cat('<a class="t-link">...</a>');

            pagerElement.innerHTML = pagerHtml.string();
        },

        $columns: function () {
            return this.$header.find('th:not(.t-hierarchy-cell,.t-group-cell)');
        },

        updateSorting: function () {
            this.sorted = [];
            $.each(this.orderBy.split('~'), $.proxy(function (_, expr) {
                var memberAndOrder = expr.split('-');
                var column = this.columnFromMember(memberAndOrder[0]);
                if (column) {
                    column.order = memberAndOrder[1];
                    this.sorted.push(column);
                }
            }, this));

            this.$columns().each($.proxy(function (i, header) {
                var direction = this.columns[i].order;
                var $link = $(header).children('a.t-link');
                var $icon = $link.children('.t-icon');

                if (!direction) {
                    $icon.hide();
                } else {
                    if ($icon.length == 0)
                        $icon = $('<span class="t-icon"/>').appendTo($link);

                    $icon.toggleClass('t-arrow-up', direction == 'asc')
                        .toggleClass('t-arrow-down', direction == 'desc')
                        .html('(' + (direction == 'asc' ? this.localization.sortedAsc : this.localization.sortedDesc) + ')')
                        .show();
                }
            }, this));
        },

        sanitizePage: function (value) {
            var result = parseInt(value, 10);
            if (isNaN(result) || result < 1)
                return this.currentPage;
            return Math.min(result, this.totalPages());
        },

        totalPages: function () {
            return Math.ceil(this.total / this.pageSize);
        },

        firstItemInPage: function () {
            var that = this;
            return that.total > 0 
                    ? that.pageOnScroll 
                        ? 1 
                        : (that.currentPage - 1) * that.pageSize + 1 
                    : 0;
        },

        lastItemInPage: function () {
            return Math.min(this.currentPage * this.pageSize, this.total);
        },

        dataBind: function (data) {
            var that = this;
            if (!that.dataSource) {
                that._dataSource();
            } else if (data && data.length) {
                that.dataSource._group = $.map(that.groups, function(group) {                    
                    return { field: group.member, dir: group.order, aggregates: that.aggregates };
                });
            }            

            that._clientBindingInProgress = true;
            try{
                that.dataSource.success(data || []);
            } finally {
                that._clientBindingInProgress = false;
            }
        },
        
        bindFooter: function() {
            var that = this, 
                $footerCells = that.$footer.find('td:not(.t-group-cell,.t-hierarchy-cell)'),
                aggregates = that.aggregates,
                defaultAggregate = { Sum: 0, Count: 0, Average: 0, Max: 0, Min: 0 };
            
            $.each(that.columns, function(index) {
                if (this.footer) {
                    $footerCells.eq(index).html(this.footer(that._mapAggregates(aggregates[this.member] || defaultAggregate)));
                }
            });
        },

        rebind: function (args) {
            var that = this;

            that.sorted = [];
            that.orderBy = '';
            that.filterBy = '';
            that.currentPage = 1;
            that.groupBy = '';
            that.groups = [];

            if (that.clearHeader) {
                that.clearHeader();
            }

            $.each(that.columns, function () {
                this.order = null;
                this.filters = null;
            });

            $('.t-filter-options', that.element)
                .find('input[type="text"], select')
                .val('')
                .removeClass('t-state-error')
                .end()
                .find('div.t-formatted-value')
                .html('');

            $('.t-grid-filter', that.element)
                .removeClass('t-active-filter');
            
            if (this.isAjax()) {
                that.data = [];
            }

            if (!that._isServerOperation()) {                
                that._dataSource();                
            } 

            that.ajaxRequest(args);
        },

        hideColumn: function(column) {
            var that = this,
                columns = that.columns,
                columnIndex,
                cols,
                width,
                rows = that.$tbody.children("tr"),
                length, 
                row, 
                cell,
                idx,                
                tableWidth = 0,
                browser = $.browser,
                isIE8 = browser.msie && parseInt(browser.version) === 8,
                tables,
                attr,
                editMode = that.editing.mode;

            if (typeof column === "number") {                
                column = columns[column];
            } else {
                column = that.columnFromMember(column);                
            }

            columnIndex = $.inArray(column, $.grep(columns, function(col) { return !col.hidden; }));

            if(columnIndex < 0 || !column) {
                return;
            }            

            cols = $("col:not(.t-group-col,.t-hierarchy-col)", that.$header.parent().prev());
            if(that.scrollable) {
                cols.eq(columnIndex).remove();
                cols = $("col:not(.t-group-col,.t-hierarchy-col)", that.$tbody.prev());
            }
            width = cols.eq(columnIndex).remove()[0].style.width;

            that.$columns().filter(":visible").eq(columnIndex).hide();
            that.$footer.find("td:not(.t-group-cell):visible").eq(columnIndex).hide();

            for(idx = 0, length = rows.length ; idx < length; idx++) {
                row = rows.eq(idx);
                if(row.is(".t-grouping-row,.t-detail-row")) {
                    cell = row.children(":not(.t-group-cell):first,.t-detail-cell").last();
                    cell.attr("colspan", parseInt(cell.attr("colspan"), 10) - 1);
                } else {
                    if(row.hasClass("t-grid-edit-row")) {
                        if(editMode === "InLine" && !that.isAjax()) {
                            cell = row.children(".t-edit-container");
                            cell.attr("colspan", parseInt(cell.attr("colspan"), 10) - 1);
                            cell.find("col").eq(columnIndex).remove();
                            row = cell.find("tr:first");
                        } else if(editMode === "InForm") {
                            cell = row.children().first();
                            cell.attr("colspan", parseInt(cell.attr("colspan"), 10) - 1);
                            continue;
                        }
                    }
                    row.children("td:not(.t-group-cell,.t-hierarchy-cell):visible").eq(columnIndex).hide();
                }
            }
           
            for(idx= 0, length = cols.length; idx < length; idx++) {
                if(idx != columnIndex) {
                    if(cols[idx].style.width) {
                        tableWidth += parseInt(cols[idx].style.width);
                    } else {
                        tableWidth = 0;
                        break;
                    }
                }
            }        

            tables = $(">table,>.t-grid-header table,>.t-grid-content>table", that.element);
            if(tableWidth) {            
                tables.width(tableWidth);                
            }
            
            if(isIE8) {
                tables.css("display", "inline-table");              
                setTimeout(function() { 
                    tables.css("display", "table");
                }, 1);
            }

            column.hidden = true;
            column.width = width;
            
            attr = column.attr;
            if(!attr || attr.indexOf("style") < 0) {
                attr = (attr || "") + ' style="display:none" ';
            } else {
                attr = column.attr.replace(/(style="(.*)?display):([^;]*)/i, "$1:none");
                if(attr === column.attr) {
                    attr = attr.replace(/(style=")/i, "$1display:none;");
                }
            }                        
            column.attr = attr;

            $t.trigger(that.element, "repaint");
        },

        showColumn: function(column) {
            var that = this,
                columnIndex,
                columns = that.columns,
                cols,               
                rows = that.$tbody.children("tr"),
                tables = $(">table,>.t-grid-header table,>.t-grid-content>table", that.element),
                row,
                cell,
                idx,
                length;

            if (typeof column === "number") {                
                column = columns[column];
            } else {
                column = that.columnFromMember(column);                
            }

            columnIndex = $.inArray(column, columns);

            if(!column || !column.hidden) {
                return;
            }
            
            cols = $("col:not(.t-group-col,.t-hierarchy-col)", that.$header.parent().prev());

            normalizeCols(cols, columns, columnIndex);
            if(that.scrollable) {
                cols = $("col:not(.t-group-col,.t-hierarchy-col)", that.$tbody.prev());
                normalizeCols(cols, columns, columnIndex);
            }

            that.$columns().eq(columnIndex).show();
            that.$footer.find("td:not(.t-group-cell)").eq(columnIndex).show();

            for(idx = 0, length = rows.length ; idx < length; idx++) {
                row = rows.eq(idx);
                if(row.is(".t-grouping-row,.t-detail-row")) {
                    cell = row.children(":not(.t-group-cell):first,.t-detail-cell").last();
                    cell.attr("colspan", parseInt(cell.attr("colspan"), 10) + 1);
                } else {
                    if(row.hasClass("t-grid-edit-row")) {
                        if(that.editing.mode === "InLine" && !that.isAjax()) {
                            cell = row.children(".t-edit-container");
                            cell.attr("colspan", parseInt(cell.attr("colspan"), 10) + 1); 
                            normalizeCols(cell.find(">form>table>colgroup>col"), columns, columnIndex);
                            row = cell.find("tr:first");
                        } else if(that.editing.mode === "InForm") {
                            cell = row.children().first();
                            cell.attr("colspan", parseInt(cell.attr("colspan"), 10) + 1);
                            continue;
                        }
                    }                    
                    row.children("td:not(.t-group-cell,.t-hierarchy-cell)").eq(columnIndex).show();
                }
            }
            
            if(!column.width) {
                tables.width("");
            } else {
                var tableWidth = parseInt(column.width, 10);
                for(idx= 0, length = cols.length; idx < length; idx++) {                                           
                    tableWidth += parseInt(cols[idx].style.width, 10);                    
                }        
                                          
                tables.width(tableWidth);                                
            }

            column.hidden = false;
            delete column.width; 
            if(column.attr) {           
                column.attr = column.attr.replace(/(style="(.*)?)(display\s*:\s*none)\s*;?/i, "$1");
            }

            $t.trigger(that.element, "repaint");
        },

        initializeContextMenu: function() {
            var that = this,
                html,
                fx = $t.fx.slide.defaults(),
                columns = $.grep(that.columns, function(col) { return col.title !== "" && col.includeInContextMenu !== false }),
                id = that.element.id + "_contextMenu",
                menu, checkboxes;

            $(document).bind("mouseup", function(e) {                
                if(menu && e.which != 3 && $(e.target).closest("#" + id).length == 0) {
                    $t.fx.rewind(fx, menu.find(".t-group"), { direction: 'bottom' }, function() { menu.remove(); });                    
                }
            });

            that.$header.closest(".t-grid-header").bind("contextmenu", function(e) {
                if(menu && menu.is(":visible")) {
                    $t.fx.rewind(fx, menu.find(".t-group"), { direction: "bottom" });
                    menu.remove();
                }

                html = new $t.stringBuilder();
                html.cat('<div class="t-animation-container t-menu t-menu-context" id="' + id + '" style="display:none">')
                .cat('<ul class="t-group">');
                $.each(columns, function() {
                    html.cat('<li class="t-item"><label class="t-link">')
                        .cat('<input type="checkbox" data-field="' + $.inArray(this, that.columns) +'"')
                        .catIf(' checked="checked"', !this.hidden)                    
                        .cat("/>")
                        .cat(this.title)
                        .cat("</label></li>");
                });
                html.cat("</ul></div>");

                menu = $(html.string())
                        .delegate("[type=checkbox]", "change", function() {                        
                            var checkbox = $(this),
                                enabledCheckboxes;
                            that[checkbox.is(":checked") ? "showColumn" : "hideColumn"](checkbox.data("field"));

                            enabledCheckboxes = menu.find(":checked");
                            enabledCheckboxes.attr("disabled", enabledCheckboxes.length == 1);
                        })                        
                        .appendTo(document.body);

                checkboxes = menu.find(":checked");
                checkboxes.attr("disabled", checkboxes.length == 1);

                menu.css({ 
                    left: e.clientX + $(document).scrollLeft(),
                    top: e.clientY + $(document).scrollTop()
                });                

                $t.fx.play(fx, menu.find(".t-group"), { direction: "bottom" });
                return false;
            });
        }
    }
    
    $t.grid.ButtonBuilder = function (button) {
        var attr = $t.splitClassesFromAttr(button.attr);

        this.classNames = ['t-button'];

        var className = attr.classes;

        if (className) {
            this.classNames.push(className);
            button.attr = attr.attributes;
        }

        if (button.name) {
            this.classNames.push("t-grid-" + button.name);
        }

        if (button.ajax) {
            this.classNames.push("t-ajax");
        }

        this.url = button.url ? template(unescape(button.url)) : function() { return "#" };
        
        this.content = function () {
            return button.text || "";
        }

        this.build = function(dataItem) {
            return '<a href="' + this.url(dataItem) + '" class="' + this.classNames.join(' ') +  '" ' + (button.attr || '') + '>' +
                        this.content() +
                   '</a>';
        }
    }

       
    $t.grid.ButtonBuilder.create = function(button) {        
        return new (buttonBuilderTypes[button.buttonType])(button);    
    }

    function sprite(name, imageAttr) {
        var attr = $t.splitClassesFromAttr(imageAttr),
            classes = attr.classes,
            otherAttr = attr.attributes;

        classes = classes ? ' ' + classes : '';

        return '<span class="t-icon t-' + name + classes + '"' + (otherAttr ? otherAttr : '') + '>' + '</span>'
    }

    $t.grid.ImageButtonBuilder = function (button) {
        $t.grid.ButtonBuilder.call(this, button);
        
        this.classNames.push('t-button-icon');
         
        this.content = function() {
            return sprite(button.name, button.imageAttr);
        }
    }    
    
    $t.grid.ImageTextButtonBuilder = function (button) {
        $t.grid.ButtonBuilder.call(this, button);
        
        this.classNames.push('t-button-icontext');
        
        this.content = function() {
            return sprite(button.name, button.imageAttr) + button.text;
        }
    }    
    
    $t.grid.BareImageButtonBuilder = function (button, localization) {
        $t.grid.ImageButtonBuilder.call(this, button, localization);
        this.classNames.push('t-button-icon', 't-button-bare');
    }
 
    var buttonBuilderTypes = {
        Text: $t.grid.ButtonBuilder,
        ImageAndText: $t.grid.ImageTextButtonBuilder,
        Image: $t.grid.ImageButtonBuilder,
        BareImage: $t.grid.BareImageButtonBuilder
    };

    $.fn.tGrid = function (options) {
        return $t.create(this, {
            name: 'tGrid',
            init: function (element, options) {
                return new $t.grid(element, options);
            },
            options: options,
            success: function (grid) {
                if (grid.$tbody.find('tr.t-no-data').length)
                    grid.ajaxRequest();
            }
        });
    }

    // default options

    $.fn.tGrid.defaults = {
        columns: [],
        plugins: [],
        currentPage: 1,
        pageSize: 10,
        localization: {
            addNew: 'Add new record',
            'delete': 'Delete',
            cancel: 'Cancel',
            insert: 'Insert',
            update: 'Update',
            select: 'Select',
            pageOf: 'of {0}',
            displayingItems: 'Displaying items {0} - {1} of {2}',
            edit: 'Edit',
            noRecords: 'No records to display.',
            page: 'Page ',
            filter: 'Filter',
            filterClear: 'Clear Filter',
            filterShowRows: 'Show rows with value that',
            filterAnd: 'And',
            filterStringEq: 'Is equal to',
            filterStringNe: 'Is not equal to',
            filterStringStartsWith: 'Starts with',
            filterStringSubstringOf: 'Contains',
            filterStringEndsWith: 'Ends with',
            filterNumberEq: 'Is equal to',
            filterNumberNe: 'Is not equal to',
            filterNumberLt: 'Is less than',
            filterNumberLe: 'Is less than or equal to',
            filterNumberGt: 'Is greater than',
            filterNumberGe: 'Is greater than or equal to',
            filterDateEq: 'Is equal to',
            filterDateNe: 'Is not equal to',
            filterDateLt: 'Is before',
            filterDateLe: 'Is before or equal to',
            filterDateGt: 'Is after',
            filterDateGe: 'Is after or equal to',
            filterEnumEq: 'Is equal to',
            filterEnumNe: 'Is not equal to',
            filterForeignKeyEq: 'Is equal to',
            filterForeignKeyNe: 'Is not equal to',
            filterBoolIsTrue: 'is true',
            filterBoolIsFalse: 'is false',
            filterSelectValue: '-Select value-',
            filterOpenPopupHint: 'Open the calendar popup',
            groupHint: 'Drag a column header and drop it here to group by that column',
            deleteConfirmation: 'Are you sure you want to delete this record?',
            sortedAsc: 'sorted ascending',
            sortedDesc: 'sorted descending',
            ungroup: 'ungroup'
        },
        queryString: {
            page: 'page',
            size: 'size',
            orderBy: 'orderBy',
            groupBy: 'groupBy',
            filter: 'filter',
            aggregates: 'aggregates'
        }
    };
})(jQuery);
(function ($) {
    var $t = $.telerik;

    var dropCueOffsetTop = 3;
    var dropCueOffsetLeft = 0;

    $t.scripts.push("telerik.grid.grouping.js");

    $t.grouping = {};

    function groupItem(container, title)
    {
        return container
            .find("div")
            .filter(function() {
                var div = $(this);
                if(div.children(".t-link").contents()
                    .filter(function() { 
                        if($(this).text() === title) {
                            return $(this);
                        } 
                }).length) {
                    return $(this);
                }
            });
    }

    $t.grouping.initialize = function (grid) {
        $.extend(grid, $t.grouping.implementation);

        grid.$groupDropCue = $('<div class="t-grouping-dropclue"/>');
        grid.$groupHeader = $('> .t-grouping-header', grid.element);
        
        function groups() {
            var all = $.map(grid.$groupHeader.find('.t-group-indicator'), function (group) {
                var $group = $(group);
                var left = $group.offset().left;
                var width = $group.outerWidth();
                return { left: left, right: left + width, width: width, $group: $group };
            });

            return {
                first: all[0],
                all: all,
                last: all[all.length - 1]
            };
        }

        function drag(e) {
            var title = e.$cue.text(),
                target = $t.eventTarget(e),
                location = $t.touchLocation(e);
            
            if (!$.contains(grid.element, target)
                || !$(target).closest('.t-grouping-header').length
                || (grid.groupFromTitle(title) && e.$draggable.closest('.t-header').length)) {
                grid.$groupDropCue.remove();
                return;
            }

            var $grid = $(grid.element),
                $toolbar = $grid.find('> .t-grid-toolbar'),
                top = $toolbar.outerHeight() + dropCueOffsetTop,
                state = groups(),
                isRtl = $grid.closest('.t-rtl').length;
                
            if (!state.all.length) {
                var left = isRtl ? $toolbar.width() - dropCueOffsetLeft : dropCueOffsetLeft;

                grid.$groupDropCue.css({ top: top, left: left }).appendTo(grid.$groupHeader);

                return;
            }

            var firstGroupIndicator = state.first;
            var lastGroupIndicator = state.last;
            var leftMargin = parseInt(firstGroupIndicator.$group.css('marginLeft'));
            var rightMargin = parseInt(firstGroupIndicator.$group.css('marginRight'));

            var currentGroupIndicator = $.grep(state.all, function (g) {
                return location.x >= g.left - leftMargin - rightMargin && location.x <= g.right;
            })[0];

            if (!currentGroupIndicator && firstGroupIndicator) {
                if (!isRtl && location.x < firstGroupIndicator.left) {
                    currentGroupIndicator = firstGroupIndicator;
                } else if (isRtl && location.x < lastGroupIndicator.left) {
                    currentGroupIndicator = lastGroupIndicator;
                }
            }

            if (isRtl) {
                if (currentGroupIndicator) {
                    grid.$groupDropCue.css({ top: top, left: currentGroupIndicator.$group.position().left - leftMargin + dropCueOffsetLeft })
                        .insertAfter(currentGroupIndicator.$group);
                } else {
                    grid.$groupDropCue.css({ top: top, left: $toolbar.width() - dropCueOffsetLeft })
                        .prependTo(grid.$groupHeader);
                }
            } else {
                if (currentGroupIndicator) {
                    grid.$groupDropCue.css({ top: top, left: currentGroupIndicator.$group.position().left - leftMargin + dropCueOffsetLeft })
                        .insertBefore(currentGroupIndicator.$group);
                } else {
                    grid.$groupDropCue.css({ top: top, left: lastGroupIndicator.$group.position().left + lastGroupIndicator.$group.outerWidth() + rightMargin + dropCueOffsetLeft })
                        .appendTo(grid.$groupHeader);
                }
            }
        }

        function cue(e) {
            if (e.$draggable.hasClass('t-header')) {
                var column = grid.columnFromTitle(e.$draggable.text());
                return $t.dragCue(column ? column.title : "");
            } else {
                // remove icons' hidden accessibility content first
                var groupButtonLink = $('.t-link', e.$draggable);
                var columnTitle = groupButtonLink.text().substr($('.t-icon', groupButtonLink).text().length);
                var column = grid.columnFromTitle(columnTitle);
                return $t.dragCue(column ? column.title : columnTitle);
            }
        }
        
        function stop(e) {
            var title = e.$cue.text();
            
            grid.$groupDropCue.remove();

            if (e.$draggable.is('.t-group-indicator') && e.keyCode != 27) {
                grid.unGroup(title);
                return false;
            }
        }

        function destroy(e) {
            e.$cue.remove();
        }
        if (grid.$groupHeader.length) {
        new $t.draggable({
            owner: grid.$header,
            selector: '.t-header:not(.t-group-cell,.t-hierarchy-cell)',
            scope: grid.element.id + '-grouping',
            cue: cue,
            start: function(e) {
                var column = grid.columnFromTitle(e.$draggable.text());
                return !!column.member && column.groupable !== false;
            },
            stop: stop,
            drag: drag,
            destroy: destroy
        });
        
        new $t.draggable({
            owner: grid.$groupHeader,
            selector: '.t-group-indicator',
            scope: grid.element.id + '-grouping',
            cue: cue,
            stop: stop,
            drag: drag,
            destroy: destroy
        });        
        
        new $t.droppable({
            owner: grid.element,
            selector: '.t-grouping-header',
            scope: grid.element.id + '-grouping',
            over: function(e) {
                $t.dragCueStatus(e.$cue, 't-add');
            },
            out: function(e) {
                $t.dragCueStatus(e.$cue, 't-denied');
            },
            drop: function(e) {
                var title = e.$cue.text();
                var group = grid.groupFromTitle(title);

                var groupIndex = $.inArray(group, grid.groups);
                
                var position = grid.$groupHeader.find('div').index(grid.$groupDropCue);
                var delta = groupIndex - position;

                if (!group || (grid.$groupDropCue.is(':visible') && delta != 0 && delta != -1))
                    grid.group(title, position);
                 
                grid.$groupDropCue.remove();
            }
        });
        }
        if (grid.isAjax()) {
            grid.$groupHeader
                .delegate('.t-button', $t.isTouch ? 'touchend' : 'click', function (e) {
                    e.preventDefault();
                    var groupButtonLink = $(this).parent().find('.t-link');
                    var columnTitle = groupButtonLink.text().substr($('.t-icon', groupButtonLink).text().length);
                    grid.unGroup(columnTitle);
                })
                .delegate('.t-link', $t.isTouch ? 'touchend' : 'click', function (e) {
                    e.preventDefault();
                    var groupButtonLink = $(this);
                    var columnTitle = groupButtonLink.text().substr($('.t-icon', groupButtonLink).text().length);
                    var group = grid.groupFromTitle(columnTitle);
                    group.order = group.order == 'asc' ? 'desc' : 'asc';
                    grid.group(group.title);
                });
        }

        grid.$groupHeader.delegate('.t-group-indicator', 'mouseenter', function () {
                grid.$currentGroupItem = $(this);
            })
            .delegate('.t-group-indicator', 'mouseleave', function () {
                grid.$currentGroupItem = null;
            });

        grid.$tbody.delegate('.t-grouping-row .t-collapse, .t-grouping-row .t-expand', 'click', $t.stop(function (e) {
            e.preventDefault();
            var $this = $(this), $tr = $this.closest('tr');
            if ($this.hasClass('t-collapse'))
                grid.collapseGroup($tr);
            else
                grid.expandGroup($tr);
        }));

        grid.groupFromTitle = function (title) {
            return $.grep(grid.groups, function (g) { return g.title == title; })[0];
        };

        grid.expandGroup = function (group) {
            var $group = $(group);
            var depth = $group.find('.t-group-cell').length;
            
            $group.nextAll('tr').each(function (i, tr) {
                var $tr = $(tr);
                var offset = $tr.find('.t-group-cell').length;
                if (offset <= depth)
                    return false;

                if (offset == depth + 1 && !$tr.hasClass('t-detail-row')) {
                    $tr.show();

                    if ($tr.hasClass('t-grouping-row') && $tr.find('.t-icon').hasClass('t-collapse'))
                        grid.expandGroup($tr);
                    if ($tr.hasClass('t-master-row') && $tr.find('.t-icon').hasClass('t-minus'))
                        $tr.next().show();
                }
            });

            $group.find('.t-icon').addClass('t-collapse').removeClass('t-expand');
        };

        grid.collapseGroup = function (group) {
            var $group = $(group),
                depth = $group.find('.t-group-cell').length,
                footerCount = 1;

            $group.nextAll('tr').each(function () {
                var $tr = $(this),
                    offset = $tr.find('.t-group-cell').length;

                if ($tr.hasClass("t-grouping-row")) {
                    footerCount++;
                } else if ($tr.hasClass("t-group-footer")) {
                    footerCount--;
                }
                        
                if (offset <= depth || ($tr.hasClass("t-group-footer") && footerCount < 0)) {
                    return false;
                }

                $tr.hide();
            });
            $group.find('.t-icon').addClass('t-expand').removeClass('t-collapse');
        };

        grid.group = function (title, position) {
            if (this.groups.length == 0 && this.isAjax())
                grid.$groupHeader.empty();

            var group = $.grep(grid.groups, function (group) {
                return group.title == title;
            })[0];

            if (!group) {
                var column = grid.columnFromTitle(title);
                group = { order: 'asc', member: column.member, title: title };
                grid.groups.push(group);
            }

            if (position >= 0) {
                grid.groups.splice($.inArray(group, grid.groups), 1);
                grid.groups.splice(position, 0, group);
            }

            grid.groupBy = $.map(grid.groups, function (g) { return g.member + '-' + g.order; }).join('~');

            if (this.isAjax()) {
                var $groupItem = groupItem(this.$groupHeader, title);
                if ($groupItem.length == 0) {
                    var html = new $.telerik.stringBuilder()
                        .cat('<div class="t-group-indicator">')
                            .cat('<a href="#" class="t-link"><span class="t-icon" />').cat(title).cat('</a>')
                            .cat('<a class="t-button t-button-icon t-button-bare"><span class="t-icon t-group-delete">').cat(grid.localization.ungroup).cat('</span></a>')
                        .cat('</div>')
                    .string();
                    $groupItem = $(html).appendTo(this.$groupHeader);
                }

                if (this.$groupDropCue.is(':visible'))
                    $groupItem.insertBefore(this.$groupDropCue);

                $groupItem.find('.t-link .t-icon')
                          .toggleClass('t-arrow-up-small', group.order == 'asc')
                          .toggleClass('t-arrow-down-small', group.order == 'desc')
                          .html('(' + (group.order == 'asc' ? grid.localization.sortedAsc : grid.localization.sortedDesc) + ')');

                this.ajaxRequest();
            } else {
                this.serverRequest();
            }
        };

        grid.unGroup = function (title) {
            var group = grid.groupFromTitle(title);
            grid.groups.splice($.inArray(group, grid.groups), 1);

            if (grid.groups.length == 0)
                grid.$groupHeader.html(grid.localization.groupHint);

            grid.groupBy = $.map(grid.groups, function (g) { return g.member + '-' + g.order; }).join('~');

            if (grid.isAjax()) {
                groupItem(grid.$groupHeader, title).remove();
                grid.ajaxRequest();
            } else {
                grid.serverRequest();
            }
        };

        grid.clearHeader = function() {
            grid.$groupHeader.html(grid.localization.groupHint);
        };

        grid.normalizeColumns = function(colspan) {
            var groups = grid.groups.length;
            var diff = colspan - grid.$tbody.parent().find(' > colgroup > col').length;
            if (diff == 0) return;
            
            var $tables = grid.$tbody.parent().add(grid.$headerWrap.find('table')).add(grid.$footer.find("table"));
            if ($.browser.msie) {
                // ie8 goes into compatibility mode if the columns get removed
                if (diff > 0) {
                    $(new $t.stringBuilder().rep('<col class="t-group-col" />', diff).string())
                        .prependTo($tables.find('colgroup'));
                    $(new $t.stringBuilder().rep('<th class="t-group-cell t-header">&nbsp;</th>', diff).string())
                        .insertBefore($tables.find('th.t-header:first'));
                    $(new $t.stringBuilder().rep('<td class="t-group-cell">&nbsp;</td>', diff).string())
                        .insertBefore($tables.find('tr.t-footer-template > td:first'));

                } else {
                    $tables.find('th:lt(' + Math.abs(diff) + '), tr.t-footer-template > td:lt(' + Math.abs(diff) + ')')
                           .remove()
                           .end()
                           .find('col:lt(' + Math.abs(diff) + ')')
                           .remove();
                }
                
                // take the tables out for a walk. ie8 does not recalculate table layout properly.
                var containers = [];
                var i = 0;
                
                $('table, .t-grid-bottom', grid.element)
                    .each(function() { containers.push(this.parentNode); })
                    .appendTo($('<div />'))
                    .each(function() { containers[i++].appendChild(this); });
            } else {
                $tables.find('col.t-group-col').remove();

                $(new $t.stringBuilder().rep('<col class="t-group-col" />', groups).string())
                        .prependTo($tables.find('colgroup'));

                $tables.find('th.t-group-cell').remove();
                $tables.find('tr.t-footer-template > td.t-group-cell').remove();

                $(new $t.stringBuilder().rep('<th class="t-group-cell t-header">&nbsp;</th>', groups).string())
                        .insertBefore($tables.find('th.t-header:first'));
                
                $(new $t.stringBuilder().rep('<td class="t-group-cell">&nbsp;</td>', groups).string())
                        .insertBefore($tables.find('tr.t-footer-template > td:first'));
            }            
        };

        function getForeignKeyText(records, key) {
            var value = key,
                idx,
                length;

            for (idx = 0, length = records.length; idx < length; idx++) {
                if (key == records[idx].Value) {
                    return records[idx].Text;
                }
            }
            return key;
        }

        grid.bindGroup = function (dataItem, colspan, html, level) {
            var group = grid.groups[level];
            var key = dataItem.value;
            var column = $.grep(grid.columns, function (column) { return group.member == column.member })[0],
            date;

            if (column && (column.format || column.type == 'Date')) {
                date = /^\/Date\((.*?)\)\/$/.exec(key);
                if(date) {
                    key = new Date(parseInt(date[1]));
                }
                key = $t.formatString(column.format || '{0:G}', key);
            }

            html.cat('<tr class="t-grouping-row">')
                .rep('<td class="t-group-cell"></td>', level)
                .cat('<td colspan="')
                .cat(colspan - level)
                .cat('"><p class="t-reset"><a class="t-icon t-collapse" href="#"></a>');
            
            if (column) {                
                var value = !column.data ? key : getForeignKeyText(column.data, key);
                html.cat(column.groupHeader($.extend( { Title: group.title, Key: value }, grid._mapAggregates(dataItem.aggregates[column.member]) )));
            }
            else {
                html.cat(group.title + ': ' + key);
            }
            
            html.cat('</p></td></tr>');

            if (dataItem.hasSubgroups) {
                for (var i = 0, l = dataItem.items.length; i < l; i++)
                    grid.bindGroup(dataItem.items[i], colspan, html, level + 1);
            } else {
                grid.bindData(dataItem.items, html, level + 1);
            }
            
            if (grid.showGroupFooter) {
                html.cat('<tr class="t-group-footer">')
                    .rep('<td class="t-group-cell"></td>', grid.groups.length)
                    .rep('<td class="t-hierarchy-cell"></td>', grid.detail ? 1 : 0);
            
                $.each(grid.columns, function() {
                    html.cat('<td');
                    html.catIf(' style="display:none;"', this.hidden);
                    html.cat('>');
                    if (this.groupFooter)
                        html.cat(this.groupFooter(grid._mapAggregates(dataItem.aggregates[this.member])));
                    html.cat('</td>');
                });

                html.cat('</tr>');
            }
        }
    }    
})(jQuery);
(function ($) {
    var $t = $.telerik;
    var escapeQuoteRegExp = /'/ig;
    var fx = $t.fx.slide.defaults();
    
    $t.scripts.push("telerik.grid.filtering.js");

    function getFormat(column) {
        if (!column.format)
            return $t.cultureInfo.shortDate;

        return /\{0(:([^\}]+))?\}/.exec(column.format)[2];
    }

    function value(column, value) {
        if (column.type == 'Date')
            return $t.formatString(column.format || '{0:G}', new Date(parseInt(value.replace(/\/Date\((.*?)\)\//, '$1'))));

        return value;
    }

    $t.filtering = {};

    $t.filtering.initialize = function (grid) {
        $.extend(grid, $t.filtering.implementation);

        grid.filterBy = grid.filterExpr();

        $('> .t-grid-content', grid.element).bind('scroll', function () {
            grid.hideFilter();
        });

        $(document).click(function (e) {
            if (e.which != 3) grid.hideFilter();
        });

        grid.$header.find('.t-grid-filter').click($.proxy(grid.showFilter, grid))
            .hover(function () {
                $(this).toggleClass('t-state-hover');
            });
    }

    /* Here `this` is the Grid instance*/

    $t.filtering.implementation = {
        createFilterCommands: function (html, column) {
            var filters = [];

            $.each(this.localization, function (key, value) {
                var prefix = 'filter' + (column.data ? "ForeignKey" : column.type);
                var index = key.indexOf(prefix);
                if (index > -1)
                    filters.push({
                     key: key.substring(index + prefix.length).toLowerCase(),
                     value: value
                    });
            });

            if (column.type == "String") {
                // put the ends with value last
                if (filters[0].key !== "eq") {
                    filters.push(filters.shift());
                }
            }

            html.cat('<select class="t-filter-operator">');
            $.each(filters, function (index, filter) {
                html.cat('<option value="')
					.cat(filter.key)
					.cat('">')
					.cat(filter.value)
					.cat('</option>');
            });

            html.cat('</select>');
        },

        createTypeSpecificInput: function (html, column, fieldId, value) {
            if (column.data) {
                 html.cat('<div><select><option>')
                    .cat(this.localization.filterSelectValue)
                    .cat('</option>');
                
                $.each(column.data, function () {
                    html.cat('<option value="')
                        .cat(this.Value)
                        .cat('">')
                        .cat(this.Text)
                        .cat('</option>');
                });
                html.cat('</select></div>');
            } else if (column.type == 'Date') {
                html.cat('<div class="t-widget t-datepicker"><div class="t-picker-wrap">')
	                .cat('<input class="t-input" id="').cat(fieldId).cat('" type="text" value="" />')
	                .cat('<span class="t-select"><label class="t-icon t-icon-calendar" for="')
	                .cat(fieldId)
	                .cat('" title="').cat(this.localization.filterOpenPopupHint).cat('" /></span></div></div>');
            } else if (column.type == 'Boolean') {
                html.cat('<div><input type="radio" style="width:auto;display:inline" id="').cat(fieldId + value)
				    .cat('" name="').cat(fieldId)
				    .cat('" value="').cat(value).cat('" />')
				    .cat('<label style="display:inline" for="').cat(fieldId + value).cat('">')
                    .cat(this.localization[value ? 'filterBoolIsTrue' : 'filterBoolIsFalse'])
				    .cat('</label></div>');
            } else if (column.type == 'Enum') {
                html.cat('<div><select><option>')
                    .cat(this.localization.filterSelectValue)
                    .cat('</option>');
                $.each(column.values, function (key, value) {
                    html.cat('<option value="')
                        .cat(value)
                        .cat('">')
                        .cat(key)
                        .cat('</option>');
                });
                html.cat('</select></div>');
            } else if (column.type == 'Number') {
                html.cat('<div class="t-widget t-numerictextbox">')
	                .cat('<input class="t-input" name="')
	                .cat(fieldId)
	                .cat('" id="')
	                .cat(fieldId)
	                .cat('" type="text" value=""/>')
	                .cat('</div>');
            } else {
                html.cat('<input type="text" />');
            }
        },

        createFilterMenu: function (column) {
            var filterMenuHtml = new $t.stringBuilder();

            filterMenuHtml.cat('<div class="t-animation-container"><div class="t-filter-options t-group t-popup" style="display:none">')
					.cat('<button class="t-button t-button-icontext t-button-expand t-clear-button"><span class="t-icon t-clear-filter"></span>')
					.cat(this.localization.filterClear)
					.cat('</button><div class="t-filter-help-text">')
					.cat(this.localization.filterShowRows)
					.cat('</div>');

            var fieldIdPrefix = $(this.element).attr('id') + column.member;

            if (column.type == 'Boolean') {
                this.createTypeSpecificInput(filterMenuHtml, column, fieldIdPrefix, true);
                this.createTypeSpecificInput(filterMenuHtml, column, fieldIdPrefix, false);
            } else {
                this.createFilterCommands(filterMenuHtml, column);
                this.createTypeSpecificInput(filterMenuHtml, column, fieldIdPrefix + 'first');
                filterMenuHtml.cat('<div class="t-filter-help-text">')
                              .cat(this.localization.filterAnd)
                              .cat('</div>');
                this.createFilterCommands(filterMenuHtml, column);
                this.createTypeSpecificInput(filterMenuHtml, column, fieldIdPrefix + 'second');
            }

            filterMenuHtml.cat('<button class="t-button t-button-icontext t-button-expand t-filter-button"><span class="t-icon t-filter"></span>')
                          .cat(this.localization.filter)
				          .cat('</button></div></div>');

            var $filterMenu = $(filterMenuHtml.string());

            $.each(column.filters || [], function (i) {
                $filterMenu.find('.t-filter-operator:eq(' + i + ')')
                           .val(this.operator)
                           .end()
                           .find(':text:eq(' + i + '),select:not(.t-filter-operator):eq(' + i + ')')
                           .val(value(column, this.value));

                if (column.type == 'Boolean')
                    $filterMenu.find(':radio[id$=' + this.value + ']')
                               .attr('checked', true);
            });

            return $filterMenu
                        .appendTo(this.element)
                        .find('.t-datepicker .t-input')
                        .each(function () {
                            $(this).tDatePicker({ format: getFormat(column) });
                        })
                        .end()
                        .find('.t-numerictextbox .t-input')
                        .each(function () {
                            $(this).tTextBox({ type: 'numeric', minValue: null, maxValue: null, numFormat: '', groupSeparator: '' });
                        })
                        .end();
        },

        showFilter: function (e) {
            e.stopPropagation();

            var $element = $(e.target).closest('.t-grid-filter');

            this.hideFilter(function () {
                return this.parentNode != $element[0];
            });

            var $filterMenu = $element.data('filter');

            if (!$filterMenu) {
                // filtering menu should be created
                var column = this.columns[this.$columns().index($element.parent())];

                $filterMenu = this.createFilterMenu(column)
                        .data('column', column)
                        .click(function (e) {
                            e.stopPropagation();

                            if ($(e.target).parents('.t-datepicker').length == 0) {
                                $('.t-datepicker .t-input', this)
                                    .each(function () {
                                        $(this).data('tDatePicker').hidePopup();
                                    });
                            }
                        })
                        .find('.t-filter-button').click($.proxy(this.filterClick, this)).end()
                        .find('.t-clear-button').click($.proxy(this.clearClick, this)).end()
                        .find('input[type=text]').keydown($.proxy(function (e) {
                            if (e.keyCode == 13) this.filterClick(e);
                        }, this)).end();

                $element.data('filter', $filterMenu);
            }

            // position filtering menu
            var top = 0;

            $(this.element).find('> .t-grouping-header, > .t-grid-toolbar').add(this.$header).each(function () {
                top += this.offsetHeight;
            });

            var position = { top: top };

            var isRtl = $(this.element).closest('.t-rtl').length;
            var headerScrollLeft = this.$headerWrap.scrollLeft();

            var width = !isRtl ? -headerScrollLeft - 1 : headerScrollLeft - 1;

            $element.parent().add($element.parent().prevAll('th')).each(function () {
                if ($(this).css('display') != 'none')
                    width += this.offsetWidth;
            });

            var left = width - $element.outerWidth();

            // constrain filtering menu within grid
            var outerWidth = $filterMenu.outerWidth() || $filterMenu.find('.t-group').outerWidth();

            if (left + outerWidth > this.$header.closest(".t-grid-header").innerWidth())
                left = width - outerWidth + 1;

            if (isRtl) {
                var correction = (($.browser.mozilla && parseInt($.browser.version, 10) < 2) || $.browser.webkit) ? 18 : 0;
                position['right'] = left + correction;
            } else {
                position['left'] = left;
            }

            $filterMenu.css(position);

            $t.fx[$filterMenu.find('.t-filter-options').is(':visible') ? 'rewind' : 'play'](fx, $filterMenu.find('.t-filter-options'), { direction: 'bottom' });
        },

        hideFilter: function (filterCallback) {
            filterCallback = filterCallback || function () { return true; };

            $('.t-grid .t-animation-container')
                .find('.t-datepicker .t-input')
                .each(function () { $(this).data('tDatePicker').hidePopup(); })
                .end()
                .find('.t-filter-options')
                .filter(filterCallback)
                .each(function () {
                    $t.fx.rewind(fx, $(this), { direction: 'bottom' });
                });
        },

        clearClick: function (e) {
            e.preventDefault();
            var $element = $(e.target);
            var column = $element.closest('.t-animation-container').data('column');
            column.filters = null;


            $element.closest(".t-filter-options")
                .find(".t-numerictextbox .t-input")
                .each(function() {
                    $(this).data("tTextBox").value("");
                })
                .end()
                .find('input')
                .removeAttr('checked')
                .removeClass('t-state-error')
                .not(':radio')
                .val('')
                .end()
                .end()
                .find('select')
                .removeClass('t-state-error')
                .find('option:first')
                .attr('selected', 'selected');

            this.filter(this.filterExpr());
            this.hideFilter();
        },

        filterClick: function (e) {
            e.preventDefault();
            var $element = $(e.target);
            var column = $element.closest('.t-animation-container').data('column');
            column.filters = [];
            var hasErrors = false;

            $element.closest(".t-filter-options").find('input[type=text]:visible,select:not(.t-filter-operator)').each($.proxy(function (index, input) {
                var $input = $(input);
                var value = $.trim($input.val());

                if (!value) {
                    $input.removeClass('t-state-error');
                    return true;
                }

                var valid = this.isValidFilterValue(column, value);

                $input.toggleClass('t-state-error', !valid);

                if (!valid) {
                    hasErrors = true;
                    return true;
                }

                var numeric = $input.data("tTextBox");

                if (numeric) {
                    // the value should be used as a Number instead of String because we need the decimal separator to be "."
                    value = numeric.value();
                }

                var operator = $input.prev('select').val() || $input.parent().prev('select').val() || $input.parent().parent().prev('select').val();
                if (value != this.localization.filterSelectValue)
                    column.filters.push({ operator: operator, value: value });
            }, this));

            $element.parent().find('input:checked').each($.proxy(function (index, input) {
                var $input = $(input);
                var value = $(input).attr('value');

                if (column.type === "Boolean" && value && typeof value === "string") {
                    value = value.toLowerCase().indexOf("true") > -1 ? true : false;
                }

                column.filters.push({ operator: 'eq', value: value });
            }, this));

            if (!hasErrors) {
                if (column.filters.length > 0) {
                    this.filter(this.filterExpr());
                } else {
                    column.filters = null;
                }

                this.hideFilter();
            }
        },

        isValidFilterValue: function (column, value) {            
           if (column.type == 'Date') {                
                var date;
                if (value.indexOf('Date(') > -1) {
                    date = new Date(parseInt(value.replace(/^\/Date\((.*?)\)\/$/, '$1')));
                } else {
                    date = $t.datetime.parse({ value: value, format: getFormat(column) });
                }
                return date != undefined;
            }

            return true;
        },

        encodeFilterValue: function (column, value) {
            switch (column.type) {
                case 'String':
                    return "'" + value.replace(escapeQuoteRegExp, "''") + "'";
                case 'Date':
                    var date;
                    if (value.indexOf('Date(') > -1)
                        date = new Date(parseInt(value.replace(/^\/Date\((.*?)\)\/$/, '$1')));
                    else
                        date = $t.datetime.parse({ value: value, format: getFormat(column) }).toDate();

                    return "datetime'" + $t.formatString('{0:yyyy-MM-ddTHH-mm-ss}', date) + "'";
            }

            return value;
        },

        filterExpr: function () {
            var result = [];

            for (var columnIndex = 0; columnIndex < this.columns.length; columnIndex++) {
                var column = this.columns[columnIndex];
                if (column.filters)
                    for (var filterIndex = 0; filterIndex < column.filters.length; filterIndex++) {
                        var filter = column.filters[filterIndex];
                        result.push(new $t.stringBuilder()
                            .cat(column.member)
                            .cat('~')
                            .cat(filter.operator)
                            .cat('~')
                            .cat(this.encodeFilterValue(column, filter.value)).string());
                    }
            }

            return result.join('~and~');
        },

        filter: function (filterBy) {
            this.currentPage = 1;
            this.filterBy = filterBy;

            if (this.isAjax()) {
                this.$columns().each($.proxy(function (index, element) {
                    $('.t-grid-filter', element).toggleClass('t-active-filter', !!this.columns[index].filters);
                }, this));

                this.ajaxRequest();
            } else {
                this.serverRequest();
            }
        }
    };
})(jQuery);
(function ($) {
    var $t = $.telerik;

    $t.scripts.push("telerik.grid.resizing.js");

    $t.resizing = {};

    $t.resizing.initialize = function (grid) {

        var $col, $indicator = $('<div class="t-grid-resize-indicator" />'),
            gridWidth, columnWidth, columnStart, indicatorWidth = 3;

        function cursor(context, value) {
            $('th, th .t-grid-filter, th .t-link', context)
                .add(document.body)
                .css('cursor', value);
        }

        function heightAboveHeader(context) {
            var top = 0;
            $('> .t-grouping-header, > .t-grid-top', context).each(function () {
                top += this.offsetHeight;
            });
            return top;
        }

        function positionResizeHandle($th) {
            var left = 0; 

            $('.t-resize-handle', grid.element).each(function () {
                left += $(this).data('th').outerWidth();
                $(this).css('left', left - indicatorWidth);
            });

            left = -grid.$tbody.closest('.t-grid-content').scrollLeft();

            $th.prevAll('th').add($th).each(function () {
                left += this.offsetWidth;
            });

            var $body = grid.scrollable ? $('.t-grid-content', grid.element) : $('tbody', grid.element);

            // using "clientWidth" and "clientHeight" to exclude the scrollbar
            var width = $body.attr(grid.scrollable ? 'clientWidth' : 'offsetWidth');

            if (left >= width) {
                $indicator.remove();
            } else {
                $indicator.css({
                    left: left,
                    top: heightAboveHeader(grid.element),
                    height: $th.outerHeight() + $body.attr(grid.scrollable ? 'clientHeight' : 'offsetHeight')
                });
                if (!$indicator.parent().length)
                    $indicator.appendTo(grid.element);
            }
        }

        function start(e) {
            var $th = e.$draggable.data('th'),
                index = $.inArray($th[0], $th.parent().children(":visible")),
                contentTable = grid.$tbody.parent();

            if (!grid.scrollable) {
                $col = contentTable.children('colgroup').find('col:eq(' + index + ')');
            } else {
                $col = grid.$header.parent().prev().find('col:eq(' + index + ')')
                    .add(contentTable.children('colgroup').find('col:eq(' + index + ')'))
                    .add(grid.$footerWrap.find('>table>colgroup>col:eq(' + index + ')'));
            }
            
            columnStart = e.pageX;
            columnWidth = $th.outerWidth();
            gridWidth = grid.$tbody.outerWidth();
        }

        function drag(e) {
            e.$draggable.dragCalled = true;
            var width = columnWidth + e.pageX - columnStart;
            if (width > 10) {
                $col.css('width', width);
                if (grid.scrollable)
                    grid.$tbody.parent()
                        .add(grid.$headerWrap.find('table'))
                        .add(grid.$footer.find('table'))
                        .css('width', gridWidth + e.pageX - columnStart);

                positionResizeHandle(e.$draggable.data('th'));
            }
        }

        function stop(e) {
            $indicator.remove();
            cursor(grid.element, '');

            // will be false on click or double-click without dragging
            if (e.$draggable.dragCalled) {
                var $th = e.$draggable.data('th');

                var newWidth = $th.outerWidth();

                if (grid.onColumnResize && newWidth != columnWidth)
                    $t.trigger(grid.element, "columnResize", {
                        column: grid.columns[grid.$columns().index($th)],
                        oldWidth: columnWidth,
                        newWidth: newWidth
                    });
            }
            return false;
        }

        function init(e) {
           var left = 0,
               scope = grid.element.id + '-column-resizing',
               activeHandler;
           
           if (e && e.type === "mouseenter") {
               $(grid.element).unbind('mouseenter', init);
           }

           var draggable = $t.draggable.get(scope);
           
           if (draggable)
               draggable.destroy();
           
           grid.$headerWrap.add(grid.element)
                           .find('> .t-resize-handle')
                           .remove();
           
           grid.$header.find('.t-header:visible').each(function() {
                left += this.offsetWidth;
                var $th = $(this);
                $('<div class="t-resize-handle" />')
                .css({
                    left: left - indicatorWidth,
                    top: grid.scrollable ? 0 : heightAboveHeader(grid.element),
                    width: indicatorWidth * 2
                })
                .appendTo(grid.scrollable ? grid.$headerWrap : grid.element)
                .data('th', $th)
                .mousedown(function() {
                    positionResizeHandle($th);
                    activeHandler = $(this);
                    cursor(grid.element, activeHandler.css('cursor'));
                });
            });
            
            $(document).mouseup(function() {
                // ensure stop is called when there is no dragging
                if (activeHandler) {
                    stop({ $draggable: activeHandler });
                    activeHandler = null;
                }
            });

            new $t.draggable({
                owner: grid.element,
                selector: '.t-resize-handle',
                scope: scope,
                distance: 0,
                start: start,
                drag: drag,
                stop: stop
            });
        }
        
        init();

        $(grid.element).one('mouseenter', init)
                       .bind('repaint', init);
    }
})(jQuery);
(function ($) {
    var $t = $.telerik;

    $t.scripts.push("telerik.grid.reordering.js");

    $t.reordering = {};

    $t.reordering.initialize = function (grid) {

        grid.$reorderDropCue = $('<div class="t-reorder-cue"><div class="t-icon t-arrow-down"></div><div class="t-icon t-arrow-up"></div></div>');

        var lastColumnIndex = grid.$header.children("th").length - 1;

        var reorderColumn = function (destIndex, column) {
            var sourceIndex = $.inArray(column, grid.columns),
                visibleColumns = $.grep(grid.columns, function(column) { return !column.hidden; }),
                colSourceIndex = $.inArray(column, visibleColumns),
                colDestIndex = $.inArray(grid.columns[destIndex], visibleColumns);
            
            grid.columns.splice(sourceIndex, 1);
            
            grid.columns.splice(destIndex, 0, column);

            reorder(grid.$columns(), sourceIndex, destIndex);

            reorder(grid.$tbody.parent().find('> colgroup > col:not(.t-group-col,.t-hierarchy-col)'), colSourceIndex, colDestIndex);
            
            reorder(grid.$headerWrap.find('table').find('> colgroup > col:not(.t-group-col,.t-hierarchy-col)'), colSourceIndex, colDestIndex);

            var footerWrap = grid.$footer.find('table');
            reorder(footerWrap.find('> colgroup > col:not(.t-group-col,.t-hierarchy-col)'), colSourceIndex, colDestIndex);            
            reorder(footerWrap.find('> tbody > tr.t-footer-template > td:not(.t-group-cell,.t-hierarchy-cell)')
                .add(grid.$footer.find('tr.t-footer-template > td:not(.t-group-cell,.t-hierarchy-cell)')), sourceIndex, destIndex);

            $.each(grid.$tbody.children(), function () {
                reorder($(this).find(' > td:not(.t-group-cell, .t-hierarchy-cell, .t-detail-cell)'), sourceIndex, destIndex);
            });
        };

        grid.reorderColumn = reorderColumn;

        function reorder(selector, sourceIndex, destIndex) {
            var $source = selector.eq(sourceIndex);
            var $dest = selector.eq(destIndex);

            $source[sourceIndex > destIndex ? 'insertBefore' : 'insertAfter']($dest);
        }

        new $t.draggable({
            owner: grid.$header[0],
            selector: '.t-header:not(.t-group-cell,.t-hierarchy-cell)',
            scope: grid.element.id + '-reodering',
            cue: function(e) {           
                var column = grid.columnFromTitle(e.$draggable.text());
                return $t.dragCue(column ? column.title : "");                    
            },
            destroy: function(e) {
                e.$cue.remove();
            }
        });

        new $t.droppable({
            owner: grid.$header[0],
            scope: grid.element.id + '-reodering',
            selector: '.t-header:not(.t-group-cell,.t-hierarchy-cell)',
            over: function(e) {
                var same = $.trim(e.$draggable.text()) == $.trim(e.$droppable.text());
                $t.dragCueStatus(e.$cue, same? 't-denied' : 't-add');

                var top = 0;

                $('> .t-grid-top, > .t-grouping-header', grid.element).each(function() {
                    top += $(this).outerHeight();
                });

                if (!same)
                    grid.$reorderDropCue.css({
                         height: e.$droppable.outerHeight(),
                         top: top,
                         left: function() {
                                return e.$droppable.position().left + ((e.$droppable.index() > e.$draggable.index()) ? e.$droppable.outerWidth() : 0)
                            }
                         })
                         .appendTo(grid.element);
            },
            out: function(e) {
                grid.$reorderDropCue.remove();
                $t.dragCueStatus(e.$cue, 't-denied');
            },
            drop: function(e) {
                grid.$reorderDropCue.remove();
                if (e.$cue.find('.t-drag-status').is('.t-add')) {
                    var column = grid.columnFromTitle($.trim(e.$draggable.text()));
                    var position = grid.$columns().index(e.$droppable.closest(".t-header"));
                    $t.trigger(grid.element, 'columnReorder', {
                        column: column,
                        oldIndex: $.inArray(column, grid.columns),
                        newIndex: position
                    });
                    reorderColumn(position, column);
                    $t.trigger(grid.element, 'repaint');
                }
            }
        });
    }
})(jQuery);
(function ($) {

    var $t = $.telerik, dateRe = /^\/Date\((.*?)\)\/$/, customFormatRegEx = /[0#?]/, numberTypeRegExp = /[npc?]/;

    $t.scripts.push("telerik.grid.editing.js");

    var UnobtrusiveValidator = function (formId) {
        this.formId = formId;
        this._isBuild = false;
        var data_validation = "tUnobtrusiveValidation";
        var data_container = "tUnobtrusiveContainer";
        var unobtrusive = this.unobtrusive = {
            adapters: [],
            parseElement: function (element, skipAttach) {
                var $element = $(element),
						form = $element.parents("form")[0],
						valInfo, rules, messages;

                if (!form) {
                    return;
                }

                valInfo = unobtrusive.validationInfo(form);
                valInfo.options.rules[element.name] = rules = {};
                valInfo.options.messages[element.name] = messages = {};

                $.each(this.adapters, function () {
                    var prefix = "data-val-" + this.name,
							message = $element.attr(prefix),
							paramValues = {};

                    if (message !== undefined) {
                        prefix += "-";

                        $.each(this.params, function () {
                            paramValues[this] = $element.attr(prefix + this);
                        });

                        this.adapt({
                            element: element,
                            form: form,
                            message: message,
                            params: paramValues,
                            rules: rules,
                            messages: messages
                        });
                    }
                });

                if (!skipAttach) {
                    valInfo.attachValidation();
                }
            },

            parse: function (selector) {
                $(selector).find(":input[data-val=true]").each(function () {
                    unobtrusive.parseElement(this, true);
                });

                $(selector).each(function () {
                    var info = unobtrusive.validationInfo(this);
                    if (info) {
                        info.attachValidation();
                    }
                });
            },

            onError: function (error, inputElement) {
                var container = $(this).find("[data-valmsg-for='" + inputElement[0].name + "']"),
						replace = $.parseJSON(container.attr("data-valmsg-replace")) !== false;

                container.removeClass("field-validation-valid").addClass("field-validation-error");
                error.data(data_container, container);

                if (replace) {
                    container.empty();
                    error.removeClass("input-validation-error").appendTo(container);
                }
                else {
                    error.hide();
                }
            },

            onErrors: function (form, validator) {
                var container = $(this).find("[data-valmsg-summary=true]"),
						list = container.find("ul");

                if (list && list.length && validator.errorList.length) {
                    list.empty();
                    container.addClass("validation-summary-errors").removeClass("validation-summary-valid");

                    $.each(validator.errorList, function () {
                        $("<li />").html(this.message).appendTo(list);
                    });
                }
            },

            onSuccess: function (error) {
                var container = error.data(data_container),
						replace = $.parseJSON(container.attr("data-valmsg-replace"));

                if (container) {
                    container.addClass("field-validation-valid").removeClass("field-validation-error");
                    error.removeData(data_container);

                    if (replace) {
                        container.empty();
                    }
                }
            },

            validationInfo: function (form) {
                var $form = $(form),
						result = $form.data(data_validation);

                if (!result) {
                    result = {
                        options: {
                            errorClass: "input-validation-error",
                            errorElement: "span",
                            errorPlacement: $.proxy(unobtrusive.onError, form),
                            invalidHandler: $.proxy(unobtrusive.onErrors, form),
                            messages: {},
                            rules: {},
                            success: $.proxy(unobtrusive.onSuccess, form)
                        },
                        attachValidation: function () {
                            $form.validate(this.options);
                        },
                        validate: function () {
                            $form.validate();
                            return $form.valid();
                        }
                    };
                    $form.data(data_validation, result);
                }

                return result;
            }
        };
    };

    UnobtrusiveValidator.prototype = {
        build: function () {
            if (this._isBuild)
                return;

            this._isBuild = true;

            var adapters = [];
            function setValidationValues(options, ruleName, value) {
                options.rules[ruleName] = value;
                if (options.message) {
                    options.messages[ruleName] = options.message;
                }
            }

            function splitAndTrim(value) {
                return value.replace(/^\s+|\s+$/g, "").split(/\s*,\s*/g);
            }

            function getModelPrefix(fieldName) {
                return fieldName.substr(0, fieldName.lastIndexOf(".") + 1);
            }

            function appendModelPrefix(value, prefix) {
                if (value.indexOf("*.") === 0) {
                    value = value.replace("*.", prefix);
                }
                return value;
            }

            adapters = this.unobtrusive.adapters;
            adapters.add = function (adapterName, params, fn) {
                if (!fn) {
                    fn = params;
                    params = [];
                }
                this.push({ name: adapterName, params: params, adapt: fn });
                return this;
            };

            adapters.addBool = function (adapterName, ruleName) {
                return this.add(adapterName, function (options) {
                    setValidationValues(options, ruleName || adapterName, true);
                });
            };

            adapters.addMinMax = function (adapterName, minRuleName, maxRuleName, minMaxRuleName, minAttribute, maxAttribute) {
                return this.add(adapterName, [minAttribute || "min", maxAttribute || "max"], function (options) {
                    var min = options.params.min,
						max = options.params.max;

                    if (min && max) {
                        setValidationValues(options, minMaxRuleName, [min, max]);
                    }
                    else if (min) {
                        setValidationValues(options, minRuleName, min);
                    }
                    else if (max) {
                        setValidationValues(options, maxRuleName, max);
                    }
                });
            };

            adapters.addSingleVal = function (adapterName, attribute, ruleName) {
                return this.add(adapterName, [attribute || "val"], function (options) {
                    setValidationValues(options, ruleName || adapterName, options.params[attribute]);
                });
            };

            adapters.addSingleVal("accept", "exts").addSingleVal("regex", "pattern");
            adapters.addBool("creditcard").addBool("date").addBool("digits").addBool("email").addBool("number").addBool("url");
            adapters.addMinMax("length", "minlength", "maxlength", "rangelength").addMinMax("range", "min", "max", "range");
            adapters.add("equalto", ["other"], function (options) {
                var element = $(options.form).find(":input[name=" + options.params.other + "]")[0];
                setValidationValues(options, "equalTo", element);
            });
            adapters.add("required", function (options) {
                if (options.element.tagName.toUpperCase() !== "INPUT" || options.element.type.toUpperCase() !== "CHECKBOX") {
                    setValidationValues(options, "required", true);
                }
            });
            adapters.add("remote", ["url", "type", "additionalfields"], function (options) {
                var value = {
                    url: options.params.url,
                    type: options.params.type || "GET",
                    data: {}
                },
                    prefix = getModelPrefix(options.element.name);

                $.each(splitAndTrim(options.params.additionalfields || options.element.name), function (i, fieldName) {
                    var paramName = appendModelPrefix(fieldName, prefix);
                    value.data[paramName] = function () {
                        return $(options.form).find(":input[name='" + paramName + "']").val();
                    };
                });

                setValidationValues(options, "remote", value);
            });

            if ($.validator.unobtrusive && $.validator.unobtrusive.adapters)
                $.extend(adapters, $.validator.unobtrusive.adapters);

            $.validator.addMethod("regex", function (value, element, params) {
                if (this.optional(element))
                    return true;

                var match = new RegExp(params).exec(value);
                return match && match.index == 0 && match[0].length == value.length;
            });

            $.validator.addMethod('number', function (value, element) {
                var groupSize = $t.cultureInfo.numericgroupsize;
                if (groupSize) {
                    var builder = new $t.stringBuilder();

                    builder.cat('^-?(?:\\d+|\\d{1,')
                        .cat(groupSize)
                        .cat('}(?:')
                        .cat($t.cultureInfo.numericgroupseparator)
                        .cat('\\d{')
                        .cat(groupSize)
                        .cat('})+)(?:\\')
                        .cat($t.cultureInfo.numericdecimalseparator)
                        .cat('\\d+)?$');
                    return this.optional(element) || (builder && new RegExp(builder.string()).test(value));
                }
                return this.optional(element) || /^-?(?:\d+|\d{1,3}(?:,\d{3})+)(?:\.\d+)?$/.test(value);
            });
        },
        parse: function () {
            this.build();
            this.unobtrusive.parse(this.formId);
        }
    };

    var Mvc2Validator = function (validationMetaData) {
        this.validationMetaData = validationMetaData;
    };

    Mvc2Validator.prototype = {
        build: function (validationContext) {

            $.validator.addMethod("regex", function (value, element, params) {
                if (this.optional(element))
                    return true;

                var match = new RegExp(params).exec(value);
                return match && match.index == 0 && match[0].length == value.length;
            });

            $.validator.addMethod('number', function (value, element) {
                var groupSize = $t.cultureInfo.numericgroupsize;
                var builder = new $t.stringBuilder();

                builder.cat('^-?(?:\\d+|\\d{1,')
					   .cat(groupSize)
					   .cat('}(?:')
					   .cat($t.cultureInfo.numericgroupseparator)
					   .cat('\\d{')
					   .cat(groupSize)
					   .cat('})+)(?:\\')
					   .cat($t.cultureInfo.numericdecimalseparator)
					   .cat('\\d+)?$');

                return this.optional(element) || new RegExp(builder.string()).test(value);
            });

            function applyRangeValidator(object, min, max) {
                object["range"] = [min, max];
            };

            function applyRegularExpressionValidator(object, pattern) {
                object["regex"] = pattern;
            };

            function applyRequiredValidator(object) {
                object["required"] = true;
            };

            function applyStringLengthValidator(object, maxLength) {
                object["maxlength"] = maxLength;
            };

            function applyUnknownValidator(object, validationType, validationParameters) {
                object[validationType] = validationParameters;
            };

            function createFieldToValidationMessageMapping(validationFields) {
                var mapping = {};

                for (var i = 0; i < validationFields.length; i++) {
                    var thisField = validationFields[i];
                    mapping[thisField.FieldName] = "#" + thisField.ValidationMessageId;
                }

                return mapping;
            };

            function createErrorMessagesObject(validationFields) {
                var messagesObj = {};

                for (var i = 0; i < validationFields.length; i++) {
                    var thisField = validationFields[i];
                    var thisFieldMessages = {};
                    messagesObj[thisField.FieldName] = thisFieldMessages;
                    var validationRules = thisField.ValidationRules;

                    for (var j = 0; j < validationRules.length; j++) {
                        var thisRule = validationRules[j];
                        if (thisRule.ErrorMessage) {
                            var jQueryValidationType = thisRule.ValidationType;
                            switch (thisRule.ValidationType) {
                                case "regularExpression":
                                    jQueryValidationType = "regex";
                                    break;

                                case "stringLength":
                                    jQueryValidationType = "maxlength";
                                    break;
                            }

                            thisFieldMessages[jQueryValidationType] = thisRule.ErrorMessage;
                        }
                    }
                }

                return messagesObj;
            }
            function createRulesForField(validationField) {
                var validationRules = validationField.ValidationRules;

                // hook each rule into jquery
                var rulesObj = {};
                for (var i = 0; i < validationRules.length; i++) {
                    var thisRule = validationRules[i];
                    switch (thisRule.ValidationType) {
                        case "range":
                            var min = (typeof (thisRule.ValidationParameters['minimum']) == "undefined") ? thisRule.ValidationParameters['min'] : thisRule.ValidationParameters['minimum'];
                            var max = (typeof (thisRule.ValidationParameters['maximum']) == "undefined") ? thisRule.ValidationParameters['max'] : thisRule.ValidationParameters['maximum'];
                            applyRangeValidator(rulesObj,
								    min, max);
                            break;

                        case "regularExpression":
                        case "regex":
                            applyRegularExpressionValidator(rulesObj,
								thisRule.ValidationParameters["pattern"]);
                            break;

                        case "required":
                            applyRequiredValidator(rulesObj);
                            break;

                        case "stringLength":
                            applyStringLengthValidator(rulesObj,
								thisRule.ValidationParameters["maximumLength"]);
                            break;
                        case "length":
                            applyStringLengthValidator(rulesObj,
								thisRule.ValidationParameters["max"]);
                            break;
                        default:
                            applyUnknownValidator(rulesObj,
								thisRule.ValidationType, thisRule.ValidationParameters);
                            break;
                    }
                }

                return rulesObj;
            }

            function createValidationOptions(validationFields) {
                var rulesObj = {};
                for (var i = 0; i < validationFields.length; i++) {
                    var validationField = validationFields[i];
                    var fieldName = validationField.FieldName;
                    rulesObj[fieldName] = createRulesForField(validationField);
                }

                return rulesObj;
            }

            var theForm = $("#" + validationContext.FormId);

            var fields = validationContext.Fields;
            var rulesObj = createValidationOptions(fields);
            var fieldToMessageMappings = createFieldToValidationMessageMapping(fields);
            var errorMessagesObj = createErrorMessagesObject(fields);

            var options = {
                errorClass: "input-validation-error",
                errorElement: "span",
                errorPlacement: function (error, element) {
                    var messageSpan = fieldToMessageMappings[element.attr("name")];
                    if (messageSpan) {
                        $(messageSpan).empty()
										.removeClass("field-validation-valid")
										.addClass("field-validation-error")

                        error.removeClass("input-validation-error")
							 .attr("_for_validation_message", messageSpan)
							 .appendTo(messageSpan);
                    }
                },
                messages: errorMessagesObj,
                rules: rulesObj,
                success: function (label) {
                    $(label.attr("_for_validation_message"))
						.empty()
						.addClass("field-validation-valid")
						.removeClass("field-validation-error");
                }
            };
            theForm.validate(options);
        },
        parse: function () {
            this.build(this.validationMetaData);
        }
    };

    $t.editing = {};

    function cancelAll(grid) {
        $(grid || document.body).find('div.t-grid')
                        .each(function () {
                            var grid = $(this).data('tGrid');
                            if (grid && grid.cancel)
                                grid.cancel();
                        });
    }

    function flatten(result, value, prefix) {
        for (var key in value) {
            if ($.isPlainObject(value[key])) {
                flatten(result, value[key], prefix ? prefix + "." + key : key);
            } else {
                result[prefix ? prefix + "." + key : key] = value[key];
            }
        }
    }

    function unflatten(value) {
        for (var key in value) {
            var firstMemberIndex = key.indexOf(".");

            if (firstMemberIndex > -1) {
                var firstMember = key.substring(0, firstMemberIndex);
                var child = value[firstMember] || {};
                child[key.substring(firstMemberIndex + 1)] = value[key];
                value[firstMember] = unflatten(child);

                delete value[key];
            }
        }
        return value;
    }

    function sanitizeDates(dataItem) {
        var member, value, date;

        for (member in dataItem) {
            value = dataItem[member];
            if (typeof value === "string") {
                date = dateRe.exec(value);
                if (date) {
                    dataItem[member] = new Date(parseInt(date[1]));
                }
            } else if ($.isPlainObject(value)) {
                sanitizeDates(value);
            }
        }
    }

    function serialize(data, prefix, predicate) {
        var result = {};        

        for (var sourceIndex = 0, destinationIndex = 0; sourceIndex < data.length; sourceIndex++) {
            var dataItem = data[sourceIndex];
            sanitizeDates(dataItem);

            if (predicate(dataItem)) {
                for (var member in dataItem) {
                    var value = dataItem[member],
                        key = prefix + '[' + destinationIndex + '].' + member;

                    if ($.isPlainObject(value)) {
                        flatten(result, value, key);
                    } else {
                        result[key] = value;
                    }
                }
                destinationIndex++;
            }
        }

        return result;
    }

    $t.editing.initialize = function (grid) {
        $.extend(grid, this.implementation);
        var $element = $(grid.element);

        grid.modelBinder = new $t.grid.ModelBinder();

        grid.formViewBinder = new $t.grid.FormViewBinder({
            'date': function (name, value) {
                var column = grid.columnFromMember(name);
                var format = column ? column.format : '';
                return $t.formatString(format || '{0:G}', value);
            }
        });

        if (grid.isAjax()) {

            grid.serializeData = function (data, prefix, predicate) {
                if (!predicate) {
                    predicate = function() { return true; }
                }

                data = serialize(data, prefix, predicate);
                return grid._convert(data);
            }

            if (grid.editing.mode == 'InCell') {
                sanitizeDates(grid.editing.defaultDataItem || {});

                grid.changeLog = new $t.grid.ChangeLog(grid.pageSize || (grid.data && grid.data.length) || 0, grid.editing.insertRowPosition);

                $(grid.element).bind('dataBound', function () {
                    grid.changeLog.clear();
                    grid.valid = true;
                    grid.td = null;
                });

                grid.cellEditor = new $t.grid.CellEditor(
                    {
                        columns: grid.columns,
                        cellIndex: function (td) { return grid.cellIndex(td); },
                        id: grid.formId(),
                        bind: $.proxy(grid.formViewBinder.bind, grid.formViewBinder),
                        validate: $.proxy(grid.validation, grid)
                    }
                );

                $element.delegate('.t-grid-save-changes:not(.t-state-disabled)', 'click', $t.stopAll(function (e) {
                    grid.submitChanges();
                }));

                $element.delegate('.t-grid-cancel-changes', 'click', $t.stopAll(function (e) {
                    grid.cancelChanges();
                }));

                grid.hasChanges = function () {
                    return grid.changeLog.dirty();
                }

                grid.updatedDataItems = function () {
                    return $.grep(grid.changeLog.updated, function (value) { return value != undefined });
                }

                grid.insertedDataItems = function () {
                    return grid.changeLog.inserted;
                }

                grid.deletedDataItems = function () {
                    return $.grep(grid.changeLog.deleted, function (value) { return value != undefined });
                }                               

                grid.submitChanges = function () {
                    grid._onCommand( { name: "submitChanges" } );

                    if (grid.changeLog.dirty()) {

                        grid._validateForm(function () {
                            var inserted = grid.changeLog.inserted;
                            var updated = $.grep(grid.changeLog.updated, function (value) { return value != undefined });
                            var deleted = $.grep(grid.changeLog.deleted, function (value) { return value != undefined });
                            var additionalValues = {};

                            if ($t.trigger(grid.element, 'submitChanges', {
                                inserted: inserted,
                                updated: updated,
                                deleted: deleted,
                                values: additionalValues
                            })) {
                                return;
                            }

                            var values = grid.ws ? {
                                inserted: $.map(inserted, function (value) { return grid._convert(value); }),
                                updated: $.map(updated, function (value) { return grid._convert(value); }),
                                deleted: $.map(deleted, function (value) { return grid._convert(value); })
                            } : grid.changeLog.serialize(inserted, updated, deleted);

                            grid.sendValues($.extend(values, additionalValues), 'updateUrl', 'submitChanges');
                        });
                    }
                }

                grid.cancelChanges = function () {
                    grid._onCommand( { name: "cancelChanges" } );

                    grid.changeLog.clear();
                    grid.valid = true;
                    grid.td = null;
                    grid.ajaxRequest();
                }

                grid.cellIndex = function (td) {
                    return $(td).parent().find('td:not(.t-group-cell,.t-hierarchy-cell)').index(td);
                }

                grid.rowIndex = function (tr) {
                    tr = $(tr);

                    if (tr.hasClass("t-grid-new-row")) {
                        return tr.parent().find(".t-grid-new-row").index(tr);
                    }

                    return tr.parent().find('tr:not(.t-detail-row,.t-grouping-row)').index(tr);
                }

                var dirtyIndicator;
                grid.valid = true;

                grid.editCell = function (td) {
                    var column = grid.columns[grid.cellIndex(td)];
                    if (grid.valid && (column && !column.readonly)) {
                        grid.td = td;

                        if (grid.form().length) {
                            $.data(grid.form()[0], 'validator', null);
                        }

                        td = $(td);
                        var tr = td.parent();
                        var index = grid.rowIndex(tr);

                        var dataItem = grid.changeLog.get(index) || grid.dataItem(tr);

                        dirtyIndicator = td.find('.t-dirty');

                        grid.cellEditor.edit(td, dataItem);

                        $t.trigger(grid.element, 'edit', {
                            mode: tr.hasClass('t-grid-new-row') ? 'insert' : 'edit',
                            form: grid.form()[0],
                            dataItem: dataItem,
                            cell: td[0]
                        });
                    } else if (grid.keyboardNavigation) {
                        var td = $(td),
                            dataArea = td.closest(".t-grid-content", grid.element);
                        if (dataArea.length > 0) {
                            var cellWidth = td.outerWidth(),
                                offsetLeft = td.position().left,
                                scrollLeft = dataArea.scrollLeft(),
                                dataWidth = dataArea.outerWidth();
                            if (offsetLeft > scrollLeft && offsetLeft + cellWidth > dataWidth) {
                                var newScroll = scrollLeft + $t.scrollbarWidth() + offsetLeft + cellWidth - dataWidth;
                                dataArea.scrollLeft(newScroll);
                            }
                        }
                    }
                }

                grid.saveCell = function (td) {
                    grid.valid = false;
                    grid._validateForm(function () {
                        grid.valid = true;
                        td = $(td);
                        var tr = td.parent();
                        var dataItem = grid.changeLog.get(grid.rowIndex(tr)) || grid.dataItem(tr);

                        var values = unflatten(grid.modelBinder.bind(td));

                        var dirty = false;

                        if ($t.trigger(grid.element, 'save', { mode: tr.hasClass('t-grid-new-row') ? 'insert' : 'edit',
                            dataItem: dataItem,
                            values: values,
                            form: grid.form()[0],
                            cell: td[0]
                        })) {
                            return;
                        }

                        if (tr.hasClass('t-grid-new-row')) {
                            grid.changeLog.insert(grid.rowIndex(tr), values);
                        } else {

                            dirty = grid.changeLog.update(grid.rowIndex(tr), dataItem, values);
                        }

                        grid.cellEditor.display(td, $.extend(true, {}, dataItem, values));
                        if (dirty || tr.hasClass('t-grid-new-row')) {
                            dirtyIndicator = $('<span class="t-dirty" />');
                        }

                        if (dirtyIndicator && dirtyIndicator.length) {
                            dirtyIndicator.prependTo(grid.td)
                        }

                        grid.td = null;

                    });
                }

                grid.cancelCell = function (td) {
                    td = $(td);
                    var tr = td.parent(),
                        index = grid.rowIndex(tr),
                        dataItem = grid.changeLog.get(index) || grid.dataItem(tr);

                    grid.valid = true;
                    grid.cellEditor.display(td, dataItem);
                    if (dirtyIndicator && dirtyIndicator.length) {
                        dirtyIndicator.prependTo(grid.td)
                    }
                    grid.td = null;
                }

                grid.td = null;
                grid.$tbody.delegate('tr:not(.t-grouping-row,.t-no-data,.t-footer-template,.t-group-footer) > td:not(.t-detail-cell,.t-grid-edit-cell,.t-group-cell,.t-hierarchy-cell)', grid.editing.beginEdit || 'click', function (e) {
                    if ($(this).closest("tbody")[0] == grid.$tbody[0]) {
                        grid.editCell(this);
                    }
                });

                $(document).mousedown(function (e) {
                    if (grid.td && !$.contains(grid.td, e.target) && grid.td != e.target && !$(e.target).closest('.t-animation-container').length) {
                        grid.saveCell(grid.td);
                    }
                });
            } else {
                if (grid.editing.beginEdit) {
                    grid.$tbody.delegate('tr:not(.t-detail-row,.t-grouping-row,.t-grid-edit-row,.t-group-footer)', grid.editing.beginEdit, function (e) {
                        if (!$(e.target).is(':button,a,:input,a>.t-icon')) {
                            grid.editRow($(this));
                        }
                    });
                }
            }
            $element.delegate('.t-grid-edit', 'click', $t.stopAll(function (e) {
                grid.editRow($(this).closest('tr'));
            }))
            .delegate('.t-grid-delete', 'click', $t.stopAll(function (e) {
                grid.deleteRow($(this).closest('tr'));
            }))
            .delegate('.t-grid-add', 'click', $t.stopAll(function (e) {
                grid.addRow();
            }));
        } else {
            $element.delegate('.t-grid-delete', 'click', $t.stop(function (e) {
                if (grid.editing.confirmDelete !== false && !confirm(grid.localization.deleteConfirmation))
                    e.preventDefault();
            }));

            grid.validation();
        }

        grid.errorView = new $t.grid.ErrorView();

        var builder = new $t.grid.DataCellBuilder({ columns: grid.columns, rowTemplate: grid.rowTemplate });

        var column = $.grep(grid.columns, function (c) {
            return c.commands && $.grep(c.commands, function (cmd) { return cmd.name == 'edit' })[0];
        })[0];

        if (!column) {
            column = { commands: [{ name: "edit", buttonType: "Text"}] };
            column.insert = grid.insertFor(column);
            column.edit = grid.editFor(column);
        }

        var formContainerBuilder = new $t.grid.FormContainerBuilder({
            html: function () { return unescape(grid.editing.editor) },
            insert: function () { return column.insert() },
            edit: function () { return column.edit() }
        });

        var editMode = grid.editing.mode;
        var groups = function () {
            return (grid.groups || []).length;
        };

        if (editMode == 'InLine') {
            grid.rowEditor = new $t.grid.Editor({
                id: grid.formId(),
                insertRow: grid.editing.insertRowPosition,
                cancel: builder.display,
                edit: builder.edit,
                insert: builder.insert,
                groups: groups,
                details: grid.detail
            });
        } else if (editMode == 'InForm') {
            grid.rowEditor = new $t.grid.Editor({
                id: grid.formId(),
                cancel: builder.display,
                insertRow: grid.editing.insertRowPosition,
                groups: groups,
                details: grid.detail,
                edit: function () {
                    return '<td colspan="' + $.grep(grid.columns, function(col) { return !col.hidden; }).length + '">' +
                                formContainerBuilder.edit() +
                           '</td>';
                },
                insert: function () {
                    return '<td colspan="' + $.grep(grid.columns, function(col) { return !col.hidden; }).length + '">' +
                                formContainerBuilder.insert() +
                           '</td>';
                }
            });
        } else if (editMode == 'PopUp') {
            grid.rowEditor = new $t.grid.PopUpEditor({
                id: grid.formId(),
                edit: formContainerBuilder.edit,
                container: grid.element,
                settings: grid.editing.popup,
                insert: formContainerBuilder.insert,
                editTitle: grid.localization.edit,
                insertTitle: grid.localization.insert
            });
        } else {
            builder = new $t.grid.CellBuilder({ columns: grid.columns });

            grid.rowEditor = new $t.grid.Editor({
                id: grid.formId(),
                cancel: builder.display,
                insertRow: grid.editing.insertRowPosition,
                edit: builder.edit,
                insert: builder.insert,
                groups: groups,
                details: grid.detail
            });
        }

        if (!grid.keyboardNavigation) {
            $element.delegate(':input:not(.t-button):not(textarea)', 'keydown', $t.stop(function (e) {
                if (e.keyCode == 13 || e.keyCode == 27) {
                    e.preventDefault();
                    var keyMap = { 13: '.t-grid-update, .t-grid-insert', 27: '.t-grid-cancel' };
                    $(this).closest('tr').find(keyMap[e.keyCode]).click();
                }
            }));
        }
    }

    $t.editing.implementation = {
        editFor: function (column) {
            var localization = this.localization;
            if (column.commands) {
                var edit = $.grep(column.commands, function (column) { return column.name == 'edit' })[0];

                if (edit) {
                    var update = $t.grid.ButtonBuilder.create($.extend({ text: localization['update'] }, edit, { name: 'update' }));
                    var cancel = $t.grid.ButtonBuilder.create($.extend({ text: localization['cancel'] }, edit, { name: 'cancel' }));

                    var html = update.build() + cancel.build();

                    return function () {
                        return html;
                    };
                } else {
                    return function () { return '' };
                }
            } else if (!column.readonly && column.editor) {
                return function () { return unescape(column.editor) };
            }

            return this.displayFor(column);
        },

        insertFor: function (column) {
            var localization = this.localization;

            if (column.commands) {
                var edit = $.grep(column.commands, function (column) { return column.name == 'edit' })[0];

                if (edit) {
                    var insert = $t.grid.ButtonBuilder.create($.extend({ text: localization['insert'] }, edit, { name: 'insert' }));
                    var cancel = $t.grid.ButtonBuilder.create($.extend({ text: localization['cancel'] }, edit, { name: 'cancel' }));

                    var html = insert.build() + cancel.build();

                    return function () {
                        return html;
                    };
                } else {
                    return function () { return '' };
                }
            } else {
                return this.editFor(column);
            }
        },
        insertRow: function ($tr) {
            var that = this;

            if ($.isPlainObject($tr)) {
                var dataItem = $.extend(true, {}, that.editing.defaultDataItem, $tr);
                if (this.editing.mode != 'InCell') {
                    sanitizeDates(dataItem);
                    that.sendValues(dataItem, 'insertUrl', 'insert');    
                } else {                    
                    that.changeLog.insert(dataItem);
                    var groups = (that.groups || []).length + 1,
                        details = that.detail,
                        tr = $('<tr class="t-grid-new-row">' +
                            new Array(groups).join('<td class="t-group-cell" />') +
                            ((details) ? '<td class="t-hierarchy-cell"/>' : "") +
                            '</tr>'),
                        columns = that.columns,
                        td, idx, length;
                    
                    that.$tbody.prepend(tr);
                    tr.closest("table")
                        .wrap(function () {
                            if (!$(this).parent().is("form"))
                                return form(that.formId());
                        });

                    for (idx = 0, length = columns.length; idx < length; idx++) {
                        td = $("<td>").appendTo(tr);
                        that.cellEditor.display(td, dataItem);
                        
                        if (!columns[idx].readonly) {                            
                            td.prepend('<span class="t-dirty" />');                            
                        }

                        if (columns[idx].hidden) {
                            td.hide();
                        }
                    }
                }

                return;
            }

            var tr = ($tr.data('tr') || $tr)[0];

            this._onCommand({ name: "insert", row: tr });

            that._validateForm(function () {
                var values = that.extractValues($tr);

                if ($t.trigger(that.element, 'save', { mode: 'insert', values: values, form: that.form()[0] }))
                    return;

                that.sendValues(values, 'insertUrl', 'insert');
            });
        },
        _validateForm: function (callback) {
            var form = this.form();

            if (form.length) {
                var validator = form.validate();
                if (validator) {
                    this.validate();
                    validator.settings.submitHandler = function () {
                        callback();
                        validator.settings.submitHandler = $.noop;
                    };
                    form.submit();
                }
            }
        },
        _rowForData: function(values) {
            var that = this,
                data = (that.changeLog ? that.changeLog.inserted : []).concat(that.data || []),
                getters = [];

            values = values ? values : {};
            for (var key in that.dataKeys) {
                getters.push(that.valueFor({ member: key }));
            }

            for(var i = 0, length = data.length; i < length; i++) {
                var idx = getters.length - 1,
                    getter = getters[idx];

                while (getter && getter(values) === getter(data[i])) {
                    getter = getters[--idx];
                }

                if (idx < 0) {                    
                    return that.$tbody.find(">tr:not(.t-grouping-row,.t-group-footer,.t-detail-row,.t-no-data,.t-footer-template)").eq(i);
                }
            }
        },
        updateRow: function ($tr) {
            var that = this;

            if ($.isPlainObject($tr)) {
                var values = $tr;
                if (this.editing.mode != 'InCell') {
                    sanitizeDates(values);
                    that.sendValues(values, 'updateUrl', 'update');    
                } else {                     
                    $tr = that._rowForData(values);
                    if (!$tr) {
                        return;
                    }

                    var rowIndex = that.rowIndex($tr),
                        changeLog = that.changeLog,
                        dataItem = changeLog.get(rowIndex) || that.dataItem($tr),
                        cells = $tr.find("td:not(.t-hierarchy-cell,.t-group-cell)"),
                        data = {},
                        td,
                        column;

                    for (var member in values) {
                        data[member] = values[member];
                        column = that.columnFromMember(member);

                        if (column && !column.readonly && changeLog.update(rowIndex, dataItem, data)) {
                            td = cells.eq($.inArray(column, that.columns));
                            that.cellEditor.display(td, data);
                            td.prepend('<span class="t-dirty" />'); 
                        }
                    }
                                   
                    $tr.closest("table")
                        .wrap(function () {
                            if (!$(this).parent().is("form"))
                                return form(that.formId());
                        });
                }

                return;
            }

            var tr = ($tr.data('tr') || $tr)[0];

            this._onCommand({ name: "update", row: tr });

            that._validateForm(function () {
                var dataItem = that.dataItem(tr);
                var values = that.extractValues($tr, (that.editing.mode != 'InCell' || !that.ws));
                if ($t.trigger(that.element, 'save', { mode: 'edit', dataItem: dataItem, values: values, form: that.form()[0] }))
                    return;

                if (that.editing.mode == 'InCell') {
                    values = $.extend(dataItem, values);
                }

                sanitizeDates(values);
                that.sendValues(values, 'updateUrl', 'update');
            });
        },

        deleteRow: function ($tr) {
            var isPlainObject = $.isPlainObject($tr),
                dataItem,
                values,
                that = this;

            if (isPlainObject) {
                dataItem = $tr;
                $tr = that._rowForData($tr); 
                dataItem = $.extend({}, this.dataItem($tr), dataItem);               
                if (that.editing.mode != 'InCell') {
                    if (!that._isServerOperation() && that.dataSource) {
                        that.deletedIds.push(that.dataSource.id(dataItem));
                    }
                    sanitizeDates(dataItem);
                    that.sendValues(dataItem, "deleteUrl", "delete");
                } else {
                    that.changeLog.erase(that.rowIndex($tr), dataItem);

                    if (!that._isServerOperation() && that.dataSource && dataItem) {
                        that.deletedIds.push(that.dataSource.id(dataItem));
                    }
                    
                    $tr.next("tr.t-detail-row").remove();

                    that.cancelRow($tr);
                    $tr.hide();
                }

                return;
            }

            dataItem = this.dataItem($tr);                

            this._onCommand({ name: "delete", row: $tr[0] });

            if (this.editing.mode != 'InCell') {
                values = this.extractValues($tr, true);
                if ($t.trigger(this.element, 'delete', { row: $tr[0], dataItem: dataItem, values: values }))
                    return;

                if (!this._isServerOperation() && this.dataSource) {
                    this.deletedIds.push(this.dataSource.id(dataItem));
                }

                if (this.editing.confirmDelete === false || confirm(this.localization.deleteConfirmation))
                    this.sendValues(values, 'deleteUrl', 'delete');
            } else {
                if (!$tr.hasClass("t-grid-new-row")) {
                    values = this.extractValues($tr, true);
                }
                if ($t.trigger(this.element, 'delete', { row: $tr[0], dataItem: dataItem, values: values }))
                    return;

                if (this.editing.confirmDelete === false || confirm(this.localization.deleteConfirmation)) {
                    this.changeLog.erase(this.rowIndex($tr), dataItem);
                    if (this.td && $.contains($tr[0], this.td)) {
                        this.td = null;
                        this.valid = true;
                    }

                    if(!this._isServerOperation() && this.dataSource && dataItem) {
                        this.deletedIds.push(this.dataSource.id(dataItem));
                    }

                    $tr.next("tr.t-detail-row").remove();

                    this.cancelRow($tr);
                    $tr.hide();
                }
            }
        },

        editRow: function ($tr) {
            var dataItem = this.dataItem($tr);

            this._onCommand({ name: "edit", row: $tr[0] });

            if (this.editing.mode != 'InCell') {
                cancelAll($(this.element).closest(".t-edit-form")[0]);

                var container = this.rowEditor.edit($tr, dataItem);

                var form = this.form();

                form.undelegate('.t-grid-update', "click")
                    .delegate('.t-grid-update', 'click', $t.stopAll($.proxy(function () {
                        this.updateRow(container);
                    }, this)))
                    .undelegate('.t-grid-cancel', "click")
                    .delegate('.t-grid-cancel', 'click', $t.stopAll($.proxy(function () {
                        this.cancelRow($tr);
                    }, this)));

                this.formViewBinder.bind(container, dataItem);

                $t.trigger(this.element, 'edit', {
                    mode: 'edit',
                    form: form[0],
                    dataItem: dataItem
                });

                this.validation();
            } else {
                if (this.valid) {
                    var row = this.rowEditor.edit($tr, dataItem);
                    var cells = row.find("td:not(.t-hierarchy-cell,.t-group-cell)");
                    var input = $tr.find(':input:visible:enabled:first');
                    this.td = input.closest('td')[0];
                    if (!this.td) {
                        var idx = 0;
                        $.each(this.columns, function(index, column) {
                            if(!column.hidden && !column.readonly) {
                                idx = index;
                                return false;
                            }
                        });

                        this.td = cells[idx];
                    }
                    input.focus();
                    this.validation();
                }
            }
        },

        form: function () {
            return $('#' + this.formId());
        },

        addRow: function () {            
            var dataItem = $.extend(true, {}, this.editing.defaultDataItem);           

            this._onCommand({ name: "add" });

            if (this.editing.mode != 'InCell') {
                cancelAll($(this.element).closest(".t-edit-form")[0]);

                var container = this.rowEditor.insert(this.$tbody, dataItem);

                var form = this.form();

                form.undelegate('.t-grid-insert', "click")
                    .delegate('.t-grid-insert', 'click', $t.stopAll($.proxy(function () {
                        this.insertRow(container);
                    }, this)))
                    .undelegate('.t-grid-cancel', "click")
                    .delegate('.t-grid-cancel', 'click', $t.stopAll($.proxy(function () {
                        this.cancelRow(container);
                    }, this)));

                $t.trigger(this.element, 'edit', {
                    mode: 'insert',
                    form: form[0],
                    dataItem: dataItem
                });

                this.validation();
            } else {
                if (this.valid) {
                    var row = this.rowEditor.insert(this.$tbody, dataItem);
                    var cells = row.find("td:not(.t-hierarchy-cell,.t-group-cell)");
                    var input = row.find(':input:enabled:visible:first');
                    this.changeLog.insert(dataItem);
                    
                    this.td = input.closest('td')[0];
                    if (!this.td) {
                        var idx = 0;
                        $.each(this.columns, function(index, column) {
                            if(!column.hidden && !column.readonly) {
                                idx = index;
                                return false;
                            }
                        });

                        this.td = cells[idx];
                    }

                    for (var i = this.columns.length - 1; i >= 0; i--) {
                        if (!this.columns[i].readonly) {
                            var cell = cells.eq(i);
                            if (cell[0] != this.td) {
                                cell.prepend('<span class="t-dirty" />');
                            }
                        }
                    }

                    $t.trigger(this.element, 'edit', {
                        mode: 'insert',
                        form: this.form()[0],
                        dataItem: dataItem,
                        cell: this.td
                    });

                    this.validation();
                    input.focus();
                }
            }

            if (this.editing.mode != 'PopUp') {
                this.$tbody.find(" > tr.t-no-data").hide();
            }
        },

        extractValues: function ($tr, extractKeys) {
            var values = this.modelBinder.bind($tr);

            if (extractKeys) {
                var dataItem = this.dataItem($tr.data('tr') || $tr);

                for (var dataKey in this.dataKeys) {
                    var value = this.valueFor({ member: dataKey })(dataItem);
                    if (value instanceof Date)
                        value = $t.formatString('{0:G}', value);

                    values[this.ws ? dataKey : this.dataKeys[dataKey]] = value;
                }
            }
            return values;
        },

        cancelRow: function ($tr) {
            if (!$tr.length)
                return;

            var tr = ($tr.data('tr') || $tr)[0];

            var dataItem = this.dataItem($tr);

            this._onCommand({ name: "cancel", row: tr});

            this.rowEditor.cancel($tr, dataItem);

            if ($tr.is('.t-grid-new-row')) {
                if (!this.changeLog || !this.changeLog.inserted.length) {
                    this.$tbody.find(" > tr.t-no-data").show();
                }
                return;
            }

            $t.trigger(this.element, 'rowDataBound', { row: $tr[0], dataItem: dataItem });
        },

        validate: function () {
            var form = this.form();
            if (form.length) {
                var validator = form.validate();
                var valid = validator.form();
                if (validator.pendingRequest) {
                    validator.formSubmitted = true;
                    return false;
                }
                return valid;
            }
            return true;
        },

        cancel: function () {
            this.cancelRow(this.$tbody.find('>.t-grid-edit-row'));
        },
        _dataSource: function () {
            var that = this,
                options = this._dataSourceOptions(),
                data = options.data,
                routeKeys = [],
                getters = [];

            $.each(that.dataKeys, function (dataKey, routeKey) {
                routeKeys.push(routeKey);
                getters.push($t.getter(dataKey));
            });

            if (that.isAjax()) {
                $.extend(true, options, {
                    model: $t.Model.define({
                        id: function (data, value) {
                            var keys;

                            if (value === undefined) {
                                return $.map(getters, function (getter) {
                                    return getter(data);
                                }).join("-");
                            } else {
                                keys = value.split("-");

                                $.each(routeKeys, function (index, routeKey) {
                                    data[routeKey] = keys[index];
                                });
                            }
                        }
                    })
                });
            }
            that.dataSource = new $t.DataSource(options);

            if (data && data.data) {
                that._convertInitialData(data.data);
            }

            that.dataSource.bind("change", $.proxy(that._dataChange, that));
        },
        _convert: function (values) {
            for (var key in values) {
                var value = values[key], column, format;
                if (value instanceof Date) {
                    column = this.columnFromMember(key);
                    format = '{0:G}';

                    if (column && column.format)
                        format = column.format;

                    values[key] = this.ws ? '\\/Date(' + value.getTime() + ')\\/' : $t.formatString(format, value);
                }
                if (typeof value === "number") {
                    var numericType = "numeric",
                        types = { "n": numericType, "p": "percent", "c": "currency", "#": numericType, "0": numericType };

                    column = this.columnFromMember(key),
                    format = (column && column.format ? column.format : "N").toLowerCase(),

                    value = value.toString();
                    var type = format.match(numberTypeRegExp) || format.match(customFormatRegEx);
                    values[key] = type ? value.replace(".", $t.cultureInfo[types[type] + "decimalseparator"]) : value;
                }

                if (value == undefined) {
                    delete values[key];
                }
                if ($.isPlainObject(value)) {
                    this._convert(value);
                }
            }
            return values;
        },

        sendValues: function (values, url, commandName) {
            if (this.editing.mode != 'InCell' || !this.ws) {
                this._convert(values);

                for (var dataKey in this.dataKeys) {
                    var value = this.valueFor({ member: dataKey })(values);
                    if (value != undefined) {
                        values[this.ws ? dataKey : this.dataKeys[dataKey]] = value;
                    }
                }
            }

            this.showBusy();

            $.ajax(this.ajaxOptions({
                data: this.ws ? (this.editing.mode == 'InCell' ? values : { value: values }) : values,
                url: this.url(url),
                hasErrors: $.proxy(this.hasErrors, this),
                commandName: commandName,
                displayErrors: $.proxy(this.displayErrors, this)
            }));
        },

        displayErrors: function (data) {
            this.errorView.bind($('#' + this.formId()), data.modelState);
        },

        hasErrors: function (data) {
            var modelState = data.modelState;
            var result = false;

            if (modelState) {
                $.each(modelState, function (key, value) {
                    if ('errors' in value) {
                        result = true;
                        return false;
                    }
                });
            }

            return result;
        },

        formId: function () {
            return $(this.element).attr('id') + 'form';
        },

        validation: function () {
            this.validator().parse();
        },

        validator: function () {
            if (this.validationMetadata) {
                return new Mvc2Validator(this.validationMetadata);
            } else {
                return new UnobtrusiveValidator("#" + this.formId());
            }
        }
    }

    $t.grid.ModelBinder = function () {
        this.binders = {
            ':input.t-autocomplete': function () {
                return $(this).val();
            },
            '.t-numerictextbox :input': function () {
                return $(this).data('tTextBox')
                              .value();
            },
            ':input[name]:not(.t-input, :radio, :button),:radio:checked': function () {
                return $(this).val();
            },
            ':checkbox': function () {
                return $(this).is(':checked');
            },
            '.t-datepicker :input': function () {
                return $(this).data('tDatePicker')
                              .value();
            },
            '.t-timepicker :input': function () {
                return $(this).data('tTimePicker')
                              .value();
            },
            '.t-datetimepicker :input': function () {
                return $(this).data('tDateTimePicker')
                              .value();
            },
            '.t-editor textarea:hidden': function () {
                var editor = $(this).closest(".t-editor")
                                    .data("tEditor");
                if (editor.encoded) {
                    return editor.encodedValue();
                }
                return editor.value();
            }
        };

        this.bind = function ($ui) {
            var model = {};

            $.each(this.binders, function (selector, callback) {
                $ui.find(selector).each(function () {
                    if (!this.disabled) model[this.name] = callback.call(this);
                });
            });

            return model;
        }
    }

    $t.grid.FormViewBinder = function (converters) {
        this.converters = converters || {};
        this.binders = {
            ':input:not(:radio):not([type="file"])': function (value) {
                if (typeof value == 'boolean') {
                    value = value + "";
                }
                $(this).val(value);
            },
            ':checkbox': function (value) {
                $(this).attr('checked', value == true);
            },
            ':radio': function (value) {
                var input = $(this).val();
                if (typeof value == 'boolean') {
                    input = input.toLowerCase();
                }
                if (input == value.toString()) {
                    $(this).attr('checked', true);
                }
            }
        };

        function evaluator(type) {
            return function (value) {
                $(this).data(type)
                       .value(value);
            };
        }

        function editorEvaluator() {
            return function (value) {
                $(this).closest(".t-editor")
                       .data("tEditor")
                       .value(value);
            };
        }

        this.binders['.t-numerictextbox :input'] = evaluator('tTextBox');
        this.binders['.t-dropdown :input:hidden'] = evaluator('tDropDownList');
        this.binders['.t-datepicker :input'] = evaluator("tDatePicker");
        this.binders['.t-datetimepicker :input'] = evaluator("tDateTimePicker");
        this.binders['.t-timepicker :input'] = evaluator("tTimePicker");
        this.binders['.t-slider :input'] = evaluator("tSlider");
        this.binders['.t-combobox :input:hidden'] = evaluator('tComboBox');
        this.binders['.t-editor textarea:hidden'] = editorEvaluator();

        this.evaluate = function (model, expression) {
            if (expression != null) {
                var value = model, match = false, members = expression.split('.');

                while (members.length) {
                    var member = members.shift();

                    if (member.indexOf("[") > -1) {
                        value = new Function("d", "try { return d." + member + "}catch(e){}")(value);
                        if (value != null) {
                            match = true;
                        } else {
                            value = model;
                        }
                    } else if (value != null && typeof (value[member]) != 'undefined') {
                        value = value[member];
                        match = true;
                    } else if (match) {
                        match = false;
                        break;
                    }
                }

                if (match && !$.isPlainObject(value)) {
                    var date = dateRe.exec(value);
                    if (date)
                        value = new Date(parseInt(date[1]));

                    var type = $t.getType(value);

                    if (type in this.converters)
                        value = this.converters[type](expression, value);

                    return value;
                }
            }
        }

        this.bind = function ($ui, model) {
            var undefined;

            $.each(this.binders, $.proxy(function (selector, callback) {
                $ui.find(selector).each($.proxy(function (index, element) {
                    var value = this.evaluate(model, element.name);
                    if (value != undefined)
                        callback.call(element, value);
                }, this));
            }, this));
        }
    }

    $t.grid.CellBuilder = function (options) {
        function impl(dataItem, method) {
            var editableIndex = 0;
            $.each(options.columns, function(index, column) {
                if (!column.readonly && !column.hidden) {
                    editableIndex = index;
                    return false;
                }
            });

            return $.map(options.columns, function (column, index) {
                var className;

                if (index == 0 && method == "insert") {
                    className = "t-grid-edit-cell";
                } else if (index == options.columns.length - 1) {
                    className = "t-last";
                }                                

                return '<td ' + (column.attr ? column.attr : '') + (className ? ' class="' + className + '"' : "") + ">" +
                            column[index == editableIndex ? method : 'display'](dataItem) +
                       '</td>';
            }).join('');
        }

        this.edit = function (dataItem) {
            return impl(dataItem, 'edit');
        }

        this.insert = function (dataItem) {
            return impl(dataItem, 'insert');
        }

        this.display = function (dataItem) {
            return impl(dataItem, 'display');
        }
    }

    $t.grid.DataCellBuilder = function (options) {

        function impl(dataItem, method) {
            return $.map(options.columns, function (column, index) {
                return '<td ' + (column.attr ? column.attr : '') + (index == options.columns.length - 1 ? ' class="t-last">' : '>') +
                            column[method](dataItem) +
                       '</td>';
            }).join('');
        }

        this.edit = function (dataItem) {
            return impl(dataItem, 'edit');
        }

        this.insert = function (dataItem) {
            return impl(dataItem, 'insert');
        }

        this.display = function (dataItem) {
            if (options.rowTemplate) {
                return '<td colspan="' + options.columns.length + '">' + options.rowTemplate(dataItem) + "</td>";
            }

            return impl(dataItem, 'display');
        }
    }

    $t.grid.FormContainerBuilder = function (options) {
        function impl(method) {
            return '<div class="t-edit-form-container">' +
                        options.html() +
                        options[method]() +
                   '</div>';
        }

        this.edit = function () {
            return impl('edit');
        }

        this.insert = function () {
            return impl('insert');
        }
    }

    function form(id) {
        return $('<form />', { id: id }).addClass('t-edit-form').submit($t.preventDefault);
    }

    $t.grid.PopUpEditor = function (options) {

        var wnd;

        function destroy() {
            var w = wnd.data('tWindow');
            w && w.close();
            wnd.remove();
        }

        function impl(dataItem, method) {
            var settings = options.settings;

            wnd = $('<div />', { id: options.container.id + 'PopUp' })
                    .appendTo(options.container)
                    .css({ top: 0, left: '50%', marginLeft: -90 })
                    .tWindow(settings)
                    .find('.t-window-content')
                    .append(options[method](dataItem))
                    .wrapInner(form(options.id))
                    .end();

            $(options.container).one('dataBound', destroy);

            wnd.find('.t-close')
               .click($t.stopAll(destroy))
               .end()
               .data('tWindow')
               .open()
               .title((settings && settings.title) ? settings.title : options[method + 'Title']);

            return wnd;
        }

        this.edit = function (tr, dataItem) {
            tr.addClass('t-grid-edit-row');
            return impl(dataItem, 'edit').data('tr', tr);
        }

        this.insert = function (tr, dataItem) {
            return impl(dataItem, 'insert');
        }

        this.cancel = function (tr) {
            tr.removeClass('t-grid-edit-row');
            destroy();
        }
    }

    $t.grid.Editor = function (options) {
        var groups = options.groups || function () { return 0 };

        function impl(tr, dataItem, method) {
            var td = tr.find('.t-group-cell,.t-hierarchy-cell');

            tr.addClass('t-grid-edit-row')
              .empty()
              .append(td)
              .append(options[method](dataItem))
              .closest('table')
              .wrap(function () {
                  if (!$(this).parent().is('form'))
                      return form(options.id);
              });
        }

        this.cancel = function (tr, dataItem) {
            if (tr.is('.t-grid-new-row')) {
                tr.remove();
            } else {
                impl(tr, dataItem, 'cancel');
                tr.removeClass('t-grid-edit-row');
            }
        }

        this.insert = function (container, dataItem) {
            var html = '<tr class="t-grid-new-row">' +
                       new Array(groups() + 1).join('<td class="t-group-cell" />') +
                       ((options.details) ? '<td class="t-hierarchy-cell"/>' : "") +
                       '</tr>';
            var tr = $(html);

            if (options.insertRow == "bottom") {
                container.append(tr);
            } else {
                container.prepend(tr);
            }

            impl(tr, dataItem, 'insert');

            if (options.insertRow == "bottom") {
                container.closest(".t-grid-content").scrollTop(tr[0].offsetTop + tr[0].offsetHeight);
            }

            return tr;
        }

        this.edit = function (tr, dataItem) {
            impl(tr, dataItem, 'edit');
            return tr;
        }
    }

    $t.grid.CellEditor = function (options) {

        this.edit = function (td, dataItem) {
            var column = options.columns[options.cellIndex(td)];

            if (!column.readonly) {
                td.parent()
                  .addClass('t-grid-edit-row')
                  .end()
                  .empty()
                  .html(column.edit(dataItem))
                  .closest('table')
                  .wrap(function () {
                      if (!$(this).parent().is('form'))
                          return form(options.id);
                  });

                options.bind(td, dataItem);

                options.validate();

                td.find(':input:visible:first')
                  .trigger("focusin")
                  .focus();

                td.addClass('t-grid-edit-cell');

                if ($.browser.msie && $.browser.version < 9) {
                    var dataArea = td.closest('.t-grid-content');
                    dataArea.scrollLeft(dataArea.scrollLeft());
                }
            }

            return !column.readonly;
        }

        this.display = function (td, dataItem) {
            var column = options.columns[options.cellIndex(td)];

            td.removeClass('t-grid-edit-cell')
              .empty()
              .html(column.display(dataItem))
              .parent()
              .removeClass('t-grid-edit-row');
        }
    }

    $t.grid.ChangeLog = function (size, insertRowPosition) {
        this.insert = function (index, values) {
            if (values == undefined) {
                values = index;
                if (insertRowPosition == "bottom") {
                    this.inserted.push(values);
                } else {
                    this.inserted.splice(0, 0, values);
                }
            } else {
                var original = this.inserted[index];

                if (original === undefined) {
                    this.inserted.splice(0, 0, values);
                } else {
                    $.extend(original, values);
                }
            }
        }

        this.get = function (index) {
            var inserted = this.inserted[index];

            if (this.inserted[index]) {
                return inserted;
            }

            return this.updated[index - this.inserted.length];
        }

        this.update = function (index, original, values) {
            index = index - this.inserted.length;

            var last = this.updated[index] || original || {};

            var dirty = false;

            for (var member in values) {
                var sourceValue = last[member],
                    destValue = values[member];

                if (sourceValue instanceof Date) {
                    if (destValue instanceof Date && destValue.getTime() !== sourceValue.getTime()) {
                        dirty = true;
                    }
                } else if (destValue !== sourceValue) {
                    dirty = true;
                }
            }

            if (dirty) {
                this.updated[index] = $.extend({}, last, values);
            }

            return dirty;
        }

        this.erase = function (index, values) {
            var inserted = this.inserted[index];

            if (inserted) {
                this.inserted.splice(index, 1);
            } else {
                index = index - this.inserted.length;

                var updated = this.updated[index];
                if (updated) {
                    delete this.updated[index];
                }

                this.deleted[index] = values;
            }
        }

        this.clear = function () {
            this.updated = new Array(size);
            this.deleted = new Array(size);
            this.inserted = [];
        }        

        this.serialize = function (inserted, updated, deleted) {
            return $.extend({},
                serialize(inserted, 'inserted', function () {
                    return true;
                }),
                serialize(updated, 'updated', function (dataItem) {
                    return dataItem !== undefined;
                }),
                serialize(deleted, 'deleted', function (dataItem) {
                    return dataItem !== undefined;
                })
            );
        }

        this.dirty = function () {

            if (this.inserted.length) {
                return true;
            }

            for (var i = 0; i < this.updated.length; i++) {
                if (this.updated[i]) {
                    return true;
                }
            }

            for (i = 0; i < this.deleted.length; i++) {
                if (this.deleted[i]) {
                    return true;
                }
            }

            return false;
        }

        this.clear();
    }

    $t.grid.ErrorView = function () {
        this.bind = function ($ui, modelState) {
            $ui.find('span[id$=_validationMessage]')
               .removeClass('field-validation-error')
               .addClass('field-validation-valid')
               .html('')
               .end()
               .find('.input-validation-error')
               .removeClass('input-validation-error')
               .addClass('valid');

            $.each(modelState, function (key, value) {
                if ('errors' in value && value.errors[0]) {
                    var originalKey = key;
                    key = key.replace('.', '_');
                    $ui.find('#' + key + '_validationMessage, [data-valmsg-for="' + originalKey + '"]')
                       .html(value.errors[0])
                       .removeClass('field-validation-valid')
                       .addClass('field-validation-error')
                       .end()
                       .find('#' + key)
                       .removeClass('valid')
                       .addClass('input-validation-error');
                }
            });
        }
    }
})(jQuery);
(function ($) {

    var $t = $.telerik,
        expandModes = {
            'single': 0,
            'multi': 1
        };

    $t.scripts.push("telerik.panelbar.js");

    $.extend($t, {
        panelbar: function (element, options) {
            this.element = element;

            $.extend(this, options);
            
            var $element = $(element),
                $content = $element.find('li.t-state-active > .t-content'),
                clickableItems = '.t-item:not(.t-state-disabled) > .t-link';

            $element
                .delegate(clickableItems, 'click', $.proxy(this._click, this))
				.delegate(clickableItems, 'mouseenter', $t.hover)
				.delegate(clickableItems, 'mouseleave', $t.leave)
                .delegate('.t-item.t-state-disabled > .t-link', 'click', $t.preventDefault);

            $t.bind(this, {
                expand: this.onExpand,
                collapse: this.onCollapse,
                select: $.proxy(function (e) {
                    if (e.target == this.element && this.onSelect) $.proxy(this.onSelect, this.element)(e);
                }, this),
                error: this.onError,
                load: this.onLoad
            });

            if (this.contentUrls)
                $element.find('> .t-item')
                    .each($.proxy(function(index, item) {
                        $(item).find('.t-link').data('ContentUrl', this.contentUrls[index]);
                    }, this));

            if ($content.length > 0 && $content.is(':empty'))
                this.expand($content.parent());
        }
    });

    $t.panelbar.prototype = {

        expand: function (li) {
            $(li).each($.proxy(function (index, item) {
                var $item = $(item);
                if (!$item.hasClass('.t-state-disabled') && $item.find('> .t-group, > .t-content').length > 0) {

                    if (this.expandMode == expandModes.single && this._collapseAllExpanded($item))
                        return;

                    this._toggleItem($item, false, null);
                }
            }, this));
        },

        collapse: function (li) {
            $(li).each($.proxy(function (index, item) {
                var $item = $(item);

                if (!$item.hasClass('.t-state-disabled') && $item.find('> .t-group, > .t-content').is(':visible'))
                    this._toggleItem($item, true, null);

            }, this));
        },

        toggle: function (li, enable) {
            $(li).each(function () {
                $(this)
                    .toggleClass('t-state-default', enable)
				    .toggleClass('t-state-disabled', !enable);
            });
        },

        enable: function (li) {
            this.toggle(li, true);
        },

        disable: function (li) {
            this.toggle(li, false);
        },

        _click: function (e) {
            var $target = $(e.target),
                element = this.element;

            if ($target.closest('.t-widget')[0] != element)
                return;

            var $link = $target.closest('.t-link'),
                $item = $link.closest('.t-item');
            
            $('.t-state-selected', element).removeClass('t-state-selected');

            $link.addClass('t-state-selected');

            if ($t.trigger(element, 'select', { item: $item[0] })) {
                e.preventDefault();
            }

            var contents = $item.find('> .t-content, > .t-group'),
                href = $link.attr('href'),
                isAnchor = $link.data('ContentUrl') || (href && (href.charAt(href.length - 1) == '#' || href.indexOf('#' + element.id + '-') != -1));

            if (isAnchor || contents.length > 0)
                e.preventDefault();
            else
                return;

            if (this.expandMode == expandModes.single)
                if (this._collapseAllExpanded($item))
                    return;

            if (contents.length != 0) {
                var visibility = contents.is(':visible');

                if (!$t.trigger(element, !visibility ? 'expand' : 'collapse', { item: $item[0] }))
                    this._toggleItem($item, visibility, e);
            }
        },

        _toggleItem: function ($element, isVisible, e) {
            var childGroup = $element.find('> .t-group');

            if (childGroup.length) {

                this._toggleGroup(childGroup, isVisible);

                if (e != null)
                    e.preventDefault();
            } else {

                var itemIndex = $element.parent().children().index($element),
                    $content = $element.find('> .t-content');

                if ($content.length) {
                    if (e != null)
                        e.preventDefault();

                    if (!$content.is(':empty'))
                        this._toggleGroup($content, isVisible);
                    else
                        this._ajaxRequest($element, $content, isVisible);
                }
            }
        },

        _toggleGroup: function ($element, visibility) {
            if ($element.is(":visible") != visibility || $element.data('animating'))
                return;

            $element
                .data('animating', true)
			    .parent()
	            .toggleClass('t-state-default', visibility)
				.toggleClass('t-state-active', !visibility)
				.find('> .t-link > .t-icon')
					.toggleClass('t-arrow-up', !visibility)
					.toggleClass('t-panelbar-collapse', !visibility)
					.toggleClass('t-arrow-down', visibility)
					.toggleClass('t-panelbar-expand', visibility);

            $t.fx[!visibility ? 'play' : 'rewind'](this.effects, $element, null, function () {
                $element.data('animating', false);
            });
        },

        _collapseAllExpanded: function ($item) {
            if ($item.find('> .t-link').hasClass('t-header')) {
                if ($item.find('> .t-content, > .t-group').is(':visible') || $item.find('> .t-content, > .t-group').length == 0) {
                    return true;
                } else {
                    $(this.element).children().find('> .t-content, > .t-group')
                            .filter(function () { return $(this).is(':visible') })
                            .each($.proxy(function (index, content) {
                                this._toggleGroup($(content), true);
                            }, this));
                }
            }
        },

        _ajaxRequest: function ($element, contentElement, isVisible) {

            var statusIcon = $element.find('.t-panelbar-collapse, .t-panelbar-expand'),
                $link = $element.find('.t-link'),
                loadingIconTimeout = setTimeout(function () {
                    statusIcon.addClass('t-loading');
                }, 100),
                data = {};

            $.ajax({
                type: 'GET',
                cache: false,
                url: $link.data('ContentUrl') || $link.attr('href'),
                dataType: 'html',
                data: data,

                error: $.proxy(function (xhr, status) {
                    if ($t.ajaxError(this.element, 'error', xhr, status))
                        return;
                }, this),

                complete: function () {
                    clearTimeout(loadingIconTimeout);
                    statusIcon.removeClass('t-loading');
                },

                success: $.proxy(function (data, textStatus) {
                    contentElement.html(data);
                    this._toggleGroup(contentElement, isVisible);
                }, this)
            });
        }
    }

    $.fn.tPanelBar = function (options) {
        return $t.create(this, {
            name: 'tPanelBar',
            init: function(element, options) { 
                return new $t.panelbar(element, options);
            },
            options: options
        });
    };

    $.fn.tPanelBar.defaults = {
        effects: $t.fx.property.defaults('height')
    };
})(jQuery);(function ($) {
    var $t = $.telerik;

    $t.scripts.push("telerik.menu.js");

    $t.menu = function (element, options) {
        this.element = element;
        this.nextItemZIndex = 100;

        $.extend(this, options);

        $('.t-item:not(.t-state-disabled)', element)
            .live('mouseenter', $t.delegate(this, this.mouseenter))
            .live('mouseleave', $t.delegate(this, this.mouseleave))
            .live('click', $t.delegate(this, this.click));

        $('.t-item:not(.t-state-disabled) > .t-link', element)
            .live('mouseenter', $t.hover)
            .live('mouseleave', $t.leave);

        $('.t-item.t-state-disabled', element)
            .live('click', function () { return false; });

        $(document).click($t.delegate(this, this.documentClick));

        $t.bind(this, {
            select: this.onSelect,
            open: this.onOpen,
            close: this.onClose,
            load: this.onLoad
        });
    }

    function getEffectOptions(item) {
        var parent = item.parent();
        return {
            direction: parent.hasClass('t-menu') ? parent.hasClass('t-menu-vertical') ? 'right' : 'bottom' : 'right'
        };
    };

    function contains(parent, child) {
        try {
            return $.contains(parent, child);
        } catch (e) {
            return false;
        }
    }

    $t.menu.prototype = {

        toggle: function (li, enable) {
            $(li).each(function () {
                $(this)
                    .toggleClass('t-state-default', enable)
                    .toggleClass('t-state-disabled', !enable);
            });
        },

        enable: function (li) {
            this.toggle(li, true);
        },

        disable: function (li) {
            this.toggle(li, false);
        },

        open: function ($li) {
            var menu = this;

            $($li).each(function () {
                var $item = $(this);

                clearTimeout($item.data('timer'));

                $item.data('timer', setTimeout(function () {
                    var $ul = $item.find('.t-group:first');
                    if ($ul.length) {
                        $t.fx.play(menu.effects, $ul, getEffectOptions($item));
                        $item.css('z-index', menu.nextItemZIndex++);
                    }
                }, 100));
            });
        },

        close: function ($li) {
            var menu = this;

            $($li).each(function (index, item) {
                var $item = $(item);

                clearTimeout($item.data('timer'));

                $item.data('timer', setTimeout(function () {
                    var $ul = $item.find('.t-group:first');
                    if ($ul.length) {
                        $t.fx.rewind(menu.effects, $ul, getEffectOptions($item), function () {
                            $item.css('zIndex', '');
                            if ($(menu.element).find('.t-group:visible').length == 0)
                                menu.nextItemZIndex = 100;
                        });
                        $ul.find('.t-group').stop(false, true);
                    }
                }, 100));
            });
        },

        mouseenter: function (e, element) {
            var $li = $(element);
            if (!this.openOnClick || this.clicked) {
                if (!contains(element, e.relatedTarget)) {
                    this.triggerEvent('open', $li);
                    this.open($li);

                    var parentItem = $li.parent().closest('.t-item')[0];

                    if (parentItem && !contains(parentItem, e.relatedTarget))
                        this.mouseenter(e, parentItem);
                }
            }

            if (this.openOnClick && this.clicked) {
                this.triggerEvent('close', $li);

                $li.siblings().each($.proxy(function (_, sibling) {
                    this.close($(sibling));
                }, this));
            }
        },

        mouseleave: function (e, element) {
            if (!this.openOnClick && !contains(element, e.relatedTarget)) {
                var $li = $(element);
                this.triggerEvent('close', $li);

                this.close($li);

                var parentItem = $li.parent().closest('.t-item')[0];

                if (parentItem && !contains(parentItem, e.relatedTarget))
                    this.mouseleave(e, parentItem);
            }
        },

        click: function (e, element) {
            e.stopPropagation();

            var $li = $(element);

            if ($li.hasClass('t-state-disabled')) {
                e.preventDefault();
                return; 
            }

            if ($t.trigger(this.element, 'select', { item: $li[0] })) {
                e.preventDefault();
                return;
            }

            if (!$li.parent().hasClass('t-menu') || !this.openOnClick)
                return;

            e.preventDefault();

            this.clicked = true;

            this.triggerEvent('open', $li);

            this.open($li);
        },

        documentClick: function (e, element) {
            if ($.contains(this.element, e.target))
                return;

            if (this.clicked) {
                this.clicked = false;
                $(this.element).children('.t-item').each($.proxy(function (i, item) {
                    this.close($(item));
                }, this));
            }
        },

        hasChildren: function ($li) {
            return $li.find('.t-group:first').length;
        },

        triggerEvent: function (eventName, $li) {
            if (this.hasChildren($li))
                $t.trigger(this.element, eventName, { item: $li[0] });
        }
    }

    $.fn.tMenu = function (options) {
        return $t.create(this, {
            name: 'tMenu',
            init: function (element, options) {
                return new $t.menu(element, options);
            },
            options: options
        });
    };

    // default options
    $.fn.tMenu.defaults = {
        orientation: 'horizontal',
        effects: $t.fx.slide.defaults(),
        openOnClick: false
    };
})(jQuery);(function ($) {

    var $t = $.telerik,
        MOUSEDOWN = $t.isTouch ? "touchstart" : "mousedown",
        PRECISION = 3;

    $t.scripts.push("telerik.slider.js");

    $t.slider = function (element, options) {
        options = options || {};
        var $element = $(element);
        element.type = "text";
        this.element = element;
        options.val = round(parseValue($element.val()) || round(options.val));
        options.distance = options.maxValue - options.minValue;
        $.extend(this, options);
        options.position = this.orientation == "horizontal" ? "left" : "bottom";
        options.size = this.orientation == "horizontal" ? "width" : "height";
        options.outerSize = this.orientation == "horizontal" ? "outerWidth" : "outerHeight";
        options.orientation = this.orientation;
        createHtml(element, options);
        this.wrapper = $element.closest(".t-slider");
        this.trackDiv = this.wrapper.find(".t-slider-track");

        $t.slider.setTrackDivWidth(this.wrapper, options);

        this.maxSelection = this.trackDiv[options.size]();

        var sizeBetweenTicks = this.maxSelection / ((this.maxValue - this.minValue) / this.smallStep);
        var pixelWidths = $t.slider.calculateItemsWidth(this.wrapper, options, Math.floor(this.distance / this.smallStep));

        if (options.tickPlacement != "none" && sizeBetweenTicks >= 2) {
            this.trackDiv.before(createSliderItems(options));
            $t.slider.setItemsWidth(this.wrapper, this.trackDiv, pixelWidths, options);
            $t.slider.setItemsTitle(this.wrapper, options);
            $t.slider.setItemsLargeTick(this.wrapper, options);
        }

        $t.slider.calculateSteps.call(this, pixelWidths);

        var settings = {
            element: element,
            dragHandle: this.wrapper.find(".t-draghandle"),
            orientation: options.orientation,
            size: options.size,
            outerSize: options.outerSize,
            position: options.position,
            owner: this
        };

        this._setValueInRange(options.val);

        this[options.enabled ? 'enable' : 'disable']();

        new $t.slider.Selection(settings);
        this._drag = new $t.slider.Drag(settings);

        this.keyMap = {
            37: decreaseValue(options.smallStep), // left arrow
            40: decreaseValue(options.smallStep), // down arrow
            39: increaseValue(options.smallStep), // right arrow
            38: increaseValue(options.smallStep), // up arrow
            35: setValue(options.maxValue), // end
            36: setValue(options.minValue), // home
            33: increaseValue(options.largeStep), // page up
            34: decreaseValue(options.largeStep)  // page down
        };

        $t.bind(this, {
            slide: this.onSlide,
            change: this.onChange,
            load: this.onLoad
        });
    };

    $.extend($t.slider, {
        setTrackDivWidth: function (wrapper, options) {
            var trackDiv = wrapper.find('.t-slider-track');
            var trackDivPosition = round(trackDiv.css(options.position)) * 2;
            trackDiv[options.size]((wrapper[options.size]() - 2) - trackDivPosition);
        },

        setItemsWidth: function (wrapper, trackDiv, pixelWidths, options) {
            var itemsCount = Math.floor(options.distance / options.smallStep),
                items = wrapper.find(".t-tick"),
                sum = 0,
                maxSelection = trackDiv[options.size](),
                arr = $.extend([], pixelWidths);

            if (options.orientation == "horizontal") {
                for (var i = 0; i < items.length - 2; i++) {
                    $(items[i + 1])[options.size](arr[i]);
                }
            } else {
                arr = arr.reverse();

                for (var i = 2; i < items.length; i++) {
                    $(items[i - 1])[options.size](arr[i]);
                }
            }

            if (options.orientation == "horizontal") {
                $(items[0]).addClass("t-first")[options.size](arr[itemsCount]);
                $(items[items.length - 1]).addClass("t-last")[options.size](arr[itemsCount - 1]);
            } else {
                $(items[items.length - 1]).addClass("t-first")[options.size](arr[0]);
                $(items[0]).addClass("t-last")[options.size](arr[1]);
            }
            
            if (options.distance % options.smallStep != 0 && options.orientation == "vertical") {
                for (var i = 0; i < arr.length; i++) {
                    sum += pixelWidths[i];
                }

                wrapper.find(".t-slider-items").css("padding-top", 29 + (maxSelection - sum));
            }
        },

        setItemsTitle: function (wrapper, options) {
            var items = wrapper.find(".t-tick"),
                titleNumber = options.minValue;

            if (options.orientation == "horizontal") {
                for (var i = 0; i < items.length; i++) {
                    $(items[i]).attr("title", $t.formatString(options.tooltip.format || "{0}", round(titleNumber)));
                    titleNumber += options.smallStep;
                }
            } else {
                for (var i = items.length - 1; i >= 0; i--) {
                    $(items[i]).attr("title", $t.formatString(options.tooltip.format || "{0}", round(titleNumber)));
                    titleNumber += options.smallStep;
                }
            }
        },

        setItemsLargeTick: function (wrapper, options) {
            if ((1000 * options.largeStep) % (1000 * options.smallStep) == 0) {
                var items = wrapper.find(".t-tick"),
                    item = {},
                    step = round(options.largeStep / options.smallStep);

                if (options.orientation == "horizontal") {
                    for (var i = 0; i < items.length; i = round(i + step)) {
                        item = $(items[i]);

                        item.addClass("t-tick-large")
                            .html($("<span class='t-label'></span>").html(item.attr("title")));
                    }
                } else {
                    for (var i = items.length - 1; i >= 0; i = round(i - step)) {
                        item = $(items[i]);

                        item.addClass("t-tick-large")
                            .html($("<span class='t-label'></span>").html(item.attr("title")));

                        if (i != 0 && i != items.length - 1) {
                            item.css('line-height', item[options.size]() + 'px');
                        }
                    }
                }
            }
        },

        calculateItemsWidth: function (wrapper, options, itemsCount) {
            var trackDivSize = parseFloat(wrapper.find('.t-slider-track').css(options.size)) + 1,
                pixelStep = trackDivSize / options.distance;

            if ((options.distance / options.smallStep) - Math.floor(options.distance / options.smallStep) > 0) {
                trackDivSize -= ((options.distance % options.smallStep) * pixelStep);
            }

            var itemWidth = trackDivSize / itemsCount,
                pixelWidths = [];

            for (var i = 0; i < itemsCount - 1; i++) {
                pixelWidths[i] = itemWidth;
            }

            pixelWidths[itemsCount - 1] = pixelWidths[itemsCount] = itemWidth / 2;

            return this.roundWidths(pixelWidths);
        },

        roundWidths: function (pixelWidthsArray) {
            var balance = 0;

            for (i = 0; i < pixelWidthsArray.length; i++) {
                balance += (pixelWidthsArray[i] - Math.floor(pixelWidthsArray[i]));
                pixelWidthsArray[i] = Math.floor(pixelWidthsArray[i]);
            }

            balance = Math.round(balance);

            return this.addAdditionalSize(balance, pixelWidthsArray);
        },

        addAdditionalSize: function (additionalSize, pixelWidthsArray) {
            if (additionalSize == 0) {
                return pixelWidthsArray;
            }

            //set step size
            var step = parseFloat(pixelWidthsArray.length - 1) / parseFloat(additionalSize == 1 ? additionalSize : additionalSize - 1);

            for (var i = 0; i < additionalSize; i++) {
                pixelWidthsArray[parseInt(Math.round(step * i))] += 1;
            }

            return pixelWidthsArray;
        },

        getValueFromPosition: function (mousePosition, dragableArea, owner) {
            var step = Math.max(owner.smallStep * (owner.maxSelection / owner.distance), 0),
                position = 0,
                halfStep = (step / 2);

            if (owner.orientation == "horizontal") {
                position = mousePosition - dragableArea.startPoint;
            } else {
                position = dragableArea.startPoint - mousePosition;
            }

            if (owner.maxSelection - ((parseInt(owner.maxSelection % step) - 3) / 2) < position) {
                return owner.maxValue;
            }

            for (var i = 0; i < owner._pixelStepsArray.length; i++) {
                if (Math.abs(owner._pixelStepsArray[i] - position) - 1 <= halfStep) {
                    return round(owner._valuesArray[i]);
                }
            }
        },
        
        getDragableArea: function (trackDiv, maxSelection, orientation) {
            var offsetLeft = trackDiv.offset().left,
                offsetTop = trackDiv.offset().top;

            return {
                startPoint: orientation == "horizontal" ? offsetLeft : offsetTop + maxSelection,
                endPoint: orientation == "horizontal" ? offsetLeft + maxSelection : offsetTop
            };
        },

        calculateSteps: function (pixelWidths) {
            var that = this,
                val = that.minValue,
                selection = 0,
                itemsCount = Math.ceil(that.distance / that.smallStep),
                i = 1;

            itemsCount += (that.distance / that.smallStep) % 1 == 0 ? 1 : 0;
            pixelWidths.splice(0, 0, pixelWidths.pop() * 2);
            pixelWidths.splice(itemsCount, 1, pixelWidths.pop() * 2);

            that._pixelStepsArray = [selection];
            that._valuesArray = [val];

            if (itemsCount == 0) {
                return;
            }

            while (i < itemsCount) {
                selection += (pixelWidths[i - 1] + pixelWidths [i]) / 2;
                that._pixelStepsArray[i] = selection;
                that._valuesArray[i] = val += that.smallStep;

                i++;
            }

            var lastItem = that.distance % that.smallStep == 0 ? itemsCount - 1 : itemsCount;

            that._pixelStepsArray[lastItem] = that.maxSelection;
            that._valuesArray[lastItem] = that.maxValue;
        }
    });

    function increaseValue(step) {
        return function (value) {
            return value + step;
        }
    }

    function decreaseValue(step) {
        return function (value) {
            return value - step;
        }
    }

    function setValue(value) {
        return function () {
            return value;
        }
    }

    function parseValue(value) {
        return value.toString().replace($t.cultureInfo.numericdecimalseparator, ".");
    }

    function round(value) {
        value = (value + "").replace($t.cultureInfo.numericdecimalseparator, ".");
        value = parseFloat(value, 10);
        var power = Math.pow(10, PRECISION || 0);
        return Math.round(value * power) / power;
    }

    $t.slider.prototype = {
        enable: function () {
            this.wrapper
                .removeAttr("disabled")
                .removeClass("t-state-disabled")
                .addClass("t-state-default");

            var clickHandler = $.proxy(function (e) {
                if ($(e.target).hasClass("t-draghandle"))
                    return;

                this._drag.start(e);
            }, this);

            this.wrapper
                .find(".t-tick").bind(MOUSEDOWN, clickHandler)
                .end()
                .find(".t-slider-track").bind(MOUSEDOWN, clickHandler);

            var move = $.proxy(function (sign) {
                this._setValueInRange(this._nextValueByIndex(this._valueIndex + (sign * 1)));
            }, this);

            if (this.showButtons) {
                var mouseDownHandler = $.proxy(function(e, sign) {
                    if (e.which == 1) {
                        move(sign);

                        this.timeout = setTimeout($.proxy(function () {
                            this.timer = setInterval(function () {
                                move(sign)
                            }, 60);
                        }, this), 200);
                    }
                }, this);

                this.wrapper.find(".t-button")
                    .unbind("mousedown")
                    .unbind("mouseup")
                    .bind("mouseup", $.proxy(function (e) {
                        this._clearTimer();
                    }, this))
                    .unbind("mouseover")
                    .bind("mouseover", function (e) {
                        $(e.currentTarget).addClass("t-state-hover");
                    })
                    .unbind("mouseout")
                    .bind("mouseout", $.proxy(function (e) {
                        $(e.currentTarget).removeClass("t-state-hover");
                        this._clearTimer();
                    }, this))
                    .eq(0)
                    .bind("mousedown", $.proxy(function (e) {
                        mouseDownHandler(e, 1);
                        e.preventDefault();
                    }, this))
                    .end()
                    .eq(1)
                    .bind("mousedown", $.proxy(function (e) {
                        mouseDownHandler(e, -1);
                        e.preventDefault();
                    }, this))
            }

            this.wrapper
                .find(".t-draghandle").bind({
                    keydown: $.proxy(this._keydown, this)
                });

            this.enabled = true;
        },

        disable: function () {
            this.wrapper
                .attr("disabled", "disabled")
                .removeClass("t-state-default")
                .addClass("t-state-disabled");

            var preventDefault = $t.preventDefault;

            this.wrapper
                .find(".t-button")
                .unbind("mousedown")
                .bind("mousedown", preventDefault)
                .unbind("mouseup")
                .bind("mouseup", preventDefault)
                .unbind("mouseleave")
                .bind("mouseleave", preventDefault)
                .unbind("mouseover")
                .bind("mouseover", preventDefault);

            this.wrapper
                .find(".t-tick").unbind(MOUSEDOWN)
                .end()
                .find(".t-slider-track").unbind(MOUSEDOWN);

            this.wrapper
                .find(".t-draghandle")
                .unbind("keydown")
                .bind("keydown", preventDefault);

            this.enabled = false;
        },
        
        _nextValueByIndex: function (index) {
            var count = this._valuesArray.length;
            return this._valuesArray[Math.max(0, Math.min(index, count - 1))];
        },

        _update: function (val) {
            var change = this.value() != val;

            this.value(val);

            if (change) {
                $t.trigger(this.element, 'change', { value: this.val });
            }
        },

        value: function (val) {
            val = round(val);
            if (isNaN(val)) {
                return this.val;
            }

            if (val >= this.minValue && val <= this.maxValue) {
                if (this.val != val) {
                    $(this.element).attr("value", parseValue(round(val)));
                    this.val = val;
                    this.refresh();
                }
            }
        },

        refresh: function () {
            $t.trigger(this.element, 't:moveSelection', { value: this.val });
        },

        _clearTimer: function (e) {
            clearTimeout(this.timeout);
            clearInterval(this.timer);
        },

        _keydown: function (e) {
            if (e.keyCode in this.keyMap) {
                this._setValueInRange(this.keyMap[e.keyCode](this.val));
                e.preventDefault();
            }
        },

        _setValueInRange: function (val) {
            val = round(val);
            
            if (isNaN(val)) {
                this._update(this.minValue);
                return;
            }

            val = Math.max(val, this.minValue);
            val = Math.min(val, this.maxValue);
            this._update(val);
        }
    };

    $t.slider.Selection = function (options) {
        var $element = $(options.element),
            owner = options.owner;

        function moveSelection (val) {
            var selectionValue = val - owner.minValue,
                index = owner._valueIndex = Math.ceil(round(selectionValue / owner.smallStep)),
                selection = owner._pixelStepsArray[index],
                selectionDiv = owner.trackDiv.find(".t-slider-selection"),
                halfDragHanndle = parseInt(options.dragHandle[options.outerSize]() / 2, 10) + 1;

            selectionDiv[options.size](selection);
            options.dragHandle.css(options.position, selection - halfDragHanndle);
        }

        moveSelection(owner.val);

        var handler = function (e) {
            moveSelection(round(e.value));
        };

        $element.bind({ "change": handler, "slide": handler, "t:moveSelection": handler });
    };

    $t.slider.Drag = function (options) {
        options.dragHandleSize = options.dragHandle[options.outerSize]();
        
        $.extend(this, options);

        this.draggable = new $t.draggable({
            distance: 0,
            owner: options.dragHandle,
            scope: options.element.id,
            start: $.proxy(this._start, this),
            drag: $.proxy(this.drag, this),
            stop: $.proxy(this.stop, this)
        });
    };

    $t.slider.Drag.prototype = {
        start: function (e) {
            var location = $t.touchLocation(e);
            this.draggable._startDrag(e.currentTarget, location);
            this.draggable._start(e);
            this.draggable._drag(e); // distance is 0, we need to manually fire the slide.
        },

        _start: function (e) {
            if (!this.owner.enabled) {
                return false;
            }

            $(this.element).unbind('mouseover');

            this.val = round($(this.element).val());
            this.dragableArea = $t.slider.getDragableArea(this.owner.trackDiv, this.owner.maxSelection, this.orientation);
            this.step = Math.max(this.owner.smallStep * (this.owner.maxSelection / this.owner.distance), 0);

            this.selectionStart = this.owner.selectionStart;
            this.selectionEnd = this.owner.selectionEnd;
            this.oldVal = this.val;
            this.format = this.owner.tooltip.format || "{0}";

            if (this.type) {
                this.owner._setZIndex(this.type);
            }

            if (this.owner.tooltip.enabled) {
                this.tooltipDiv = $("<div class='t-widget t-tooltip'></div>").appendTo(document.body);

                if (this.type) {
                    var formattedSelectionStart = $t.formatString(this.format, this.selectionStart),
                        formattedSelectionEnd = $t.formatString(this.format, this.selectionEnd);

                    this.tooltipDiv.html(formattedSelectionStart + ' - ' + formattedSelectionEnd );
                } else {
                    var tooltipArrow = "t-callout-";

                    if (this.orientation == "horizontal") {
                        if (this.owner.tickPlacement == "topLeft") {
                            tooltipArrow += "n";
                        } else {
                            tooltipArrow += "s";
                        }                    } else {
                        if (this.owner.tickPlacement == "topLeft") {
                            tooltipArrow += "w";
                        } else {
                            tooltipArrow += "e";
                        }
                    }

                    this.tooltipInnerDiv = "<div class='t-callout " + tooltipArrow + "'></div>";
                    this.tooltipDiv.html($t.formatString(this.owner.tooltip.format || "{0}", this.val) + this.tooltipInnerDiv);
                }

                this.moveTooltip();
            }
        },

        drag: function (e) {
            var location = $t.touchLocation(e);

            if (this.orientation == "horizontal") {
                this.val = this.horizontalDrag(location.x);
            } else {
                this.val = this.verticalDrag(location.y);
            }

            if (this.oldVal != this.val) {
                this.oldVal = this.val;

                if (this.type) {
                    if (this.type == "firstHandle") {
                        if (this.val < this.selectionEnd) {
                            this.selectionStart = this.val;
                        } else {
                            this.selectionStart = this.selectionEnd = this.val;
                        }
                    } else {
                        if (this.val > this.selectionStart) {
                            this.selectionEnd = this.val;
                        } else {
                            this.selectionStart = this.selectionEnd = this.val;
                        }
                    }

                    $t.trigger(this.element, "slide", { values: [this.selectionStart, this.selectionEnd] });

                    if (this.owner.tooltip.enabled) {
                        var formattedSelectionStart = $t.formatString(this.format, this.selectionStart),
                            formattedSelectionEnd = $t.formatString(this.format, this.selectionEnd);

                        this.tooltipDiv.html(formattedSelectionStart + ' - ' + formattedSelectionEnd );
                    }
                } else {
                    $t.trigger(this.element, "slide", { value: this.val });

                    if (this.owner.tooltip.enabled) {
                        this.tooltipDiv.html($t.formatString(this.format, this.val) + this.tooltipInnerDiv);
                    }
                }

                if (this.owner.tooltip.enabled) {
                    this.moveTooltip();
                }
            }
        },

        stop: function (e) {
            if ($t.isTouch)
                e.preventDefault();
            
            if (e.keyCode == 27) { // ESC
                this.owner.refresh();
            } else {
                if (this.type) {
                    this.owner._update(this.selectionStart, this.selectionEnd);
                } else {
                    this.owner._update(this.val);
                }
            }

            if (this.owner.tooltip.enabled) {
                this.tooltipDiv.remove();
            }

            $(this.element).bind('mouseover');

            return false;
        },

        moveTooltip: function () {
            var that = this,
                top = 0,
                left= 0,
                margin = 4,
                callout = that.tooltipDiv.find(".t-callout");

            if (that.type) {
                var dragHandles = that.owner.wrapper.find(".t-draghandle"),
                    firstDragHandleOffset = dragHandles.eq(0).offset(),
                    secondDragHandleOffset = dragHandles.eq(1).offset();

                if (that.orientation == "horizontal") {
                    top = secondDragHandleOffset.top;
                    left = firstDragHandleOffset.left + ((secondDragHandleOffset.left - firstDragHandleOffset.left) / 2);
                } else {
                    top = firstDragHandleOffset.top + ((secondDragHandleOffset.top - firstDragHandleOffset.top) / 2);
                    left = secondDragHandleOffset.left;
                }
            } else {
                var dragHandleOffset = that.dragHandle.offset();

                top = dragHandleOffset.top;
                left = dragHandleOffset.left;
            }

            if (that.orientation == "horizontal") {
                left -= Math.round((that.tooltipDiv.outerWidth() - that.dragHandle[that.outerSize]()) / 2);
                top -= that.tooltipDiv.outerHeight() + callout.height() + margin;
            } else {
                top -= Math.round((that.tooltipDiv.outerHeight() - that.dragHandle[that.outerSize]()) / 2);
                left -= that.tooltipDiv.outerWidth() + callout.width() + margin;
            }

            that.tooltipDiv.css({ top: top, left: left });
        },

        horizontalDrag: function (x) {
            var val = 0;

            if (this.dragableArea.startPoint < x && x < this.dragableArea.endPoint) {
                val = $t.slider.getValueFromPosition(x, this.dragableArea, this.owner);
            } else if (x >= this.dragableArea.endPoint) {
                val = this.owner.maxValue;
            } else {
                val = this.owner.minValue;
            }

            return val;
        },

        verticalDrag: function (y) {
            var val = 0;

            if (this.dragableArea.startPoint > y && y > this.dragableArea.endPoint) {
                val = $t.slider.getValueFromPosition(y, this.dragableArea, this.owner);
            } else if (y <= this.dragableArea.endPoint) {
                val = this.owner.maxValue;
            } else {
                val = this.owner.minValue;
            }

            return val;
        }
    };

    function createWrapper (options, element) {
        var $element = $(element),
            orientationCssClass = options.orientation == "horizontal" ? " t-slider-horizontal" : " t-slider-vertical",
            tickPlacementCssClass;

        if (options.tickPlacement == "bottomRight") {
            tickPlacementCssClass = " t-slider-bottomright";
        } else if (options.tickPlacement == "topLeft") {
            tickPlacementCssClass = " t-slider-topleft";
        }

        var style = options.style ? options.style : $element.attr("style");

        return new $t.stringBuilder()
                     .cat("<div class='t-widget t-slider")
                     .cat(orientationCssClass)
                     .catIf(" ", $element.attr("class"), $element.attr("class"))
                     .cat("'")
                     .catIf(" style='", style, "'", style)
                     .cat(">")
                     .cat("<div class='t-slider-wrap")
                     .catIf(" t-slider-buttons", options.showButtons)
                     .catIf(tickPlacementCssClass, tickPlacementCssClass)
                     .cat("'></div></div>")
                     .string();
    }

    function createButton (options, type) {
        var buttonCssClass,
            isHorizontal = options.orientation == "horizontal";

        if (type == "increase") {
            buttonCssClass = isHorizontal ? "t-arrow-next" : "t-arrow-up";
        } else {
            buttonCssClass = isHorizontal ? "t-arrow-prev" : "t-arrow-down";
        }

        return new $t.stringBuilder()
                     .cat("<a ")
                     .cat("class='t-button ")
                     .cat("t-button-" + type)
                     .cat("'><span class='t-icon ")
                     .cat(buttonCssClass)
                     .cat("' title='")
                     .cat(options[type + "ButtonTitle"])
                     .cat("'>")
                     .cat(options[type + "ButtonTitle"])
                     .cat("</span></a>")
                     .string();
    }

    function createSliderItems (options) {
        return new $t.stringBuilder()
                     .cat("<ul class='t-reset t-slider-items'>")
                     .rep("<li class='t-tick'>&nbsp;</li>", (Math.floor((options.distance / options.smallStep).toFixed(3), 10) + 1))
                     .cat("</ul>")
                     .string();
    }

    function createTrack ($element) {
        var dragHandleCount = $element.is("input") ? 1 : 2;

        return new $t.stringBuilder()
                     .cat("<div class='t-slider-track'>")
                     .cat("<div class='t-slider-selection'></div>")
                     .cat("<a href='javascript:void(0)' class='t-draghandle' title='Drag'>Drag</a>")
                     .catIf("<a href='javascript:void(0)' class='t-draghandle t-draghandle1' title='Drag'>Drag</a>", dragHandleCount > 1)
                     .cat("</div>")
                     .string();
    }

    function createHtml (element, options) {
        var $element = $(element);
        $element.val(options.val);
        $element.wrap(createWrapper(options, element)).hide();

        if (options.showButtons) {
            $element.before(createButton(options, "increase"))
                    .before(createButton(options, "decrease"));
        }

        $element.before(createTrack($element));
    }

    // jQuery extender
    $.fn.tSlider = function (options) {
        return $t.create(this, {
            name: "tSlider",
            init: function (element, options) {
                return new $t.slider(element, options);
            },
            options: options
        });
    };

    // default options
    $.fn.tSlider.defaults = {
        enabled: true,
        minValue: 0,
        maxValue: 10,
        smallStep: 1,
        largeStep: 5,
        showButtons: true,
        increaseButtonTitle: "Increase",
        decreaseButtonTitle: "Decrease",
        orientation: "horizontal",
        tickPlacement: "both",
        tooltip: { enabled: true, format: "{0}" }
    };

    //
    // RangeSlider
    //

    $t.rangeSlider = function (element, options) {
        var $element = $(element),
            inputs = $(element).find("input");
        options = options || {};
        inputs[0].type = "text";
        inputs[1].type = "text";
        options.selectionStart = round(parseValue(inputs.eq(0).val()) || options.selectionStart);
        options.selectionEnd = round(parseValue(inputs.eq(1).val()) || options.selectionEnd);

        this.values(options.selectionStart, options.selectionEnd);
        this.element = element;
        options.distance = options.maxValue - options.minValue;
        $.extend(this, options);
        options.position = this.orientation == "horizontal" ? "left" : "bottom";
        options.size = this.orientation == "horizontal" ? "width" : "height";
        options.outerSize = this.orientation == "horizontal" ? "outerWidth" : "outerHeight";

        createHtml(element, options);
        this.wrapper = $element.closest(".t-slider");
        this.trackDiv = this.wrapper.find(".t-slider-track");

        $t.slider.setTrackDivWidth(this.wrapper, options);
        this.maxSelection = this.trackDiv[options.size]();

        var sizeBetweenTicks = this.maxSelection / ((this.maxValue - this.minValue) / this.smallStep);
        var pixelWidths = $t.slider.calculateItemsWidth(this.wrapper, options, Math.floor(this.distance / this.smallStep));

        if (options.tickPlacement != "none" && sizeBetweenTicks >= 2) {
            this.trackDiv.before(createSliderItems(options));
            $t.slider.setItemsWidth(this.wrapper, this.trackDiv, pixelWidths, options);
            $t.slider.setItemsTitle(this.wrapper, options);
            $t.slider.setItemsLargeTick(this.wrapper, options);
        }

        $t.slider.calculateSteps.call(this, pixelWidths);

        this._correctValues(this.selectionStart, this.selectionEnd);

        var leftDrag = {
            element: element,
            type: "firstHandle",
            dragHandle: this.wrapper.find(".t-draghandle:first"),
            orientation: options.orientation,
            size: options.size,
            outerSize: options.outerSize,
            position: options.position,
            owner: this
        };

        this._firstHandleDrag = new $t.slider.Drag(leftDrag);
        new $t.rangeSlider.Selection(leftDrag);

        var rightDrag = {
            element: element,
            type: "lastHandle",
            outerSize: options.outerSize,
            dragHandle: this.wrapper.find(".t-draghandle:last"),
            orientation: options.orientation,
            size: options.size,
            position: options.position,
            owner: this
        };

        this._lastHandleDrag = new $t.slider.Drag(rightDrag);

        this[options.enabled ? 'enable' : 'disable']();

        this.keyMap = {
            37: decreaseValue(options.smallStep), // left arrow
            40: decreaseValue(options.smallStep), // down arrow
            39: increaseValue(options.smallStep), // right arrow
            38: increaseValue(options.smallStep), // up arrow
            35: setValue(options.maxValue), // end
            36: setValue(options.minValue), // home
            33: increaseValue(options.largeStep), // page up
            34: decreaseValue(options.largeStep)  // page down
        };

        $t.bind(this, {
            slide: this.onSlide,
            change: this.onChange,
            load: this.onLoad
        });
    };

    $t.rangeSlider.prototype = {
        enable: function () {
            this.wrapper
                .removeAttr("disabled")
                .removeClass("t-state-disabled")
                .addClass("t-state-default");

            var clickHandler = $.proxy(function (e) {
                if ($(e.target).hasClass("t-draghandle"))
                    return;

                var location = $t.touchLocation(e),
                    mousePosition = this.orientation == "horizontal" ? location.x : location.y,
                    dragableArea = $t.slider.getDragableArea(this.trackDiv, this.maxSelection, this.orientation),
                    val = $t.slider.getValueFromPosition(mousePosition, dragableArea, this);

                if (val < this.selectionStart) {
                    this._firstHandleDrag.start(e);
                } else if (val > this.selectionEnd) {
                    this._lastHandleDrag.start(e);
                } else {
                    if (val - this.selectionStart <= this.selectionEnd - val) {
                        this._firstHandleDrag.start(e);
                    } else {
                        this._lastHandleDrag.start(e);
                    }
                }
            }, this);

            this.wrapper
                .find(".t-tick").bind(MOUSEDOWN, clickHandler)
                .end()
                .find(".t-slider-track").bind(MOUSEDOWN, clickHandler);

            this.wrapper.find(".t-draghandle")
                .eq(0).bind({
                    keydown: $.proxy(function(e) {
                        this._keydown(e, true);
                    }, this)
                })
                .end()
                .eq(1).bind({
                    keydown: $.proxy(function(e) {
                        this._keydown(e, false);
                    }, this)
                });

            this.enabled = true;
        },

        disable: function () {
            this.wrapper
                .attr("disabled", "disabled")
                .removeClass("t-state-default")
                .addClass("t-state-disabled");

            this.wrapper
                .find(".t-tick").unbind(MOUSEDOWN)
                .end()
                .find(".t-slider-track").unbind(MOUSEDOWN);

            this.wrapper
                .find(".t-draghandle")
                .unbind("keydown")
                .bind("keydown", $t.preventDefault);

            this.enabled = false;
        },

        _keydown: function (e, isFirstHandle) {
            var selectionStartValue = this.selectionStart,
                selectionEndValue = this.selectionEnd;

            if (e.keyCode in this.keyMap) {
                if (isFirstHandle) {
                    selectionStartValue = this.keyMap[e.keyCode](selectionStartValue);

                    if (selectionStartValue > selectionEndValue) {
                        selectionEndValue = selectionStartValue;
                    }
                } else {
                    selectionEndValue = this.keyMap[e.keyCode](selectionEndValue);

                    if (selectionEndValue < selectionStartValue) {
                        selectionStartValue = selectionEndValue;
                    }
                }

                this._setValueInRange(selectionStartValue, selectionEndValue);
                e.preventDefault();
            }
        },

        _update: function (selectionStart, selectionEnd) {
            var values = this.values();

            var change = values[0] != selectionStart || values[1] != selectionEnd;

            this.values(selectionStart, selectionEnd);

            if (change) {
                $t.trigger(this.element, 'change', { values: [selectionStart, selectionEnd] });
            }
        },

        values: function (selectionStart, selectionEnd) {
            var values = [this.selectionStart, this.selectionEnd];

            selectionStart = round(selectionStart);
            if (isNaN(selectionStart)) {
                return values;
            }

            selectionEnd = round(selectionEnd);
            if (isNaN(selectionEnd)) {
                return values;
            }

            if (selectionStart >= this.minValue && selectionStart <= this.maxValue
            && selectionEnd >= this.minValue && selectionEnd <= this.maxValue && selectionStart <= selectionEnd) {
                if (this.selectionStart != selectionStart || this.selectionEnd != selectionEnd) {
                    $(this.element).find("input")
                                   .eq(0).attr("value", parseValue(round(selectionStart)))
                                   .end()
                                   .eq(1).attr("value", parseValue(round(selectionEnd)));

                    this.selectionStart = selectionStart;
                    this.selectionEnd = selectionEnd;
                    this.refresh();
                }
            }
        },

        refresh: function() {
            $t.trigger(this.element, 't:moveSelection', { values: [this.selectionStart, this.selectionEnd] });

            if (this.selectionStart == this.maxValue && this.selectionEnd == this.maxValue) {
                this._setZIndex("firstHandle");
            }
        },

        _setValueInRange: function (selectionStart, selectionEnd) {
            selectionStart = Math.max(selectionStart, this.minValue);
            selectionStart = Math.min(selectionStart, this.maxValue);

            selectionEnd = Math.max(selectionEnd, this.minValue);
            selectionEnd = Math.min(selectionEnd, this.maxValue);

            if (this.selectionStart == this.maxValue && this.selectionEnd == this.maxValue) {
                this._setZIndex("firstHandle");
            }

            this._update(selectionStart, selectionEnd);
        },

        _correctValues: function (selectionStartValue, selectionEndValue) {
            if (selectionStartValue >= selectionEndValue) {
                this._setValueInRange(selectionEndValue, selectionStartValue);
            } else {
                this._setValueInRange(selectionStartValue, selectionEndValue);
            }
        },

        _setZIndex: function (type) {
            var dragHandles = this.wrapper.find(".t-draghandle"),
                firstHandle = dragHandles.eq(0),
                secondHandle = dragHandles.eq(1),
                zIndex = "z-index";

            if (type == "firstHandle") {
                firstHandle.css(zIndex, "1");
                secondHandle.css(zIndex, "");
            } else {
                firstHandle.css(zIndex, "");
                secondHandle.css(zIndex, "1");
            }
        }
    };

    $t.rangeSlider.Selection = function (options) {
        var owner = options.owner;

        function moveSelection(values) {
            var selectionStartValue = values[0] - owner.minValue,
                selectionEndValue = values[1] - owner.minValue,
                selectionStartIndex = Math.ceil(round(selectionStartValue / owner.smallStep)),
                selectionEndIndex = Math.ceil(round(selectionEndValue / owner.smallStep)),
                selectionStart = owner._pixelStepsArray[selectionStartIndex],
                selectionEnd = owner._pixelStepsArray[selectionEndIndex],
                dragHandles = owner.wrapper.find(".t-draghandle"),
                halfHandle = parseInt(dragHandles.eq(0)[options.outerSize]() / 2, 10) + 1;

            dragHandles.eq(0).css(options.position, selectionStart - halfHandle)
                       .end()
                       .eq(1).css(options.position, selectionEnd - halfHandle);

            makeSelection(selectionStart, selectionEnd);
        }

        function makeSelection(selectionStart, selectionEnd) {
            var selection = 0,
                selectionPosition = 0,
                selectionDiv = owner.trackDiv.find(".t-slider-selection");

            selection = Math.abs(selectionStart - selectionEnd);
            selectionPosition = selectionStart < selectionEnd ? selectionStart : selectionEnd;

            selectionDiv[options.size](selection);
            selectionDiv.css(options.position, selectionPosition - 1);
        }

        moveSelection(owner.values());

        var handler = function (e) {
            moveSelection(e.values);
        };

        $(owner.element).bind({ "change": handler, "slide": handler, "t:moveSelection": handler  });
    };

    // jQuery extender
    $.fn.tRangeSlider = function (options) {
        return $t.create(this, {
            name: "tRangeSlider",
            init: function (element, options) {
                return new $t.rangeSlider(element, options);
            },
            options: options
        });
    };

    // default options
    $.fn.tRangeSlider.defaults = {
        enabled: true,
        minValue: 0,
        maxValue: 10,
        smallStep: 1,
        largeStep: 5,
        selectionStart: 0,
        selectionEnd: 10,
        orientation: "horizontal",
        tickPlacement: "both",
        tooltip: { enabled: true, format: "{0}" }
    };
})(jQuery);
(function ($) {
    var $t = $.telerik,
        splitBarSize = 7,
        pxUnitsRegex = /^\d+px$/i,
        percentageUnitsRegex = /^\d+(\.\d+)?%$/i;

    $t.scripts.push("telerik.splitter.js");

    function isPercentageSize(size) {
        return percentageUnitsRegex.test(size);
    }

    function isPixelSize(size) {
        return pxUnitsRegex.test(size);
    }

    function isFluid(size) {
        return !isPercentageSize(size) && !isPixelSize(size);
    }

    $t.splitter = function (element, options) {
        this.element = element;
        var $element = this.$element = $(element),
            self = this;

        $.extend(this, options);
        
        var orientation = this.orientation.toLowerCase() != "vertical" ? "horizontal" : "vertical",
            panesConfig = this.panes;

        this.orientation = orientation;

        $t.bind(this, {
            load: this.onLoad,
            expand: this.onExpand,
            collapse: this.onCollapse,
            contentLoad: this.onContentLoad,
            resize: function(e) {
                e.stopPropagation();
                
                self.resize.call(self, e);

                if ($.isFunction(self.onResize)) {
                    self.onResize.call(element, e);
                }
            }
        });

        $(window).resize(function() {
            $element.trigger("resize");
        });

        var splitbarSelector = ".t-splitbar-draggable-" + orientation,
            expandCollapseSelector = ".t-splitbar .t-icon:not(.t-resize-handle)";

        var arrowClick = function (arrowType) {
            return function(e) {
                var $target = $(e.target), $pane;

                if ($target.closest(".t-splitter")[0] != element)
                    return;

                if ($target.is(".t-" + arrowType + "-prev")) {
                    $pane = $target.parent().prev();
                } else {
                    $pane = $target.parent().next();
                }

                if (!$t.trigger(element, arrowType, { pane: $pane[0] })) {
                    self[arrowType]($pane[0]);
                }
            };
        };

        $element
            .addClass("t-widget").addClass("t-splitter")
            .children()
                .addClass("t-pane")
                .each($.proxy(function (index, pane) {
                    var $pane = $(pane);
                    $pane.data("pane", panesConfig ? panesConfig[index] : {})
                         .toggleClass("t-scrollable", panesConfig ? panesConfig[index].scrollable !== false : true);
                    this.ajaxRequest($pane);
                }, this))
            .end()
            .trigger("resize")
            .delegate(splitbarSelector, "mouseenter", function() { $(this).addClass("t-splitbar-" + orientation + "-hover"); })
            .delegate(splitbarSelector, "mouseleave", function() { $(this).removeClass("t-splitbar-" + orientation + "-hover"); })
            .delegate(expandCollapseSelector, "mouseenter", $t.hover)
            .delegate(expandCollapseSelector, "mouseleave", $t.leave)
            .delegate(".t-splitbar .t-collapse-next, .t-splitbar .t-collapse-prev", "click", arrowClick("collapse"))
            .delegate(".t-splitbar .t-expand-next, .t-splitbar .t-expand-prev", "click", arrowClick("expand"))
            .delegate(".t-splitbar", "dblclick", function(e) {
                var $target = $(e.target),
                    triggerAction = function(type, $pane) {
                        if (!$t.trigger(element, type, { pane: $pane[0] })) {
                            self[type]($pane[0]);
                        }
                    };

                if ($target.closest(".t-splitter")[0] != element)
                    return;

                var arrow = $target.children(".t-icon:not(.t-resize-handle)");

                if (arrow.length !== 1) {
                    return;
                }
                    
                if (arrow.is(".t-collapse-prev")) {
                    triggerAction("collapse", $target.prev());
                } else if (arrow.is(".t-collapse-next")) {
                    triggerAction("collapse", $target.next());
                } else if (arrow.is(".t-expand-prev")) {
                    triggerAction("expand", $target.prev());
                } else if (arrow.is(".t-expand-next")) {
                    triggerAction("expand", $target.next());
                }
            })
            .children(".t-pane").children(".t-splitter").trigger("resize").end().end()
            .parent().closest(".t-splitter")
                .bind("resize", function() {
                    $element.trigger("resize");
                });

        this.resizing = new $t.splitter.PaneResizing(this);
    };

    function panePropertyAccessor(propertyName, triggersResize) {
        return function(pane, value) {
            var paneConfig = $(pane).data("pane");

            if (arguments.length == 1) {
                return paneConfig[propertyName];
            }

            paneConfig[propertyName] = value;

            if (triggersResize) {
                this.$element.trigger("resize");
            }
        };
    }

    $t.splitter.prototype = {
        toggle: function(pane, expand) {
            var pane = $(pane),
                previousSplitBar = pane.prev(".t-splitbar"),
                nextSplitBar = pane.next(".t-splitbar"),
                paneConfig = pane.data("pane"),
                prevPaneConfig = pane.prevAll(".t-pane:first").data("pane"),
                nextPaneConfig = pane.nextAll(".t-pane:first").data("pane"),
                orentation = this.orientation,
                hoverClass = "t-splitbar-" + orentation + "-hover",
                draggableClass = "t-splitbar-draggable-" + orentation;

            if (arguments.length == 1) {
                expand = paneConfig.collapsed === undefined ? false : paneConfig.collapsed;
            }

            previousSplitBar
                .toggleClass(draggableClass, expand && paneConfig.resizable !== false && (!prevPaneConfig || prevPaneConfig.resizable !== false))
                .removeClass(hoverClass)
                .find(expand ? ".t-expand-next" : ".t-collapse-next")
                    .toggleClass("t-expand-next", !expand)
                    .toggleClass("t-collapse-next", expand);

            nextSplitBar
                .toggleClass(draggableClass, expand && paneConfig.resizable !== false && (!nextPaneConfig || nextPaneConfig.resizable !== false))
                .removeClass(hoverClass)
                .find(expand ? ".t-expand-prev" : ".t-collapse-prev")
                    .toggleClass("t-expand-prev", !expand)
                    .toggleClass("t-collapse-prev", expand);

            paneConfig.collapsed = !expand;

            this.$element.trigger("resize");
        },
        collapse: function(pane) {
            this.toggle(pane, false);
        },
        expand: function(pane) {
            this.toggle(pane, true);
        },
        size: panePropertyAccessor("size", true),
        minSize: panePropertyAccessor("minSize"),
        maxSize: panePropertyAccessor("maxSize"),
        ajaxOptions: function($pane, options) {
            var self = this;

            return $.extend({
                type: "POST",
                dataType: "html",
                success: function (data) {
                    $pane.html(data);
                    
                    $t.trigger(self.element, "contentLoad", { pane: $pane[0] });
                }
            }, options);
        },
        ajaxRequest: function(pane, url, data) {
            var $pane = $(pane),
                paneConfig = $pane.data("pane");

            if (url || paneConfig.contentUrl) {
                $pane.append("<span class='t-icon t-loading t-pane-loading' />");

                $.ajax(this.ajaxOptions($pane, {
                    url: url || paneConfig.contentUrl,
                    data: data || {}
                }));
            }
        },
        resize: function() {
            var $element = this.$element,
                panes = $element.children(":not(.t-splitbar):not(.t-ghost-splitbar)"),
                isHorizontal = this.orientation == "horizontal",
                splitBarsCount = $element.children(".t-splitbar").length,
                sizingProperty = isHorizontal ? "width" : "height",
                totalSize = $element[sizingProperty]();
                
            if (splitBarsCount === 0) {
                // add splitbars where necessary
                splitBarsCount = panes.length - 1;

                for (var i = 0; i < splitBarsCount; i++) {
                    var $pane = panes.eq(i),
                        previousPane = $pane.data("pane"),
                        nextPane = $pane.next().data("pane");

                    if (!nextPane) {
                        continue;
                    }

                    var isSplitBarDraggable = (previousPane.resizable !== false) && (nextPane.resizable !== false),
                        splitBarHtml = new $t.stringBuilder();

                    splitBarHtml.catIconIf = function(iconType, condition) {
                        if (condition) {
                            this.cat("<div class='t-icon ").cat(iconType).cat("' />");
                        }

                        return this;
                    };

                    splitBarHtml
                        .cat("<div class='t-splitbar t-state-default t-splitbar-").cat(this.orientation)
                                .catIf(" t-splitbar-draggable-", this.orientation, isSplitBarDraggable && !previousPane.collapsed && !nextPane.collapsed)
                            .cat("'>")
                            .catIconIf("t-collapse-prev", previousPane.collapsible && !previousPane.collapsed)
                            .catIconIf("t-expand-prev", previousPane.collapsible && previousPane.collapsed)
                            .catIconIf("t-resize-handle", isSplitBarDraggable)
                            .catIconIf("t-collapse-next", nextPane.collapsible && !nextPane.collapsed)
                            .catIconIf("t-expand-next", nextPane.collapsible && nextPane.collapsed)
                        .cat("</div>");

                    $pane.after(splitBarHtml.string());
                }
            }

            // discard splitbar sizes from total size
            totalSize -= splitBarSize * splitBarsCount;

            var sizedPanesWidth = 0,
                sizedPanesCount = 0,
                freeSizedPanes = $();
            
            panes.css({ position: "absolute", top: 0 })
                [sizingProperty](function() {
                    var config = $(this).data("pane"), size;

                    if (!config["collapsed"] && config["size"] && config.size.indexOf("NaN") != -1) { // resizing issues in iOS
                        return false;
                    } else {
                        if (config.collapsed) {
                            size = 0;
                        } else if (isFluid(config.size)) {
                            freeSizedPanes = freeSizedPanes.add(this);
                            return;
                        } else { // sized in px/%, not collapsed
                            size = parseInt(config.size, 10);

                            if (isPercentageSize(config.size)) {
                                size = Math.floor(size * totalSize / 100);
                            }
                        }

                        sizedPanesCount++;
                        sizedPanesWidth += size;

                        return size;
                    }
                });

            totalSize -= sizedPanesWidth;

            var freeSizePanesCount = freeSizedPanes.length,
                freeSizePaneWidth = Math.floor(totalSize / freeSizePanesCount);
         
            freeSizedPanes
                .slice(0, freeSizePanesCount - 1).css(sizingProperty, freeSizePaneWidth).end()
                .eq(freeSizePanesCount - 1).css(sizingProperty, totalSize - (freeSizePanesCount - 1) * freeSizePaneWidth);

            // arrange panes
            var sum = 0,
                alternateSizingProperty = isHorizontal ? "height" : "width",
                positioningProperty = isHorizontal ? "left" : "top",
                sizingDomProperty = isHorizontal ? "offsetWidth" : "offsetHeight";

            $element.children()
                .css(alternateSizingProperty, $element[alternateSizingProperty]())
                .each(function (i, child) {
                    child.style[positioningProperty] = Math.floor(sum) + "px";
                    sum += child[sizingDomProperty];
                });
        }
    };
    
    $t.splitter.PaneResizing = function(splitter) {
        this.owner = splitter;

        new $t.draggable({
            distance: 0,
            owner: splitter.element,
            selector: ".t-splitbar-draggable-horizontal, .t-splitbar-draggable-vertical",
            scope: splitter.element.id,
            start: $.proxy(this.start, this),
            drag: $.proxy(this.drag, this),
            stop: $.proxy(this.stop, this)
        });
    };

    $t.splitter.PaneResizing.prototype = {
        start: function(e) {
            if ($t.isTouch)
                e.stopImmediatePropagation();

            var splitBar = e.$draggable,
                previousPane = splitBar.prev(), nextPane = splitBar.next(),
                previousPaneConfig = previousPane.data("pane"), nextPaneConfig = nextPane.data("pane"),
                isHorizontal = this.owner.orientation === "horizontal",
                sizingProperty = isHorizontal ? "width" : "height",
                sizingDomProperty = isHorizontal ? "offsetWidth" : "offsetHeight",
                alternateSizingProperty = isHorizontal ? "height" : "width",
                location = $t.touchLocation(e);

            this.positioningProperty = isHorizontal ? "left" : "top";
            this.mousePositioningProperty = isHorizontal ? "x" : "y";
            this.previousPane = previousPane;
            this.nextPane = nextPane;
            this.initialSplitBarPosition = parseInt(splitBar[0].style[this.positioningProperty]);
            this.initialMousePosition = location[this.mousePositioningProperty];
            this.ghostSplitBar =
                $("<div class='t-ghost-splitbar t-ghost-splitbar-" + this.owner.orientation + " t-state-default' />")
                    .css(alternateSizingProperty, e.$draggable[alternateSizingProperty]())
                    .css(this.positioningProperty, this.initialSplitBarPosition)
                    .appendTo(this.owner.$element);

            // set this.minSize and this.maxSize to the lowest and highest values that the ghost splitbar can go to
            // keep in mind the minSize/maxSize of both the previous and next panes
            var prevBoundary = parseInt(previousPane[0].style[this.positioningProperty]),
                nextBoundary = parseInt(nextPane[0].style[this.positioningProperty]) + nextPane[0][sizingDomProperty] - splitBarSize,
                totalSize = this.owner.$element.css(sizingProperty),
                toPx = function (value) {
                    var val = parseInt(value, 10);
                    return (isPixelSize(value) ? val : (totalSize * val) / 100) || 0;
                },
                prevMinSize = toPx(previousPaneConfig.minSize),
                prevMaxSize = toPx(previousPaneConfig.maxSize) || nextBoundary - prevBoundary,
                nextMinSize = toPx(nextPaneConfig.minSize),
                nextMaxSize = toPx(nextPaneConfig.maxSize) || nextBoundary - prevBoundary;

            this.maxSize = Math.min(nextBoundary - nextMinSize, prevBoundary + prevMaxSize);
            this.minSize = Math.max(prevBoundary + prevMinSize, nextBoundary - nextMaxSize);

            $(document.body).css("cursor", splitBar.css("cursor"));
        },
        drag: function(e) {
            if ($t.isTouch)
                e.stopImmediatePropagation();

            var location = $t.touchLocation(e),
                position = Math.min(this.maxSize, Math.max(this.minSize, this.initialSplitBarPosition + (location[this.mousePositioningProperty] - this.initialMousePosition)));

            this.ghostSplitBar
                .toggleClass("t-restricted-size-" + this.owner.orientation, position == this.maxSize || position == this.minSize)
                [0].style[this.positioningProperty] = position + "px";
        },
        stop: function(e) {
            if ($t.isTouch)
                e.stopImmediatePropagation();

            if (e.keyCode !== 27) {

                var ghostPosition = parseInt(this.ghostSplitBar[0].style[this.positioningProperty]),
                    isHorizontal = this.owner.orientation === "horizontal",
                    sizingProperty = isHorizontal ? "width" : "height",
                    sizingDomProperty = isHorizontal ? "offsetWidth" : "offsetHeight",
                    previousPaneConfig = this.previousPane.data("pane"),
                    nextPaneConfig = this.nextPane.data("pane"),
                    previousPaneNewSize = ghostPosition - parseInt(this.previousPane[0].style[this.positioningProperty]),
                    nextPaneNewSize = parseInt(this.nextPane[0].style[this.positioningProperty]) + this.nextPane[0][sizingDomProperty] - ghostPosition - splitBarSize,
                    totalSize = this.owner.$element[sizingProperty](),
                    resized = !$t.isTouch || ($t.isTouch && !isNaN(previousPaneNewSize) && !isNaN(nextPaneNewSize));

                totalSize -= splitBarSize * this.owner.$element.children('.t-splitbar').length;

                var fluidPanesCount = this.owner.$element.children(".t-pane").filter(function() { return isFluid($(this).data("pane").size); }).length;

                if (!isFluid(previousPaneConfig.size) || fluidPanesCount > 1) {
                    if (isFluid(previousPaneConfig.size)) {
                        fluidPanesCount--;
                    }

                    previousPaneConfig.size = previousPaneNewSize + "px";
                }

                if (!isFluid(nextPaneConfig.size) || fluidPanesCount > 1) {
                    nextPaneConfig.size = nextPaneNewSize + "px";
                }
            }

            this.ghostSplitBar.remove();

            if (e.keyCode !== 27 && resized) {
                this.owner.$element.trigger("resize");
            }

            $(document.body).css("cursor", "");

            return false;
        }
    };

    $.fn.tSplitter = function (options) {
        return $t.create(this, {
            name: "tSplitter",
            init: function (element, options) {
                return new $t.splitter(element, options);
            },
            options: options
        });
    };

    // default options
    $.fn.tSplitter.defaults = {
        orientation: "horizontal"
    };
})(jQuery);(function ($) {

    var $t = $.telerik;
    $t.scripts.push("telerik.tabstrip.js");

    $t.tabstrip = function (element, options) {
        this.element = element;

        var $element = $(element);

        this.$contentElements = $element.find('> .t-content');

        $.extend(this, options);

        if (this.contentUrls)
            $element.find('.t-tabstrip-items > .t-item')
                .each($.proxy(function(index, item) {
                    $(item).find('.t-link').data('ContentUrl', this.contentUrls[index]);
                }, this));

        var enabledItems = '.t-tabstrip-items > .t-item:not(.t-state-disabled)';

        $element
            .delegate(enabledItems, 'mouseenter', $t.hover)
			.delegate(enabledItems, 'mouseleave', $t.leave)
			.delegate(enabledItems, options.activateEvent, $t.delegate(this, this._click))
            .delegate('.t-tabstrip-items > .t-state-disabled .t-link', 'click', $t.preventDefault);

        $t.bind(this, {
            select: $.proxy(function (e) {
                if (e.target == this.element && this.onSelect) $.proxy(this.onSelect, this.element)(e);
            }, this),
            contentLoad: this.onContentLoad,
            error: this.onError,
            load: this.onLoad
        });

        var selectedItems = $element.find('li.t-state-active'),
            $content = $(this.getContentElement(selectedItems.parent().children().index(selectedItems)));

        if ($content.length > 0 && $content[0].childNodes.length == 0)
            this.activateTab(selectedItems.eq(0));
    };

    $.extend($t.tabstrip.prototype, {

        select: function (li) {
            $(li).each($.proxy(function (index, item) {
                var $item = $(item);
                if ($item.is('.t-state-disabled,.t-state-active'))
                    return;

                this.activateTab($item);
            }, this));
        },

        enable: function (li) {
            $(li).addClass('t-state-default')
                 .removeClass('t-state-disabled');
        },

        disable: function (li) {
            $(li).removeClass('t-state-default')
                 .removeClass('t-state-active')
				 .addClass('t-state-disabled');
        },

        reload: function (li) {
            var tabstrip = this;

            $(li).each(function () {
                var $item = $(this),
                    contentUrl = $item.find('.t-link').data('ContentUrl');

                if (contentUrl) {
                    tabstrip.ajaxRequest($item, $(tabstrip.getContentElement($item.index())), null, contentUrl);
                }
            });
        },

        _click: function (e, element) {
            var $item = $(element),
                $link = $item.find('.t-link'),
                href = $link.attr('href'),
                $content = $(this.getContentElement($item.index()));

            if ($item.is('.t-state-disabled,.t-state-active')) {
                e.preventDefault();
                return;
            }

            if ($t.trigger(this.element, 'select', { item: $item[0], contentElement: $content[0] })) {
                e.preventDefault();
            } else {
                var isAnchor = $link.data('ContentUrl') || (href && (href.charAt(href.length - 1) == '#' || href.indexOf('#' + this.element.id + '-') != -1));

                if (!href || isAnchor || ($content.length > 0 && $content[0].childNodes.length == 0))
                    e.preventDefault();
                else return;

                if (this.activateTab($item))
                    e.preventDefault();
            }
        },

        activateTab: function ($item) {
            // deactivate previously active tab
            var itemIndex =
				$item.parent().children()
					.removeClass('t-state-active')
					.addClass('t-state-default')
					.index($item);

            // activate tab
            $item.removeClass('t-state-default').addClass('t-state-active');

            // handle content elements
            var $contentElements = this.$contentElements;

            if ($contentElements.length == 0)
                return false;

            var $visibleContentElements = $contentElements.filter('.t-state-active');

            // find associated content element
            var $content = $(this.getContentElement(itemIndex));

            var tabstrip = this;
            if ($content.length == 0) {
                $visibleContentElements.removeClass('t-state-active');

                $t.fx.rewind(tabstrip.effects, $visibleContentElements, {});

                return false;
            }

            var isAjaxContent = $content.is(':empty'),
                showContentElement = function () {
                    $content.addClass('t-state-active');

                    $t.fx.play(tabstrip.effects, $content, {});
                };

            $visibleContentElements.removeClass('t-state-active').stop(false, true);

            $t.fx.rewind(
                tabstrip.effects,
			    $visibleContentElements, {},
			    function () {
			        if ($item.hasClass('t-state-active')) {
			            if (!isAjaxContent)
			                showContentElement();
			            else
			                tabstrip.ajaxRequest($item, $content, function () {
			                    if ($item.hasClass('t-state-active'))
			                        showContentElement();
			                });
			        }
			    });

            return true;
        },

        getSelectedTabIndex: function () {
            return $(this.element).find('li.t-state-active').index();
        },

        getContentElement: function (itemIndex) {
            if (isNaN(itemIndex - 0)) return;

            var $contentElements = this.$contentElements,
                idTest = new RegExp('-' + (itemIndex + 1) + '$');

            for (var i = 0, len = $contentElements.length; i < len; i++) {
                if (idTest.test($contentElements[i].id)) {
                    return $contentElements[i];
                }
            }
        },

        ajaxRequest: function ($element, $content, complete, url) {
            if ($element.find('.t-loading').length)
                return;

            var $link = $element.find('.t-link'),
                data = {},
                statusIcon = null,
                loadingIconTimeout = setTimeout(function () {
                    statusIcon = $('<span class="t-icon t-loading"></span>').prependTo($link)
                }, 100);

            $.ajax({
                type: 'GET',
                cache: false,
                url: url || $link.data('ContentUrl') || $link.attr('href'),
                dataType: 'html',
                data: data,

                error: $.proxy(function (xhr, status) {
                    if ($t.ajaxError(this.element, 'error', xhr, status))
                        return;
                }, this),

                complete: function () {
                    clearTimeout(loadingIconTimeout);
                    if (statusIcon !== null)
                        statusIcon.remove();
                },

                success: $.proxy(function (data, textStatus) {
                    $content.html(data);

                    if (complete)
                        complete.call(this, $content);
                        
                    $t.trigger(this.element, 'contentLoad', { item: $element[0], contentElement: $content[0] });
                }, this)
            });
        }
    });

    // Plugin declaration
    $.fn.tTabStrip = function (options) {
        return $t.create(this, {
            name: 'tTabStrip',
            init: function (element, options) {
                return new $t.tabstrip(element, options);
            },
            options: options
        });
    }

    // default options
    $.fn.tTabStrip.defaults = {
        activateEvent: 'click',
        effects: $t.fx.toggle.defaults()
    };
})(jQuery);(function ($, undefined) {

    var $t = $.telerik,
        extend = $.extend,
        SUBGROUP = ">.t-group,>.t-animation-container>.t-group",
        TTREEVIEW = "t-treeview",
        TreeView;

    $t.scripts.push("telerik.treeview.js");

    function markAjaxLoadableNodes($element) {
        $element.find('.t-plus')
                .each(function () {
                    var item = $(this.parentNode);
                    item.parent().data('loaded', item.next('.t-group').length > 0);
                });
    }

    function updateNodeHtml(node) {
        var wrapper = node.find(">div"),
            subGroup = node.find(">ul"),
            toggleButton = wrapper.find(">.t-icon"),
            innerWrapper = wrapper.find(">.t-in"),
            tmp;

        if (node.hasClass("t-treeview")) {
            return;
        }

        if (!wrapper.length) {
            wrapper = $("<div />").prependTo(node);
        }

        if (!toggleButton.length && subGroup.length) {
            toggleButton = $("<span class='t-icon' />").prependTo(wrapper);
        } else if (!subGroup.length || !subGroup.children().length) {
            toggleButton.remove();
            subGroup.remove();
        }

        if (!innerWrapper.length) {
            innerWrapper = $("<span class='t-in' />").appendTo(wrapper)[0];

            // move all non-group content in the t-in container
            currentNode = wrapper[0].nextSibling;
            innerWrapper = wrapper.find(".t-in")[0];

            while (currentNode && currentNode.nodeName.toLowerCase() != "ul") {
                tmp = currentNode;
                currentNode = currentNode.nextSibling;
                innerWrapper.appendChild(tmp);
            }
        }
    }

    var rendering = {
        wrapperCssClass: function (group, item) {
            var result = "t-item",
                index = item.itemIndex;
        
            if (group.isFirstLevel && index == 0) {
                result += " t-first"
            }
        
            if (index == group.itemsCount-1) {
                result += " t-last";
            }
        
            return result;
        },
        cssClass: function(group, item) {
            var result = "",
                index = item.itemIndex,
                groupLength = group.itemsCount - 1;
        
            if (group.isFirstLevel && index == 0) {
                result += "t-top ";
            }
        
            if (index == 0 && index != groupLength) {
                result += "t-top";
            } else if (index == groupLength) {
                result += "t-bot";
            } else {
                result += "t-mid";
            }
        
            return result;
        },
        toggleButtonClass: function(item) {
            var result = "t-icon";
    
            if (item.isExpanded !== true) {
                result += " t-plus";
            } else {
                result += " t-minus";
            }
    
            if (item.enabled === false) {
                result += "-disabled";
            }
    
            return result;
        }
    };

    function updateNodeClasses(node, groupData, nodeData) {
        var wrapper = node.find(">div"),
            subGroup = node.find(">ul");

        if (node.hasClass("t-treeview")) {
            return;
        }

        if (!nodeData) {
            nodeData = {
                isExpanded: !(subGroup.css("display") == "none"),
                itemIndex: node.index(),
                enabled: !wrapper.find(">.t-in").hasClass("t-state-disabled")
            };
        }

        if (!groupData) {
            groupData = {
                isFirstLevel: node.parent().parent().hasClass(TTREEVIEW),
                itemsCount: node.parent().children().length
            };
        }

        // li
        node.removeClass("t-first t-last")
            .addClass(rendering.wrapperCssClass(groupData, nodeData));

        // div
        wrapper.removeClass("t-top t-mid t-bot")
           .addClass(rendering.cssClass(groupData, nodeData));

        // toggle button
        if (subGroup.length) {
            wrapper.find(">.t-icon")
                .removeClass("t-plus t-minus t-plus-disabled t-minus-disabled")
                .addClass(rendering.toggleButtonClass(nodeData));

            subGroup.addClass("t-group");
        }
    }

    TreeView = $t.treeview = function (element, options) {
        this.element = element;
        var $element = $(element);

        $.extend(this, options);

        var clickableItems = '.t-in:not(.t-state-selected,.t-state-disabled)';

        $('.t-in.t-state-selected', element)
            .live('mouseenter', $t.preventDefault);

        $element
            .delegate(clickableItems, 'mouseenter', $t.hover)
            .delegate(clickableItems, 'mouseleave', $t.leave)
            .delegate(clickableItems, 'click', $t.delegate(this, this.nodeSelect))
            .delegate('div:not(.t-state-disabled) .t-in', 'dblclick', $t.delegate(this, this.nodeClick))
            .delegate(':checkbox', 'click', $.proxy(this.checkboxClick, this))
            .delegate('.t-plus, .t-minus', $t.isTouch ? 'touchend' : 'click', $t.delegate(this, this.nodeClick));

        if (this.isAjax())
            markAjaxLoadableNodes($element);

        if (this.dragAndDrop) {
            $t.bind(this, {
                nodeDragStart: this.onNodeDragStart,
                nodeDragging: this.onNodeDragging,
                nodeDragCancelled: this.onNodeDragCancelled,
                nodeDrop: this.onNodeDrop,
                nodeDropped: this.onNodeDropped
            });

            (function (treeview) {
                var $dropCue = $("<div class='t-drop-clue' />");
                var $dropTarget;

                function start(e) {
                    if ($t.trigger(treeview.element, "nodeDragStart", { item: e.$draggable.closest(".t-item")[0] })) {
                        return false;
                    }

                    $dropCue.appendTo(treeview.element);
                }

                function drag(e) {
                    var status;

                    $dropTarget = $($t.eventTarget(e));

                    if (treeview.dragAndDrop.dropTargets && $dropTarget.closest(treeview.dragAndDrop.dropTargets).length > 0) {
                        // dragging node to a dropTarget area
                        status = "t-add";
                    } else if (!$.contains(treeview.element, $dropTarget[0])) {
                        // dragging node outside of treeview
                        status = "t-denied";
                    } else if ($.contains(e.$draggable.closest(".t-item")[0], $dropTarget[0])) {
                        // dragging node within itself
                        status = "t-denied";
                    } else {
                        // moving or reordering node
                        status = "t-insert-middle";

                        $dropCue.css("visibility", "visible");

                        var hoveredItem = $dropTarget.closest(".t-top,.t-mid,.t-bot");

                        if (hoveredItem.length) {
                            var itemHeight = hoveredItem.outerHeight(),
                                itemTop = hoveredItem.offset().top,
                                itemContent = $dropTarget.closest(".t-in"),
                                delta = itemHeight / (itemContent.length > 0 ? 4 : 2),
                                location = $t.touchLocation(e),

                                insertOnTop = location.y < (itemTop + delta),
                                insertOnBottom = (itemTop + itemHeight - delta) < location.y,
                                addChild = itemContent.length > 0 && !insertOnTop && !insertOnBottom;

                            hoveredItem.siblings(".t-top,.t-mid,.t-bot").children(".t-state-hover").removeClass("t-state-hover");
                            itemContent.toggleClass("t-state-hover", addChild);
                            $dropCue.css("visibility", addChild ? "hidden" : "visible");

                            if (addChild) {
                                status = "t-add";
                            } else {
                                var hoveredItemPos = hoveredItem.position();
                                hoveredItemPos.top += insertOnTop ? 0 : itemHeight;

                                $dropCue
                                    .css(hoveredItemPos)
                                    [insertOnTop ? "prependTo" : "appendTo"]($dropTarget.closest(".t-item").find("> div:first"));

                                if (insertOnTop && hoveredItem.hasClass("t-top")) {
                                    status = "t-insert-top";
                                }

                                if (insertOnBottom && hoveredItem.hasClass("t-bot")) {
                                    status = "t-insert-bottom";
                                }
                            }
                        }
                    }

                    $t.trigger(treeview.element, "nodeDragging", {
                        pageY: e.pageY,
                        pageX: e.pageX,
                        dropTarget: $dropTarget[0],
                        status: status.substring(2),
                        setStatusClass: function (value) { status = value },
                        item: e.$draggable.closest(".t-item")[0]
                    });

                    if (status.indexOf("t-insert") != 0) {
                        $dropCue.css("visibility", "hidden");
                    }

                    $t.dragCueStatus(e.$cue, status);
                }

                function stop(e) {
                    if (e.keyCode == 27) {
                        $t.trigger(treeview.element, 'nodeDragCancelled', { item: e.$draggable.closest('.t-item')[0] });
                    } else {
                        var dropPosition = 'over', destinationItem,
                            target = $t.eventTarget(e);

                        if ($dropCue.css('visibility') == 'visible') {
                            dropPosition = $dropCue.prevAll('.t-in').length > 0 ? 'after' : 'before';
                            destinationItem = $dropCue.closest('.t-item').find('> div');
                        } else if ($dropTarget) {
                            destinationItem = $dropTarget.closest('.t-top,.t-mid,.t-bot');
                        }

                        var isValid = !e.$cue.find('.t-drag-status').hasClass('t-denied'),
                            isDropPrevented = $t.trigger(treeview.element, 'nodeDrop', {
                                isValid: isValid,
                                dropTarget: target,
                                destinationItem: destinationItem.parent()[0],
                                dropPosition: dropPosition,
                                item: e.$draggable.closest('.t-item')[0]
                            });

                        if (!isValid) {
                            return false;
                        }

                        if (isDropPrevented || !$.contains(treeview.element, target)) {
                            return !isDropPrevented;
                        }

                        var sourceItem = e.$draggable.closest('.t-top,.t-mid,.t-bot');
                        var movedItem = sourceItem.parent(); // .t-item
                        var sourceGroup = sourceItem.closest('.t-group');
                        // dragging item within itself
                        if ($.contains(movedItem[0], target)) {
                            return false;
                        }
                        // normalize source group
                        if (movedItem.hasClass('t-last')) {
                            movedItem.removeClass('t-last')
                                    .prev()
                                    .addClass('t-last')
                                    .find('> div')
                                    .removeClass('t-top t-mid')
                                    .addClass('t-bot');
                        }

                        // perform reorder / move
                        if ($dropCue.css('visibility') == 'visible') {
                            destinationItem.parent()[dropPosition](movedItem);
                        } else {
                            var targetGroup = destinationItem.next('.t-group');

                            if (targetGroup.length === 0) {
                                targetGroup = $('<ul class="t-group" />').appendTo(destinationItem.parent());

                                if (!treeview.isAjax()) {
                                    destinationItem.prepend('<span class="t-icon t-minus" />');
                                } else {
                                    targetGroup.hide();
                                    treeview.nodeToggle(null, destinationItem.parent(), true);
                                    targetGroup.show();
                                }
                            }

                            targetGroup.append(movedItem);

                            if (destinationItem.find('> .t-icon').hasClass('t-plus'))
                                treeview.nodeToggle(null, destinationItem.parent(), true);
                        }

                        updateNodeClasses(movedItem);
                        updateNodeClasses(movedItem.prev());
                        updateNodeClasses(movedItem.next());

                        // remove source group if it is empty
                        if (sourceGroup.children().length === 0) {
                            sourceGroup.prev('div').find('.t-plus,.t-minus').remove();
                            sourceGroup.remove();
                        }

                        if ($t.isTouch) {
                            destinationItem.children(".t-in").removeClass("t-state-hover");
                        }

                        $t.trigger(treeview.element, 'nodeDropped', {
                            destinationItem: destinationItem.closest('.t-item')[0],
                            dropPosition: dropPosition,
                            item: sourceItem.parent('.t-item')[0]
                        });

                        return false;
                    }
                }

                new $t.draggable({
                   owner: treeview.element,
                   selector: 'div:not(.t-state-disabled) .t-in',
                   scope: treeview.element.id,
                   cue: function (e) {
                        return $t.dragCue($t.encode(e.$draggable.text()));
                   },
                   start: start,
                   drag: drag,
                   stop: stop,
                   destroy: function (e) {
                        $dropCue.remove();
                        e.$cue.remove();
                   }
                });

            })(this);
        }

        $t.bind(this, {
            expand: this.onExpand,
            collapse: this.onCollapse,
            select: $.proxy(function (e) {
                if (e.target == this.element && this.onSelect) $.proxy(this.onSelect, this.element)(e);
            }, this),
            checked: this.onChecked,
            error: this.onError,
            load: this.onLoad,
            dataBinding: this.onDataBinding,
            dataBound: this.onDataBound
        });
    };

    TreeView.prototype = {

        expand: function (li) {
            $(li, this.element).each($.proxy(function (index, item) {
                var $item = $(item);
                var contents = $item.find('> .t-group, > .t-content');
                if ((contents.length > 0 && !contents.is(':visible')) || (this.isAjax() && $item.data('loaded') === false)) {
                    this.nodeToggle(null, $item);
                }
            }, this));
        },

        collapse: function (li) {
            $(li, this.element).each($.proxy(function (index, item) {
                var $item = $(item),
                    contents = $item.find('> .t-group, > .t-content');
                if (contents.length > 0 && contents.is(':visible')) {
                    this.nodeToggle(null, $item);
                }
            }, this));
        },

        enable: function (li) {
            this.toggle(li, true);
        },

        disable: function (li) {
            this.toggle(li, false);
        },

        toggle: function (li, enable) {
            $(li, this.element).each($.proxy(function (index, item) {
                var $item = $(item),
                    isCollapsed = !$item.find('> .t-group, > .t-content').is(':visible');

                if (!enable) {
                    this.collapse($item);
                    isCollapsed = true;
                }

                $item.find('> div > .t-in')
                        .toggleClass('t-state-default', enable)
                        .toggleClass('t-state-disabled', !enable)
                     .end()
                     .find('> div > .t-icon')
                        .toggleClass('t-plus', isCollapsed && enable)
                        .toggleClass('t-plus-disabled', isCollapsed && !enable)
                        .toggleClass('t-minus', !isCollapsed && enable)
                        .toggleClass('t-minus-disabled', !isCollapsed && !enable);

                var checkbox = $item.find('> div > .t-checkbox > :checkbox');

                if (enable) {
                    checkbox.removeAttr('disabled');
                } else {
                    checkbox.attr('disabled', 'disabled');
                }

            }, this));
        },

        reload: function (li) {
            var treeView = this;
            $(li).each(function () {
                var $item = $(this);
                $item.find('.t-group').remove();
                treeView.ajaxRequest($item);
            });
        },

        shouldNavigate: function (element) {
            var contents = $(element).closest('.t-item').find('> .t-content, > .t-group');
            var href = $(element).attr('href');

            return !((href && (href.charAt(href.length - 1) == '#' || href.indexOf('#' + this.element.id + '-') != -1)) ||
                    (contents.length > 0 && contents.children().length == 0));
        },

        nodeSelect: function (e, element) {

            if (!this.shouldNavigate(element))
                e.preventDefault();

            var $element = $(element);

            if (!$element.hasClass('.t-state-selected') &&
                !$t.trigger(this.element, 'select', { item: $element.closest('.t-item')[0] })) {
                $('.t-in', this.element).removeClass('t-state-hover t-state-selected');

                $element.addClass('t-state-selected');
            }
        },

        nodeToggle: function (e, $item, suppressAnimation) {
            if ($item.find('.t-minus').length == 0 && $item.find('.t-plus').length == 0) {
                return;
            }

            if (e != null)
                e.preventDefault();

            if ($item.data('animating')
             || $item.find('> div > .t-in').hasClass('t-state-disabled'))
                return;

            $item.data('animating', !suppressAnimation);

            var contents = $item.find('>.t-group, >.t-content, >.t-animation-container>.t-group, >.t-animation-container>.t-content'),
                isExpanding = !contents.is(':visible');

            if (contents.children().length > 0 && $item.data('loaded') !== false) {
                if (!$t.trigger(this.element, isExpanding ? 'expand' : 'collapse', { item: $item[0] })) {
                    $item.find('> div > .t-icon')
                        .toggleClass('t-minus', isExpanding)
                        .toggleClass('t-plus', !isExpanding);
                    
                    if (!suppressAnimation) {
                        $t.fx[isExpanding ? 'play' : 'rewind'](this.effects, contents, { direction: 'bottom' }, function () {
                            $item.data('animating', false);
                        });
                    } else {
                        contents[isExpanding ? 'show' : 'hide']();
                    }
                } else {
                    $item.data('animating', false);
                }
            } else if (isExpanding && this.isAjax() && (contents.length == 0 || $item.data('loaded') === false)) {
                if (!$t.trigger(this.element, isExpanding ? 'expand' : 'collapse', { item: $item[0] })) {
                    this.ajaxRequest($item);
                } else {
                    $item.data('animating', false);
                }
            }
        },

        nodeClick: function (e, element) {
            var $element = $(element),
                $item = $element.closest('.t-item');

            if ($element.hasClass('t-plus-disabled') || $element.hasClass('t-minus-disabled'))
                return;

            this.nodeToggle(e, $item);
        },

        isAjax: function () {
            return this.ajax || this.ws || this.onDataBinding;
        },

        url: function (which) {
            return (this.ajax || this.ws)[which];
        },

        ajaxOptions: function ($item, options) {
            var result = {
                type: 'POST',
                dataType: 'text',
                error: $.proxy(function (xhr, status) {
                    if ($t.ajaxError(this.element, 'error', xhr, status))
                        return;

                    if (status == 'parsererror')
                        alert('Error! The requested URL did not return JSON.');
                }, this),

                success: $.proxy(function (data) {
                    data = eval("(" + data + ")");
                    data = data.d || data; // Support the `d` returned by MS Web Services
                    this.dataBind($item, data);
                }, this),

                complete: function() {
                    $item.data("animating", false);
                }
            };

            result = $.extend(result, options);

            var node = this.ws ? result.data.node = {} : result.data;

            if ($item.hasClass('t-item')) {
                node[this.queryString.value] = this.getItemValue($item);
                node[this.queryString.text] = this.getItemText($item);

                var itemCheckbox = $item.find('.t-checkbox:first :checkbox');
                if (itemCheckbox.length)
                    node[this.queryString.checked] = itemCheckbox.is(':checked');
            }

            if (this.ws) {
                result.data = $t.toJson(result.data);
                result.contentType = 'application/json; charset=utf-8';
            }

            return result;
        },

        ajaxRequest: function ($item) {

            $item = $item || $(this.element);

            var e = { item: $item[0] };

            if ($t.trigger(this.element, 'dataBinding', e) || (!this.ajax && !this.ws))
                return;

            $item.data('loadingIconTimeout', setTimeout(function () {
                $item.find('> div > .t-icon').addClass('t-loading');
            }, 100));

            $.ajax(this.ajaxOptions($item, {
                data: $.extend({}, e.data),
                url: this.url('selectUrl')
            }));
        },

        bindTo: function (data) {
            this.dataBind(this.element, data);
        },

        dataBind: function ($item, data) {
            $item = $($item); // can be called from user code with dom objects

            var group = $item.find('> .t-group'),
                element = this.element,
                icon = $item.find('> div > .t-icon'),
                hasData = data.length > 0;
            
            if (data.length == 0) {
                icon.remove();
                group.remove();
                $t.trigger(element, 'dataBound', { item: $item[0] });
                return;
            } else {
                if (icon.length == 0) {
                    $item.find("> div").prepend('<span class="t-icon t-plus" />');
                }
            }

            var groupHtml = new $t.stringBuilder(),
                isGroup = group.length == 0,
                groupLevel = $item.find('> div > .t-checkbox :input[name="' + element.id + '_checkedNodes.Index"]').val();

            if (!groupLevel && $item[0] != element) {
                var itemParents = $item.parentsUntil(".t-treeview", ".t-item").andSelf().map(function(x, item) { return $(item).index(); });
                groupLevel = Array.prototype.join.call(itemParents, ":");
            }

            var isExpanded = (isGroup ? $item.eq(0).is('.t-treeview') ? true : data[0].Expanded : false);

            TreeView.getGroupHtml({
                data: data,
                html: groupHtml,
                isAjax: this.isAjax(),
                isFirstLevel: $item.hasClass('t-treeview'),
                showLines: this.showLines,
                showCheckBoxes: this.showCheckBox,
                groupLevel: groupLevel,
                isExpanded: isExpanded,
                renderGroup: isGroup,
                elementId: element.id
            });

            if (group.length > 0 && $item.data('loaded') === false) {
                $(groupHtml.string()).prependTo(group);
            } else if (group.length > 0 && $item.data('loaded') !== false) {
                group.html(groupHtml.string());
            } else if (group.length == 0)
                group = $(groupHtml.string()).appendTo($item);

            $item.data('animating', true);

            $t.fx.play(this.effects, group, { direction: 'bottom' }, function () {
                $item.data('animating', false);
            });

            clearTimeout($item.data('loadingIconTimeout'));

            if ($item.hasClass('t-item')) {
                $item.data('loaded', true)
                    .find('.t-icon:first')
                        .removeClass('t-loading')
                        .removeClass('t-plus')
                        .addClass('t-minus');
            }

            if (this.isAjax()) {
                markAjaxLoadableNodes($item);
            }

            $t.trigger(element, 'dataBound', { item: $item[0] });
        },

        checkboxClick: function (e) {
            var element = $(e.target),
                isChecked = element.is(':checked');

            var isEventPrevented =
                $t.trigger(this.element, 'checked', {
                    item: element.closest('.t-item')[0],
                    checked: isChecked
                });

            if (!isEventPrevented) {
                this.nodeCheck(element, isChecked);
            } else {
                e.preventDefault();
            }
        },

        nodeCheck: function (li, isChecked) {
            $(li, this.element).each($.proxy(function (i, item) {
                var $item = $(item).closest('.t-item'),
                    $checkboxHolder = $("> div > .t-checkbox", $item),
                    arrayName = this.element.id + '_checkedNodes',
                    index = $checkboxHolder.find(':input[name="' + arrayName + '.Index"]').val(),
                    checkbox = $checkboxHolder.find(':checkbox');

                $checkboxHolder.find('[type=hidden]').filter(function() {
                    // use filter because of nested square brackets
                    return ($(this).attr("name").indexOf(arrayName + '[' + index + '].') > -1);
                }).remove();
                
                checkbox.attr('value', isChecked ? "True" : "False");
                
                if (isChecked) {
                    checkbox.attr('checked', 'checked');
                    $(TreeView.getNodeInputsHtml(this.getItemValue($item), this.getItemText($item), arrayName, index))
                        .appendTo($checkboxHolder);
                } else {
                    checkbox.attr('checked', false);
                }
            }, this));
        },

        getItemText: function (item) {
            return $(item).find('> div > .t-in').text();
        },

        getItemValue: function (item) {
            return $(item).find('>div>:input[name="itemValue"]').val() || this.getItemText(item);
        },

        findByText: function(text) {
            return $(this.element).find(".t-in").filter(function(i, element) {
                return $(element).text() == text;
            }).closest(".t-item");
        },

        findByValue: function(value) {
            return $(this.element).find("input[name='itemValue']").filter(function(i, element) {
                return $(element).val() == value;
            }).closest(".t-item");
        },

        _insertNode: function(nodeData, index, parentNode, group, insertCallback) {
            var that = this,
                updatedGroupLength = group.children().length + 1,
                isArrayData = $.isArray(nodeData),
                fromNodeData = isArrayData || $.isPlainObject(nodeData),
                groupData = {
                    showCheckBoxes: that.showCheckBox,
                    isFirstLevel: parentNode.hasClass(TTREEVIEW),
                    isExpanded: true,
                    itemsCount: updatedGroupLength
                }, node, i, html = new $t.stringBuilder();

            if (fromNodeData) {
                if (isArrayData) {
                    for (i = 0; i < nodeData.length; i++) {
                        TreeView.getItemHtml(extend({
                            html: html,
                            itemIndex: index + i,
                            item: nodeData[i]
                        }, groupData));
                    }

                } else {
                    TreeView.getItemHtml(extend({
                        html: html,
                        itemIndex: index,
                        item: nodeData
                    }, groupData));
                }

                node = $(html.string());
            } else {
                node = $(nodeData);

                if (group.children()[index - 1] == node[0]) {
                    return node;
                }

                if (node.closest(".t-treeview")[0] == that.element) {
                    that.remove(node);
                }
            }

            if (!group.length) {
                var groupHtml = new $t.stringBuilder();

                TreeView.getGroupHtml(extend({
                    html: groupHtml,
                    renderGroup: true
                }, groupData));

                group = $(groupHtml.string()).appendTo(parentNode);
            }

            insertCallback(node, group);

            if (parentNode.hasClass("t-item")) {
                updateNodeHtml(parentNode);
                updateNodeClasses(parentNode);
            }

            if (!fromNodeData) {
                updateNodeClasses(node);
            }

            updateNodeClasses(node.prev());
            updateNodeClasses(node.next());

            return node;
        },

        insertAfter: function (nodeData, referenceNode) {
            var group = referenceNode.parent();

            return this._insertNode(nodeData, referenceNode.index() + 1, group.parent(), group, function(item, group) {
                item.insertAfter(referenceNode);
            });
        },

        insertBefore: function (nodeData, referenceNode) {
            var group = referenceNode.parent();

            return this._insertNode(nodeData, referenceNode.index(), group.parent(), group, function(item, group) {
                item.insertBefore(referenceNode);
            });
        },

        append: function (nodeData, parentNode) {
            parentNode = $(parentNode || this.element);

            var group = parentNode.find(SUBGROUP);

            return this._insertNode(nodeData, group.children().length, parentNode, group, function(item, group) {
                item.appendTo(group);
            });
        },

        remove: function (node) {
            node = $(node);

            var that = this,
                parentNode = node.parent().parent(),
                prevSibling = node.prev(),
                nextSibling = node.next();

            node.remove();

            if (parentNode.hasClass("t-item")) {
                updateNodeHtml(parentNode);
                updateNodeClasses(parentNode);
            }

            updateNodeClasses(prevSibling);
            updateNodeClasses(nextSibling);
        }
    };

    // client-side rendering
    $.extend(TreeView, {
        getNodeInputsHtml: function (itemValue, itemText, arrayName, value) {
            return new $t.stringBuilder()
                .cat('<input type="hidden" value="')
                .cat(itemValue)
                .cat('" name="' + arrayName + '[').cat(value).cat('].Value" class="t-input">')
                .cat('<input type="hidden" value="')
                .cat(itemText)
                .cat('" name="' + arrayName + '[').cat(value).cat('].Text" class="t-input">')
                .string();
        },

        getItemHtml: function (options) {
            var item = options.item,
                html = options.html,
                isFirstLevel = options.isFirstLevel,
                groupLevel = options.groupLevel,
                itemIndex = options.itemIndex,
                itemsCount = options.itemsCount,
                absoluteIndex = new $t.stringBuilder()
                                    .cat(groupLevel).catIf(':', groupLevel).cat(itemIndex)
                                .string(),
                serializeAttributes = function(attributes) {
                var i ;
                    if (typeof attributes != "undefined") {
                        for (i in attributes) {
                            html.cat(' ').cat(i).cat('="').cat(attributes[i]).cat('"');
                        }
                    }
                },
                htmlAttributes = item.HtmlAttributes || item.htmlAttributes || {};

            html.cat('<li class="t-item')
                    .catIf(' t-first', isFirstLevel && itemIndex == 0)
                    .catIf(' t-last', itemIndex == itemsCount - 1)
                .cat('">')
                .cat('<div class="')
                    .catIf('t-top ', isFirstLevel && itemIndex == 0)
                    .catIf('t-top', itemIndex != itemsCount - 1 && itemIndex == 0)
                    .catIf('t-mid', itemIndex != itemsCount - 1 && itemIndex != 0)
                    .catIf('t-bot', itemIndex == itemsCount - 1)
                    .catIf(' ' + htmlAttributes["class"], htmlAttributes["class"])
                .cat('"');

            delete htmlAttributes["class"];

            serializeAttributes(htmlAttributes);
                
            html.cat('>');

            if ((options.isAjax && item.LoadOnDemand) || (item.Items && item.Items.length > 0))
                html.cat('<span class="t-icon')
                        .catIf(' t-plus', item.Expanded !== true)
                        .catIf(' t-minus', item.Expanded === true)
                        .catIf('-disabled', item.Enabled === false) // t-(plus|minus)-disabled
                    .cat('"></span>');

            if (options.showCheckBoxes && item.Checkable !== false) {
                var arrayName = options.elementId + '_checkedNodes';

                html.cat('<span class="t-checkbox">')
                        .cat('<input type="hidden" value="').cat(absoluteIndex)
                        .cat('" name="').cat(arrayName).cat('.Index')
                        .cat('" class="t-input"/>')

                        .cat('<input type="checkbox" value="').cat(item.Checked === true ? 'True' : 'False')
                        .cat('" class="t-input')
                        .cat('" name="').cat(arrayName).cat('[').cat(absoluteIndex).cat('].Checked"')
                        .catIf(' disabled="disabled"', item.Enabled === false)
                        .catIf(' checked="checked"', item.Checked)
                    .cat('/>');

                if (item.Checked)
                    html.cat(TreeView.getNodeInputsHtml(item.Value, item.Text, arrayName, absoluteIndex));

                html.cat('</span>');
            }

            var navigateUrl = item.NavigateUrl || item.Url;

            html.cat(navigateUrl ? '<a href="' + navigateUrl + '" class="t-link ' : '<span class="')
                    .cat('t-in')
                    .catIf(' t-state-disabled', item.Enabled === false)
                    .catIf(' t-state-selected', item.Selected === true)
                .cat('">');

            if (item.ImageUrl != null) {
                html.cat('<img');

                serializeAttributes($.extend({
                    alt: "",
                    "class": "t-image",
                    src: item.ImageUrl
                }, item.ImageHtmlAttributes || item.imageHtmlAttributes || {}));
                
                html.cat(' />');
            }

            if (item.SpriteCssClasses != null)
                html.cat('<span class="t-sprite ').cat(item.SpriteCssClasses).cat('"></span>');

            html.catIf(item.Text, item.Encoded === false)
                .catIf(item.Text.replace(/</g, '&lt;').replace(/>/g, '&gt;'), item.Encoded !== false)
                .cat(navigateUrl ? '</a>' : '</span>');

            if (item.Value)
                html.cat('<input type="hidden" class="t-input" name="itemValue" value="')
                    .cat(item.Value)
                    .cat('" />');

            html.cat('</div>');

            if (item.Items && item.Items.length > 0)
                TreeView.getGroupHtml({
                    data: item.Items,
                    html: html,
                    isAjax: options.isAjax,
                    isFirstLevel: false,
                    showCheckBoxes: options.showCheckBoxes,
                    groupLevel: absoluteIndex,
                    isExpanded: item.Expanded,
                    elementId: options.elementId
                });

            html.cat('</li>');
        },

        getGroupHtml: function (options) {
            var data = options.data,
                html = options.html,
                showLines = options.showLines,
                isFirstLevel = options.isFirstLevel,
                renderGroup = options.renderGroup;

            if (renderGroup !== false) {
                html.cat('<ul class="t-group')
                    .catIf(' t-treeview-lines', isFirstLevel && (typeof showLines == typeof undefined || showLines))
                    .cat('"')
                    .catIf(' style="display:none"', options.isExpanded !== true)
                    .cat('>');
            }

            if (data && data.length > 0) {
                var getItemHtml = TreeView.getItemHtml;

                for (var i = 0, len = data.length; i < len; i++) {
                    getItemHtml({
                        item: data[i],
                        html: html,
                        isAjax: options.isAjax,
                        isFirstLevel: isFirstLevel,
                        showCheckBoxes: options.showCheckBoxes,
                        groupLevel: options.groupLevel,
                        itemIndex: i,
                        itemsCount: len,
                        elementId: options.elementId
                    });
                }
            }

            if (renderGroup !== false)
                html.cat('</ul>');
        }
    });

    $.fn.tTreeView = function (options) {
        return $t.create(this, {
            name: 'tTreeView',
            init: function (element, options) {
                return new TreeView(element, options);
            },
            options: options,
            success: function (treeView) {
                if (treeView.isAjax() && $(treeView.element).find('.t-item').length == 0)
                    treeView.ajaxRequest();
            }
        });
    };

    $.fn.tTreeView.defaults = {
        effects: $t.fx.property.defaults('height'),
        queryString: {
            text: 'Text',
            value: 'Value',
            checked: 'Checked'
        }
    };
})(jQuery);
